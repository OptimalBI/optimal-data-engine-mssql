/*
Deployment script for ode_to_mssql

This code was generated by a tool.
Changes to this file may cause incorrect behavior and will be lost if
the code is regenerated.
*/

GO
SET ANSI_NULLS, ANSI_PADDING, ANSI_WARNINGS, ARITHABORT, CONCAT_NULL_YIELDS_NULL, QUOTED_IDENTIFIER ON;

SET NUMERIC_ROUNDABORT OFF;


GO
:setvar DatabaseName "ode_to_mssql"
:setvar DefaultFilePrefix "ode_to_mssql"
:setvar DefaultDataPath ""
:setvar DefaultLogPath ""

GO
:on error exit
GO
/*
Detect SQLCMD mode and disable script execution if SQLCMD mode is not supported.
To re-enable the script after enabling SQLCMD mode, execute the following:
SET NOEXEC OFF; 
*/
:setvar __IsSqlCmdEnabled "True"
GO
IF N'$(__IsSqlCmdEnabled)' NOT LIKE N'True'
    BEGIN
        PRINT N'SQLCMD mode must be enabled to successfully execute this script.';
        SET NOEXEC ON;
    END


GO
USE [master];


GO

IF (DB_ID(N'$(DatabaseName)') IS NOT NULL) 
BEGIN
    ALTER DATABASE [$(DatabaseName)]
    SET SINGLE_USER WITH ROLLBACK IMMEDIATE;
    DROP DATABASE [$(DatabaseName)];
END

GO
PRINT N'Creating $(DatabaseName)...'
GO
CREATE DATABASE [$(DatabaseName)] COLLATE SQL_Latin1_General_CP1_CI_AS
GO
IF EXISTS (SELECT 1
           FROM   [master].[dbo].[sysdatabases]
           WHERE  [name] = N'$(DatabaseName)')
    BEGIN
        ALTER DATABASE [$(DatabaseName)]
            SET ANSI_NULLS ON,
                ANSI_PADDING ON,
                ANSI_WARNINGS ON,
                ARITHABORT ON,
                CONCAT_NULL_YIELDS_NULL ON,
                NUMERIC_ROUNDABORT OFF,
                QUOTED_IDENTIFIER ON,
                ANSI_NULL_DEFAULT ON,
                CURSOR_DEFAULT LOCAL,
                RECOVERY SIMPLE,
                CURSOR_CLOSE_ON_COMMIT OFF,
                AUTO_CREATE_STATISTICS ON,
                AUTO_SHRINK OFF,
                AUTO_UPDATE_STATISTICS ON,
                RECURSIVE_TRIGGERS OFF 
            WITH ROLLBACK IMMEDIATE;
        ALTER DATABASE [$(DatabaseName)]
            SET AUTO_CLOSE OFF 
            WITH ROLLBACK IMMEDIATE;
    END


GO
IF EXISTS (SELECT 1
           FROM   [master].[dbo].[sysdatabases]
           WHERE  [name] = N'$(DatabaseName)')
    BEGIN
        ALTER DATABASE [$(DatabaseName)]
            SET ALLOW_SNAPSHOT_ISOLATION OFF;
    END


GO
IF EXISTS (SELECT 1
           FROM   [master].[dbo].[sysdatabases]
           WHERE  [name] = N'$(DatabaseName)')
    BEGIN
        ALTER DATABASE [$(DatabaseName)]
            SET READ_COMMITTED_SNAPSHOT OFF 
            WITH ROLLBACK IMMEDIATE;
    END


GO
IF EXISTS (SELECT 1
           FROM   [master].[dbo].[sysdatabases]
           WHERE  [name] = N'$(DatabaseName)')
    BEGIN
        ALTER DATABASE [$(DatabaseName)]
            SET AUTO_UPDATE_STATISTICS_ASYNC OFF,
                PAGE_VERIFY NONE,
                DATE_CORRELATION_OPTIMIZATION OFF,
                ENABLE_BROKER,
                PARAMETERIZATION SIMPLE,
                SUPPLEMENTAL_LOGGING OFF 
            WITH ROLLBACK IMMEDIATE;
    END


GO
IF IS_SRVROLEMEMBER(N'sysadmin') = 1
    BEGIN
        IF EXISTS (SELECT 1
                   FROM   [master].[dbo].[sysdatabases]
                   WHERE  [name] = N'$(DatabaseName)')
            BEGIN
                EXECUTE sp_executesql N'ALTER DATABASE [$(DatabaseName)]
    SET TRUSTWORTHY ON,
        DB_CHAINING OFF 
    WITH ROLLBACK IMMEDIATE';
            END
    END
ELSE
    BEGIN
        PRINT N'The database settings cannot be modified. You must be a SysAdmin to apply these settings.';
    END


GO
IF IS_SRVROLEMEMBER(N'sysadmin') = 1
    BEGIN
        IF EXISTS (SELECT 1
                   FROM   [master].[dbo].[sysdatabases]
                   WHERE  [name] = N'$(DatabaseName)')
            BEGIN
                EXECUTE sp_executesql N'ALTER DATABASE [$(DatabaseName)]
    SET HONOR_BROKER_PRIORITY OFF 
    WITH ROLLBACK IMMEDIATE';
            END
    END
ELSE
    BEGIN
        PRINT N'The database settings cannot be modified. You must be a SysAdmin to apply these settings.';
    END


GO
ALTER DATABASE [$(DatabaseName)]
    SET TARGET_RECOVERY_TIME = 0 SECONDS 
    WITH ROLLBACK IMMEDIATE;


GO
IF EXISTS (SELECT 1
           FROM   [master].[dbo].[sysdatabases]
           WHERE  [name] = N'$(DatabaseName)')
    BEGIN
        ALTER DATABASE [$(DatabaseName)]
            SET FILESTREAM(NON_TRANSACTED_ACCESS = OFF),
                CONTAINMENT = NONE 
            WITH ROLLBACK IMMEDIATE;
    END


GO
IF EXISTS (SELECT 1
           FROM   [master].[dbo].[sysdatabases]
           WHERE  [name] = N'$(DatabaseName)')
    BEGIN
        ALTER DATABASE [$(DatabaseName)]
            SET AUTO_CREATE_STATISTICS ON(INCREMENTAL = OFF),
                MEMORY_OPTIMIZED_ELEVATE_TO_SNAPSHOT = OFF,
                DELAYED_DURABILITY = DISABLED 
            WITH ROLLBACK IMMEDIATE;
    END


GO
USE [$(DatabaseName)];


GO
IF fulltextserviceproperty(N'IsFulltextInstalled') = 1
    EXECUTE sp_fulltext_database 'enable';


GO
PRINT N'Creating [SBLogin]...';


GO
CREATE LOGIN [SBLogin]
    WITH PASSWORD = N'lqfuhrjGFsTiVapsdjdsugdamsFT7_&#$!~<riz2Itvsm|7d';


GO
ALTER LOGIN [SBLogin] DISABLE;


GO
PRINT N'Creating [SBLogin]...';


GO
CREATE USER [SBLogin] FOR LOGIN [SBLogin];


GO
REVOKE CONNECT TO [SBLogin];


GO
PRINT N'Creating <unnamed>...';


GO
EXECUTE sp_addrolemember @rolename = N'db_owner', @membername = N'SBLogin';


GO
PRINT N'Creating [dv_config]...';


GO
CREATE SCHEMA [dv_config]
    AUTHORIZATION [dbo];


GO
PRINT N'Creating [dv_integrity]...';


GO
CREATE SCHEMA [dv_integrity]
    AUTHORIZATION [dbo];


GO
PRINT N'Creating [dv_log]...';


GO
CREATE SCHEMA [dv_log]
    AUTHORIZATION [dbo];


GO
PRINT N'Creating [dv_release]...';


GO
CREATE SCHEMA [dv_release]
    AUTHORIZATION [dbo];


GO
PRINT N'Creating [dv_scheduler]...';


GO
CREATE SCHEMA [dv_scheduler]
    AUTHORIZATION [dbo];


GO
PRINT N'Creating [log4]...';


GO
CREATE SCHEMA [log4]
    AUTHORIZATION [dbo];


GO
PRINT N'Creating [ODE_Release]...';


GO
CREATE SCHEMA [ODE_Release]
    AUTHORIZATION [dbo];


GO
PRINT N'Creating [dbo].[dv_column_type]...';


GO
CREATE TYPE [dbo].[dv_column_type] AS TABLE (
    [column_name]                VARCHAR (128) NOT NULL,
    [column_type]                VARCHAR (50)  NOT NULL,
    [column_length]              INT           NULL,
    [column_precision]           INT           NULL,
    [column_scale]               INT           NULL,
    [collation_name]             [sysname]     NULL,
    [bk_ordinal_position]        INT           DEFAULT ((0)) NOT NULL,
    [source_ordinal_position]    INT           NOT NULL,
    [satellite_ordinal_position] INT           NOT NULL,
    [abbreviation]               VARCHAR (50)  NULL,
    [object_type]                VARCHAR (50)  NULL);


GO
PRINT N'Creating [dbo].[dv_column]...';


GO
CREATE TABLE [dbo].[dv_column] (
    [column_key]                 INT                IDENTITY (1, 1) NOT NULL,
    [table_key]                  INT                NOT NULL,
    [column_name]                VARCHAR (128)      NOT NULL,
    [column_type]                VARCHAR (30)       NOT NULL,
    [column_length]              INT                NULL,
    [column_precision]           INT                NULL,
    [column_scale]               INT                NULL,
    [Collation_Name]             [sysname]          NULL,
    [bk_ordinal_position]        INT                NOT NULL,
    [source_ordinal_position]    INT                NOT NULL,
    [satellite_ordinal_position] INT                NOT NULL,
    [is_source_date]             BIT                NOT NULL,
    [discard_flag]               BIT                NOT NULL,
    [is_retired]                 BIT                NOT NULL,
    [release_key]                INT                NOT NULL,
    [version_number]             INT                NOT NULL,
    [updated_by]                 VARCHAR (30)       NULL,
    [update_date_time]           DATETIMEOFFSET (7) NULL,
    CONSTRAINT [PK__dv_colum__448C9D1E0C33CF7F] PRIMARY KEY CLUSTERED ([column_key] ASC),
    CONSTRAINT [dv_column_unique] UNIQUE NONCLUSTERED ([table_key] ASC, [column_name] ASC)
);


GO
PRINT N'Creating [dbo].[dv_column].[dv_satellite_ordinal_position_unique]...';


GO
CREATE UNIQUE NONCLUSTERED INDEX [dv_satellite_ordinal_position_unique]
    ON [dbo].[dv_column]([table_key] ASC, [satellite_ordinal_position] ASC);


GO
PRINT N'Creating [dbo].[dv_column_relationship]...';


GO
CREATE TABLE [dbo].[dv_column_relationship] (
    [column_relationship_key] INT                IDENTITY (1, 1) NOT NULL,
    [primary_column_key]      INT                NOT NULL,
    [foreign_column_key]      INT                NOT NULL,
    [release_key]             INT                NOT NULL,
    [version_number]          INT                NOT NULL,
    [updated_by]              VARCHAR (30)       NOT NULL,
    [updated_datetime]        DATETIMEOFFSET (7) NOT NULL,
    CONSTRAINT [PK__dv_colum__DD6110B057F324E6] PRIMARY KEY CLUSTERED ([column_relationship_key] ASC),
    CONSTRAINT [dv_column_relationship_unique] UNIQUE NONCLUSTERED ([primary_column_key] ASC, [foreign_column_key] ASC)
);


GO
PRINT N'Creating [dbo].[dv_default_column]...';


GO
CREATE TABLE [dbo].[dv_default_column] (
    [default_column_key] INT                IDENTITY (1, 1) NOT NULL,
    [object_type]        VARCHAR (30)       NOT NULL,
    [object_column_type] VARCHAR (30)       NOT NULL,
    [ordinal_position]   INT                NOT NULL,
    [column_prefix]      VARCHAR (30)       NULL,
    [column_name]        VARCHAR (256)      NOT NULL,
    [column_suffix]      VARCHAR (30)       NULL,
    [column_type]        VARCHAR (30)       NOT NULL,
    [column_length]      INT                NULL,
    [column_precision]   INT                NULL,
    [column_scale]       INT                NULL,
    [collation_Name]     [sysname]          NULL,
    [is_nullable]        BIT                NOT NULL,
    [is_pk]              BIT                NOT NULL,
    [discard_flag]       BIT                NOT NULL,
    [release_key]        INT                NOT NULL,
    [version_number]     INT                NOT NULL,
    [updated_by]         VARCHAR (30)       NULL,
    [update_date_time]   DATETIMEOFFSET (7) NULL,
    CONSTRAINT [PK__dv_defau__56A78F2CAD0ED7B9] PRIMARY KEY CLUSTERED ([default_column_key] ASC),
    CONSTRAINT [dv_default_column_unique] UNIQUE NONCLUSTERED ([object_type] ASC, [column_name] ASC)
);


GO
PRINT N'Creating [dbo].[dv_defaults]...';


GO
CREATE TABLE [dbo].[dv_defaults] (
    [default_key]      INT                IDENTITY (1, 1) NOT NULL,
    [default_type]     VARCHAR (50)       NOT NULL,
    [default_subtype]  VARCHAR (50)       NOT NULL,
    [default_sequence] INT                NOT NULL,
    [data_type]        VARCHAR (50)       NOT NULL,
    [default_integer]  INT                NULL,
    [default_varchar]  VARCHAR (128)      NULL,
    [default_dateTime] DATETIME           NULL,
    [release_key]      INT                NOT NULL,
    [version_number]   INT                NOT NULL,
    [updated_by]       VARCHAR (30)       NULL,
    [updated_datetime] DATETIMEOFFSET (7) NULL,
    CONSTRAINT [PK__dv_defau__2A343C0024B38F34] PRIMARY KEY CLUSTERED ([default_key] ASC),
    CONSTRAINT [Default_Type_Key] UNIQUE NONCLUSTERED ([default_type] ASC, [default_subtype] ASC)
);


GO
PRINT N'Creating [dbo].[dv_hub]...';


GO
CREATE TABLE [dbo].[dv_hub] (
    [hub_key]          INT                IDENTITY (1, 1) NOT NULL,
    [hub_name]         VARCHAR (128)      NOT NULL,
    [hub_abbreviation] VARCHAR (4)        NULL,
    [hub_schema]       VARCHAR (128)      NOT NULL,
    [hub_database]     VARCHAR (128)      NOT NULL,
    [is_retired]       BIT                NOT NULL,
    [release_key]      INT                NOT NULL,
    [version_number]   INT                NOT NULL,
    [updated_by]       VARCHAR (30)       NULL,
    [updated_datetime] DATETIMEOFFSET (7) NULL,
    CONSTRAINT [PK__dv_hub__2671B43F8B7FC200] PRIMARY KEY CLUSTERED ([hub_key] ASC),
    CONSTRAINT [dv_hub_abr_unique] UNIQUE NONCLUSTERED ([hub_abbreviation] ASC),
    CONSTRAINT [dv_hub_unique] UNIQUE NONCLUSTERED ([hub_database] ASC, [hub_schema] ASC, [hub_name] ASC)
);


GO
PRINT N'Creating [dbo].[dv_hub_key_column]...';


GO
CREATE TABLE [dbo].[dv_hub_key_column] (
    [hub_key_column_key]       INT                IDENTITY (1, 1) NOT NULL,
    [hub_key]                  INT                NOT NULL,
    [hub_key_column_name]      VARCHAR (128)      NOT NULL,
    [hub_key_column_type]      VARCHAR (30)       NOT NULL,
    [hub_key_column_length]    INT                NULL,
    [hub_key_column_precision] INT                NULL,
    [hub_key_column_scale]     INT                NULL,
    [hub_key_Collation_Name]   [sysname]          NULL,
    [hub_key_ordinal_position] INT                NOT NULL,
    [release_key]              INT                NOT NULL,
    [version_number]           INT                NOT NULL,
    [updated_by]               VARCHAR (30)       NULL,
    [updated_datetime]         DATETIMEOFFSET (7) NULL,
    CONSTRAINT [PK__dv_hub_k__E124E9D92355792F] PRIMARY KEY CLUSTERED ([hub_key_column_key] ASC),
    CONSTRAINT [dv_hub_column_key_unique] UNIQUE NONCLUSTERED ([hub_key] ASC, [hub_key_column_name] ASC)
);


GO
PRINT N'Creating [dbo].[dv_hub_link]...';


GO
CREATE TABLE [dbo].[dv_hub_link] (
    [hub_link_key]     INT                IDENTITY (1, 1) NOT NULL,
    [link_key]         INT                NOT NULL,
    [hub_key]          INT                NOT NULL,
    [release_key]      INT                NOT NULL,
    [version_number]   INT                NOT NULL,
    [updated_by]       VARCHAR (30)       NULL,
    [updated_datetime] DATETIMEOFFSET (7) NULL,
    CONSTRAINT [PK__dv_hub_l__46516BCBEC5E1CB0] PRIMARY KEY CLUSTERED ([hub_link_key] ASC),
    CONSTRAINT [dv_hub_link_unique] UNIQUE NONCLUSTERED ([link_key] ASC, [hub_key] ASC)
);


GO
PRINT N'Creating [dbo].[dv_link]...';


GO
CREATE TABLE [dbo].[dv_link] (
    [link_key]          INT                IDENTITY (1, 1) NOT NULL,
    [link_name]         VARCHAR (128)      NOT NULL,
    [link_abbreviation] VARCHAR (4)        NULL,
    [link_schema]       VARCHAR (128)      NOT NULL,
    [link_database]     VARCHAR (128)      NOT NULL,
    [is_retired]        BIT                NOT NULL,
    [release_key]       INT                NOT NULL,
    [version_number]    INT                NOT NULL,
    [updated_by]        VARCHAR (30)       NULL,
    [updated_datetime]  DATETIMEOFFSET (7) NULL,
    CONSTRAINT [PK__dv_link__8F1D0002234E32BF] PRIMARY KEY CLUSTERED ([link_key] ASC),
    CONSTRAINT [dv_link_abr_unique] UNIQUE NONCLUSTERED ([link_abbreviation] ASC),
    CONSTRAINT [dv_link_unique] UNIQUE NONCLUSTERED ([link_database] ASC, [link_schema] ASC, [link_name] ASC)
);


GO
PRINT N'Creating [dbo].[dv_source_system]...';


GO
CREATE TABLE [dbo].[dv_source_system] (
    [source_system_key]  INT                IDENTITY (1, 1) NOT NULL,
    [source_system_name] VARCHAR (50)       NOT NULL,
    [timevault_name]     VARCHAR (50)       NULL,
    [is_retired]         BIT                NOT NULL,
    [release_key]        INT                NOT NULL,
    [version_number]     INT                NULL,
    [updated_by]         VARCHAR (30)       NULL,
    [update_date_time]   DATETIMEOFFSET (7) NULL,
    CONSTRAINT [PK__dv_sourc__B5998963B2793DE4] PRIMARY KEY CLUSTERED ([source_system_key] ASC),
    CONSTRAINT [source_system_unique] UNIQUE NONCLUSTERED ([source_system_name] ASC)
);


GO
PRINT N'Creating [dbo].[dv_source_table]...';


GO
CREATE TABLE [dbo].[dv_source_table] (
    [source_table_key]        INT                IDENTITY (1, 1) NOT NULL,
    [system_key]              INT                NOT NULL,
    [source_table_schema]     VARCHAR (128)      NOT NULL,
    [source_table_name]       VARCHAR (128)      NOT NULL,
    [source_table_load_type]  VARCHAR (50)       NOT NULL,
    [source_procedure_schema] VARCHAR (128)      NULL,
    [source_procedure_name]   VARCHAR (128)      NULL,
    [is_retired]              BIT                NOT NULL,
    [release_key]             INT                NOT NULL,
    [version_number]          INT                NULL,
    [updated_by]              VARCHAR (30)       NULL,
    [update_date_time]        DATETIMEOFFSET (7) NULL,
    CONSTRAINT [PK__dv_sourc__D64CD3B7E8292317] PRIMARY KEY CLUSTERED ([source_table_key] ASC),
    CONSTRAINT [dv_source_system_unique] UNIQUE NONCLUSTERED ([system_key] ASC, [source_table_schema] ASC, [source_table_name] ASC)
);


GO
PRINT N'Creating [dbo].[dv_satellite]...';


GO
CREATE TABLE [dbo].[dv_satellite] (
    [satellite_key]               INT                IDENTITY (1, 1) NOT NULL,
    [hub_key]                     INT                NOT NULL,
    [link_key]                    INT                NOT NULL,
    [link_hub_satellite_flag]     CHAR (1)           NOT NULL,
    [satellite_name]              VARCHAR (128)      NOT NULL,
    [satellite_abbreviation]      VARCHAR (4)        NULL,
    [satellite_schema]            VARCHAR (128)      NOT NULL,
    [satellite_database]          VARCHAR (128)      NOT NULL,
    [duplicate_removal_threshold] INT                NOT NULL,
    [is_columnstore]              BIT                NOT NULL,
    [is_retired]                  BIT                NOT NULL,
    [release_key]                 INT                NOT NULL,
    [version_number]              INT                NOT NULL,
    [updated_by]                  VARCHAR (30)       NULL,
    [updated_datetime]            DATETIMEOFFSET (7) NULL,
    CONSTRAINT [PK__dv_satel__591F7B98AC67FA20] PRIMARY KEY CLUSTERED ([satellite_key] ASC),
    CONSTRAINT [dv_sat_abr_unique] UNIQUE NONCLUSTERED ([satellite_abbreviation] ASC),
    CONSTRAINT [dv_satellite_unique] UNIQUE NONCLUSTERED ([satellite_name] ASC)
);


GO
PRINT N'Creating [dbo].[dv_hub_column]...';


GO
CREATE TABLE [dbo].[dv_hub_column] (
    [hub_col_key]        INT                IDENTITY (1, 1) NOT NULL,
    [hub_key_column_key] INT                NOT NULL,
    [column_key]         INT                NOT NULL,
    [release_key]        INT                NOT NULL,
    [version_number]     INT                NOT NULL,
    [updated_by]         VARCHAR (30)       NULL,
    [updated_datetime]   DATETIMEOFFSET (7) NULL,
    CONSTRAINT [PK__dv_hub_c__1990F0D2AC6D4CF1] PRIMARY KEY CLUSTERED ([hub_col_key] ASC),
    CONSTRAINT [dv_hub_column_unique] UNIQUE NONCLUSTERED ([hub_key_column_key] ASC, [column_key] ASC),
    CONSTRAINT [dv_hub_source_column_unique] UNIQUE NONCLUSTERED ([column_key] ASC)
);


GO
PRINT N'Creating [dbo].[dv_satellite_column]...';


GO
CREATE TABLE [dbo].[dv_satellite_column] (
    [satellite_col_key] INT                IDENTITY (1, 1) NOT NULL,
    [satellite_key]     INT                NOT NULL,
    [column_key]        INT                NOT NULL,
    [release_key]       INT                NOT NULL,
    [version_number]    INT                NOT NULL,
    [updated_by]        VARCHAR (30)       NULL,
    [updated_datetime]  DATETIMEOFFSET (7) NULL,
    CONSTRAINT [PK__dv_satel__FCBA778F866D59FE] PRIMARY KEY CLUSTERED ([satellite_col_key] ASC),
    CONSTRAINT [dv_satellite_column_unique] UNIQUE NONCLUSTERED ([satellite_key] ASC, [column_key] ASC),
    CONSTRAINT [dv_satellite_source_column_unique] UNIQUE NONCLUSTERED ([column_key] ASC)
);


GO
PRINT N'Creating [dv_log].[dv_load_state_history]...';


GO
CREATE TABLE [dv_log].[dv_load_state_history] (
    [load_state_key]   INT                NULL,
    [activity]         CHAR (1)           NULL,
    [source_table_key] INT                NULL,
    [object_key]       INT                NULL,
    [object_type]      VARCHAR (50)       NULL,
    [execution_key]    INT                NULL,
    [load_high_water]  DATETIMEOFFSET (7) NULL,
    [rows_inserted]    INT                NULL,
    [rows_updated]     INT                NULL,
    [rows_deleted]     INT                NULL,
    [updated_by]       VARCHAR (30)       NULL,
    [update_date_time] DATETIMEOFFSET (7) NULL
);


GO
PRINT N'Creating [dv_log].[dv_load_state]...';


GO
CREATE TABLE [dv_log].[dv_load_state] (
    [load_state_key]   INT                IDENTITY (1, 1) NOT NULL,
    [source_table_key] INT                NOT NULL,
    [object_key]       INT                NOT NULL,
    [object_type]      VARCHAR (50)       NOT NULL,
    [execution_key]    INT                NOT NULL,
    [load_high_water]  DATETIMEOFFSET (7) NULL,
    [rows_inserted]    INT                NOT NULL,
    [rows_updated]     INT                NOT NULL,
    [rows_deleted]     INT                NOT NULL,
    [updated_by]       VARCHAR (30)       NULL,
    [update_date_time] DATETIMEOFFSET (7) NOT NULL,
    PRIMARY KEY CLUSTERED ([load_state_key] ASC)
);


GO
PRINT N'Creating [dv_log].[dv_execution]...';


GO
CREATE TABLE [dv_log].[dv_execution] (
    [execution_key]            INT                IDENTITY (1, 1) NOT NULL,
    [execution_start_datetime] DATETIMEOFFSET (7) NOT NULL,
    [execution_end_datetime]   DATETIMEOFFSET (7) NULL,
    [created_by]               VARCHAR (30)       NOT NULL,
    [updated_by]               VARCHAR (30)       NOT NULL,
    [update_date_time]         DATETIMEOFFSET (7) NOT NULL,
    PRIMARY KEY CLUSTERED ([execution_key] ASC)
);


GO
PRINT N'Creating [dv_release].[dv_release_build]...';


GO
CREATE TABLE [dv_release].[dv_release_build] (
    [release_build_key]          INT           NOT NULL,
    [release_statement_sequence] INT           NOT NULL,
    [release_number]             INT           NOT NULL,
    [release_statement_type]     VARCHAR (10)  NOT NULL,
    [release_statement]          VARCHAR (MAX) NULL,
    [affected_row_count]         INT           NOT NULL,
    CONSTRAINT [PK_dv_release_build] PRIMARY KEY CLUSTERED ([release_build_key] ASC, [release_statement_sequence] ASC)
);


GO
PRINT N'Creating [dv_release].[dv_release_master]...';


GO
CREATE TABLE [dv_release].[dv_release_master] (
    [release_key]               INT                IDENTITY (1, 1) NOT NULL,
    [release_number]            INT                NOT NULL,
    [release_description]       VARCHAR (256)      NULL,
    [reference_number]          VARCHAR (50)       NULL,
    [reference_source]          VARCHAR (50)       NULL,
    [build_number]              INT                NOT NULL,
    [build_date]                DATETIMEOFFSET (7) NULL,
    [build_server]              VARCHAR (256)      NULL,
    [release_built_by]          VARCHAR (30)       NULL,
    [release_start_datetime]    DATETIMEOFFSET (7) NULL,
    [release_complete_datetime] DATETIMEOFFSET (7) NULL,
    [release_count]             INT                NOT NULL,
    [version_number]            INT                NOT NULL,
    [updated_by]                VARCHAR (30)       NOT NULL,
    [updated_datetime]          DATETIMEOFFSET (7) NOT NULL,
    CONSTRAINT [PK__dv_relea__7B7C0773AC625D81] PRIMARY KEY CLUSTERED ([release_key] ASC)
);


GO
PRINT N'Creating [dv_release].[dv_release_master].[dv_release_number]...';


GO
CREATE UNIQUE NONCLUSTERED INDEX [dv_release_number]
    ON [dv_release].[dv_release_master]([release_number] ASC);


GO
PRINT N'Creating [dv_scheduler].[dv_run]...';


GO
CREATE TABLE [dv_scheduler].[dv_run] (
    [run_key]            INT                IDENTITY (1, 1) NOT NULL,
    [run_status]         VARCHAR (128)      NOT NULL,
    [run_schedule_name]  VARCHAR (128)      NOT NULL,
    [run_start_datetime] DATETIMEOFFSET (7) NULL,
    [run_end_datetime]   DATETIMEOFFSET (7) NULL,
    [updated_datetime]   DATETIMEOFFSET (7) NOT NULL,
    CONSTRAINT [PK__dv_run__AEDC1D6EF837117B] PRIMARY KEY CLUSTERED ([run_key] ASC)
);


GO
PRINT N'Creating [dv_scheduler].[dv_source_table_hierarchy]...';


GO
CREATE TABLE [dv_scheduler].[dv_source_table_hierarchy] (
    [source_table_hierarchy_key] INT                IDENTITY (1, 1) NOT NULL,
    [source_table_key]           INT                NOT NULL,
    [prior_table_key]            INT                NOT NULL,
    [is_cancelled]               BIT                NOT NULL,
    [release_key]                INT                NOT NULL,
    [version_number]             INT                NOT NULL,
    [updated_by]                 VARCHAR (30)       NOT NULL,
    [update_date_time]           DATETIMEOFFSET (7) NOT NULL,
    CONSTRAINT [PK__dv_sourc__83E05932811DCE8D] PRIMARY KEY CLUSTERED ([source_table_hierarchy_key] ASC)
);


GO
PRINT N'Creating [dv_scheduler].[dv_source_table_hierarchy].[UX_Source_table_key_prior_table_key]...';


GO
CREATE UNIQUE NONCLUSTERED INDEX [UX_Source_table_key_prior_table_key]
    ON [dv_scheduler].[dv_source_table_hierarchy]([source_table_key] ASC, [prior_table_key] ASC);


GO
PRINT N'Creating [dv_scheduler].[dv_schedule_source_table]...';


GO
CREATE TABLE [dv_scheduler].[dv_schedule_source_table] (
    [schedule_source_table_key] INT                IDENTITY (1, 1) NOT NULL,
    [schedule_key]              INT                NOT NULL,
    [source_table_key]          INT                NOT NULL,
    [source_table_load_type]    VARCHAR (50)       NOT NULL,
    [priority]                  VARCHAR (50)       NOT NULL,
    [queue]                     VARCHAR (50)       NOT NULL,
    [is_cancelled]              BIT                NOT NULL,
    [release_key]               INT                NOT NULL,
    [version_number]            INT                NOT NULL,
    [updated_by]                VARCHAR (30)       NOT NULL,
    [updated_datetime]          DATETIMEOFFSET (7) NOT NULL,
    CONSTRAINT [PK__dv_sched__5FF3626055109B18] PRIMARY KEY CLUSTERED ([schedule_source_table_key] ASC)
);


GO
PRINT N'Creating [dv_scheduler].[dv_schedule_source_table].[dv_schedule__dv_schedule__dv_source_table]...';


GO
CREATE UNIQUE NONCLUSTERED INDEX [dv_schedule__dv_schedule__dv_source_table]
    ON [dv_scheduler].[dv_schedule_source_table]([schedule_key] ASC, [source_table_key] ASC);


GO
PRINT N'Creating [dv_scheduler].[dv_schedule]...';


GO
CREATE TABLE [dv_scheduler].[dv_schedule] (
    [schedule_key]         INT                IDENTITY (1, 1) NOT NULL,
    [schedule_name]        VARCHAR (128)      NOT NULL,
    [schedule_description] VARCHAR (256)      NULL,
    [schedule_frequency]   VARCHAR (128)      NOT NULL,
    [is_cancelled]         BIT                NOT NULL,
    [release_key]          INT                NOT NULL,
    [version_number]       INT                NOT NULL,
    [updated_by]           VARCHAR (30)       NOT NULL,
    [updated_datetime]     DATETIMEOFFSET (7) NOT NULL,
    CONSTRAINT [PK__dv_sched__DC037B951DDF7647] PRIMARY KEY CLUSTERED ([schedule_key] ASC)
);


GO
PRINT N'Creating [dv_scheduler].[dv_schedule].[UX_dv_schedule_schedule_name]...';


GO
CREATE UNIQUE NONCLUSTERED INDEX [UX_dv_schedule_schedule_name]
    ON [dv_scheduler].[dv_schedule]([schedule_name] ASC);


GO
PRINT N'Creating [dv_scheduler].[dv_run_manifest_hierarchy]...';


GO
CREATE TABLE [dv_scheduler].[dv_run_manifest_hierarchy] (
    [run_manifest_hierarchy_key] INT                IDENTITY (1, 1) NOT NULL,
    [run_manifest_key]           INT                NOT NULL,
    [run_manifest_prior_key]     INT                NOT NULL,
    [update_date_time]           DATETIMEOFFSET (7) NULL,
    PRIMARY KEY CLUSTERED ([run_manifest_hierarchy_key] ASC)
);


GO
PRINT N'Creating [dv_scheduler].[dv_run_manifest_hierarchy].[UX_run_manifest_key__run_manifest_prior_key]...';


GO
CREATE UNIQUE NONCLUSTERED INDEX [UX_run_manifest_key__run_manifest_prior_key]
    ON [dv_scheduler].[dv_run_manifest_hierarchy]([run_manifest_key] ASC, [run_manifest_prior_key] ASC);


GO
PRINT N'Creating [dv_scheduler].[dv_run_manifest]...';


GO
CREATE TABLE [dv_scheduler].[dv_run_manifest] (
    [run_manifest_key]        INT                IDENTITY (1, 1) NOT NULL,
    [run_key]                 INT                NOT NULL,
    [source_system_name]      VARCHAR (50)       NOT NULL,
    [source_timevault]        VARCHAR (50)       NULL,
    [source_table_schema]     [sysname]          NOT NULL,
    [source_table_name]       [sysname]          NOT NULL,
    [source_table_load_type]  VARCHAR (50)       NOT NULL,
    [source_table_key]        INT                NOT NULL,
    [source_procedure_schema] VARCHAR (128)      NULL,
    [source_procedure_name]   VARCHAR (128)      NULL,
    [priority]                VARCHAR (10)       NOT NULL,
    [queue]                   VARCHAR (10)       NOT NULL,
    [start_datetime]          DATETIMEOFFSET (7) NULL,
    [completed_datetime]      DATETIMEOFFSET (7) NULL,
    [run_status]              VARCHAR (128)      NOT NULL,
    [row_count]               INT                NOT NULL,
    [session_id]              INT                NULL,
    CONSTRAINT [PK__dv_run_m__C9D207B6B86E4AF4] PRIMARY KEY CLUSTERED ([run_manifest_key] ASC)
);


GO
PRINT N'Creating [dv_scheduler].[dv_run_manifest].[UX_dv_run_manifest__run_key_source_table]...';


GO
CREATE UNIQUE NONCLUSTERED INDEX [UX_dv_run_manifest__run_key_source_table]
    ON [dv_scheduler].[dv_run_manifest]([run_key] ASC, [source_system_name] ASC, [source_table_schema] ASC, [source_table_name] ASC);


GO
PRINT N'Creating [log4].[Severity]...';


GO
CREATE TABLE [log4].[Severity] (
    [SeverityId]   INT           NOT NULL,
    [SeverityName] VARCHAR (128) NOT NULL,
    CONSTRAINT [PK_Severity] PRIMARY KEY NONCLUSTERED ([SeverityId] ASC) WITH (FILLFACTOR = 100),
    CONSTRAINT [UQ_Severity_SeverityName] UNIQUE NONCLUSTERED ([SeverityName] ASC) WITH (FILLFACTOR = 100)
);


GO
PRINT N'Creating [log4].[JournalDetail]...';


GO
CREATE TABLE [log4].[JournalDetail] (
    [JournalId] INT           NOT NULL,
    [ExtraInfo] VARCHAR (MAX) NULL,
    CONSTRAINT [PK_JournalDetail] PRIMARY KEY NONCLUSTERED ([JournalId] ASC) WITH (FILLFACTOR = 100)
);


GO
PRINT N'Creating [log4].[JournalControl]...';


GO
CREATE TABLE [log4].[JournalControl] (
    [ModuleName]  VARCHAR (255) NOT NULL,
    [OnOffSwitch] VARCHAR (3)   NOT NULL,
    CONSTRAINT [PK_JournalControl] PRIMARY KEY NONCLUSTERED ([ModuleName] ASC) WITH (FILLFACTOR = 100)
);


GO
PRINT N'Creating [log4].[Journal]...';


GO
CREATE TABLE [log4].[Journal] (
    [JournalId]         INT            IDENTITY (1, 1) NOT NULL,
    [UtcDate]           DATETIME       NULL,
    [SystemDate]        DATETIME       NULL,
    [Task]              VARCHAR (128)  NULL,
    [FunctionName]      VARCHAR (256)  NULL,
    [StepInFunction]    VARCHAR (128)  NULL,
    [MessageText]       VARCHAR (512)  NULL,
    [SeverityId]        INT            NULL,
    [ExceptionId]       INT            NULL,
    [SessionId]         INT            NULL,
    [ServerName]        NVARCHAR (128) NULL,
    [DatabaseName]      NVARCHAR (128) NULL,
    [HostName]          NVARCHAR (128) NULL,
    [ProgramName]       NVARCHAR (128) NULL,
    [NTDomain]          NVARCHAR (128) NULL,
    [NTUsername]        NVARCHAR (128) NULL,
    [LoginName]         NVARCHAR (128) NULL,
    [OriginalLoginName] NVARCHAR (128) NULL,
    [SessionLoginTime]  DATETIME       NULL,
    CONSTRAINT [PK_Journal] PRIMARY KEY NONCLUSTERED ([JournalId] ASC) WITH (FILLFACTOR = 100)
);


GO
PRINT N'Creating [log4].[Exception]...';


GO
CREATE TABLE [log4].[Exception] (
    [ExceptionId]       INT            IDENTITY (1, 1) NOT NULL,
    [UtcDate]           DATETIME       NULL,
    [SystemDate]        DATETIME       NULL,
    [ErrorContext]      NVARCHAR (512) NULL,
    [ErrorNumber]       INT            NULL,
    [ErrorSeverity]     INT            NULL,
    [ErrorState]        INT            NULL,
    [ErrorProcedure]    NVARCHAR (128) NULL,
    [ErrorLine]         INT            NULL,
    [ErrorMessage]      NVARCHAR (MAX) NULL,
    [SessionId]         INT            NULL,
    [ServerName]        NVARCHAR (128) NULL,
    [DatabaseName]      NVARCHAR (128) NULL,
    [HostName]          NVARCHAR (128) NULL,
    [ProgramName]       NVARCHAR (128) NULL,
    [NTDomain]          NVARCHAR (128) NULL,
    [NTUsername]        NVARCHAR (128) NULL,
    [LoginName]         NVARCHAR (128) NULL,
    [OriginalLoginName] NVARCHAR (128) NULL,
    [SessionLoginTime]  DATETIME       NULL,
    CONSTRAINT [PK_Exception] PRIMARY KEY NONCLUSTERED ([ExceptionId] ASC) WITH (FILLFACTOR = 100)
);


GO
PRINT N'Creating [ODE_Release].[dv_release_002_002_001]...';


GO
CREATE TABLE [ODE_Release].[dv_release_002_002_001] (
    [release_key]          INT                IDENTITY (1, 1) NOT NULL,
    [release_applied_date] DATETIMEOFFSET (7) NULL,
    PRIMARY KEY CLUSTERED ([release_key] ASC)
);


GO
PRINT N'Creating [dbo].[DF__dv_column__bk_or__31EC6D26]...';


GO
ALTER TABLE [dbo].[dv_column]
    ADD CONSTRAINT [DF__dv_column__bk_or__31EC6D26] DEFAULT ((0)) FOR [bk_ordinal_position];


GO
PRINT N'Creating [dbo].[DF__dv_column__is_so__32E0915F]...';


GO
ALTER TABLE [dbo].[dv_column]
    ADD CONSTRAINT [DF__dv_column__is_so__32E0915F] DEFAULT ((0)) FOR [is_source_date];


GO
PRINT N'Creating [dbo].[DF__dv_column__disca__33D4B598]...';


GO
ALTER TABLE [dbo].[dv_column]
    ADD CONSTRAINT [DF__dv_column__disca__33D4B598] DEFAULT ((0)) FOR [discard_flag];


GO
PRINT N'Creating [dbo].[DF__dv_column__delet__34C8D9D1]...';


GO
ALTER TABLE [dbo].[dv_column]
    ADD CONSTRAINT [DF__dv_column__delet__34C8D9D1] DEFAULT ((0)) FOR [is_retired];


GO
PRINT N'Creating [dbo].[DF_dv_column_release_key]...';


GO
ALTER TABLE [dbo].[dv_column]
    ADD CONSTRAINT [DF_dv_column_release_key] DEFAULT ((0)) FOR [release_key];


GO
PRINT N'Creating [dbo].[DF__dv_column__versi__35BCFE0A]...';


GO
ALTER TABLE [dbo].[dv_column]
    ADD CONSTRAINT [DF__dv_column__versi__35BCFE0A] DEFAULT ((1)) FOR [version_number];


GO
PRINT N'Creating [dbo].[DF__dv_column__updat__36B12243]...';


GO
ALTER TABLE [dbo].[dv_column]
    ADD CONSTRAINT [DF__dv_column__updat__36B12243] DEFAULT (suser_name()) FOR [updated_by];


GO
PRINT N'Creating [dbo].[DF__dv_column__updat__37A5467C]...';


GO
ALTER TABLE [dbo].[dv_column]
    ADD CONSTRAINT [DF__dv_column__updat__37A5467C] DEFAULT (sysdatetimeoffset()) FOR [update_date_time];


GO
PRINT N'Creating [dbo].[DF_dv_column_relationship_release_key]...';


GO
ALTER TABLE [dbo].[dv_column_relationship]
    ADD CONSTRAINT [DF_dv_column_relationship_release_key] DEFAULT ((0)) FOR [release_key];


GO
PRINT N'Creating [dbo].[DF__dv_column__versi__13F1F5EB]...';


GO
ALTER TABLE [dbo].[dv_column_relationship]
    ADD CONSTRAINT [DF__dv_column__versi__13F1F5EB] DEFAULT ((1)) FOR [version_number];


GO
PRINT N'Creating [dbo].[DF__dv_column__updat__14E61A24]...';


GO
ALTER TABLE [dbo].[dv_column_relationship]
    ADD CONSTRAINT [DF__dv_column__updat__14E61A24] DEFAULT (suser_name()) FOR [updated_by];


GO
PRINT N'Creating [dbo].[DF__dv_column__updat__15DA3E5D]...';


GO
ALTER TABLE [dbo].[dv_column_relationship]
    ADD CONSTRAINT [DF__dv_column__updat__15DA3E5D] DEFAULT (sysdatetimeoffset()) FOR [updated_datetime];


GO
PRINT N'Creating [dbo].[DF__dv_defaul__ordin__214BF109]...';


GO
ALTER TABLE [dbo].[dv_default_column]
    ADD CONSTRAINT [DF__dv_defaul__ordin__214BF109] DEFAULT ((0)) FOR [ordinal_position];


GO
PRINT N'Creating [dbo].[DF__dv_defaul__is_nu__22401542]...';


GO
ALTER TABLE [dbo].[dv_default_column]
    ADD CONSTRAINT [DF__dv_defaul__is_nu__22401542] DEFAULT ((1)) FOR [is_nullable];


GO
PRINT N'Creating [dbo].[DF__dv_defaul__is_pk__2334397B]...';


GO
ALTER TABLE [dbo].[dv_default_column]
    ADD CONSTRAINT [DF__dv_defaul__is_pk__2334397B] DEFAULT ((0)) FOR [is_pk];


GO
PRINT N'Creating [dbo].[DF__dv_defaul__disca__24285DB4]...';


GO
ALTER TABLE [dbo].[dv_default_column]
    ADD CONSTRAINT [DF__dv_defaul__disca__24285DB4] DEFAULT ((0)) FOR [discard_flag];


GO
PRINT N'Creating [dbo].[DF_dv_default_column_release_key]...';


GO
ALTER TABLE [dbo].[dv_default_column]
    ADD CONSTRAINT [DF_dv_default_column_release_key] DEFAULT ((0)) FOR [release_key];


GO
PRINT N'Creating [dbo].[DF__dv_defaul__versi__251C81ED]...';


GO
ALTER TABLE [dbo].[dv_default_column]
    ADD CONSTRAINT [DF__dv_defaul__versi__251C81ED] DEFAULT ((1)) FOR [version_number];


GO
PRINT N'Creating [dbo].[DF__dv_defaul__updat__2610A626]...';


GO
ALTER TABLE [dbo].[dv_default_column]
    ADD CONSTRAINT [DF__dv_defaul__updat__2610A626] DEFAULT (suser_name()) FOR [updated_by];


GO
PRINT N'Creating [dbo].[DF__dv_defaul__updat__2704CA5F]...';


GO
ALTER TABLE [dbo].[dv_default_column]
    ADD CONSTRAINT [DF__dv_defaul__updat__2704CA5F] DEFAULT (sysdatetimeoffset()) FOR [update_date_time];


GO
PRINT N'Creating [dbo].[DF__dv_defaul__defau__19AACF41]...';


GO
ALTER TABLE [dbo].[dv_defaults]
    ADD CONSTRAINT [DF__dv_defaul__defau__19AACF41] DEFAULT ((1)) FOR [default_sequence];


GO
PRINT N'Creating [dbo].[DF__dv_defaul__data___1A9EF37A]...';


GO
ALTER TABLE [dbo].[dv_defaults]
    ADD CONSTRAINT [DF__dv_defaul__data___1A9EF37A] DEFAULT ('varchar') FOR [data_type];


GO
PRINT N'Creating [dbo].[DF_dv_defaults_release_key]...';


GO
ALTER TABLE [dbo].[dv_defaults]
    ADD CONSTRAINT [DF_dv_defaults_release_key] DEFAULT ((0)) FOR [release_key];


GO
PRINT N'Creating [dbo].[DF__dv_defaul__versi__1B9317B3]...';


GO
ALTER TABLE [dbo].[dv_defaults]
    ADD CONSTRAINT [DF__dv_defaul__versi__1B9317B3] DEFAULT ((1)) FOR [version_number];


GO
PRINT N'Creating [dbo].[DF__dv_defaul__updat__1C873BEC]...';


GO
ALTER TABLE [dbo].[dv_defaults]
    ADD CONSTRAINT [DF__dv_defaul__updat__1C873BEC] DEFAULT (suser_name()) FOR [updated_by];


GO
PRINT N'Creating [dbo].[DF__dv_defaul__updat__1D7B6025]...';


GO
ALTER TABLE [dbo].[dv_defaults]
    ADD CONSTRAINT [DF__dv_defaul__updat__1D7B6025] DEFAULT (sysdatetimeoffset()) FOR [updated_datetime];


GO
PRINT N'Creating unnamed constraint on [dbo].[dv_hub]...';


GO
ALTER TABLE [dbo].[dv_hub]
    ADD DEFAULT ((0)) FOR [is_retired];


GO
PRINT N'Creating [dbo].[DF_dv_hub_release_key]...';


GO
ALTER TABLE [dbo].[dv_hub]
    ADD CONSTRAINT [DF_dv_hub_release_key] DEFAULT ((0)) FOR [release_key];


GO
PRINT N'Creating [dbo].[DF__dv_hub__version___534D60F1]...';


GO
ALTER TABLE [dbo].[dv_hub]
    ADD CONSTRAINT [DF__dv_hub__version___534D60F1] DEFAULT ((1)) FOR [version_number];


GO
PRINT N'Creating [dbo].[DF__dv_hub__updated___5441852A]...';


GO
ALTER TABLE [dbo].[dv_hub]
    ADD CONSTRAINT [DF__dv_hub__updated___5441852A] DEFAULT (suser_name()) FOR [updated_by];


GO
PRINT N'Creating [dbo].[DF__dv_hub__updated___5535A963]...';


GO
ALTER TABLE [dbo].[dv_hub]
    ADD CONSTRAINT [DF__dv_hub__updated___5535A963] DEFAULT (sysdatetimeoffset()) FOR [updated_datetime];


GO
PRINT N'Creating [dbo].[DF__dv_hub_ke__hub_k__308E3499]...';


GO
ALTER TABLE [dbo].[dv_hub_key_column]
    ADD CONSTRAINT [DF__dv_hub_ke__hub_k__308E3499] DEFAULT ((0)) FOR [hub_key_ordinal_position];


GO
PRINT N'Creating [dbo].[DF_dv_hub_key_column_release_key]...';


GO
ALTER TABLE [dbo].[dv_hub_key_column]
    ADD CONSTRAINT [DF_dv_hub_key_column_release_key] DEFAULT ((0)) FOR [release_key];


GO
PRINT N'Creating [dbo].[DF__dv_hub_ke__versi__318258D2]...';


GO
ALTER TABLE [dbo].[dv_hub_key_column]
    ADD CONSTRAINT [DF__dv_hub_ke__versi__318258D2] DEFAULT ((1)) FOR [version_number];


GO
PRINT N'Creating [dbo].[DF__dv_hub_ke__updat__32767D0B]...';


GO
ALTER TABLE [dbo].[dv_hub_key_column]
    ADD CONSTRAINT [DF__dv_hub_ke__updat__32767D0B] DEFAULT (suser_name()) FOR [updated_by];


GO
PRINT N'Creating [dbo].[DF__dv_hub_ke__updat__336AA144]...';


GO
ALTER TABLE [dbo].[dv_hub_key_column]
    ADD CONSTRAINT [DF__dv_hub_ke__updat__336AA144] DEFAULT (sysdatetimeoffset()) FOR [updated_datetime];


GO
PRINT N'Creating [dbo].[DF_dv_hub_link_release_key]...';


GO
ALTER TABLE [dbo].[dv_hub_link]
    ADD CONSTRAINT [DF_dv_hub_link_release_key] DEFAULT ((0)) FOR [release_key];


GO
PRINT N'Creating [dbo].[DF__dv_hub_li__versi__373B3228]...';


GO
ALTER TABLE [dbo].[dv_hub_link]
    ADD CONSTRAINT [DF__dv_hub_li__versi__373B3228] DEFAULT ((1)) FOR [version_number];


GO
PRINT N'Creating [dbo].[DF__dv_hub_li__updat__382F5661]...';


GO
ALTER TABLE [dbo].[dv_hub_link]
    ADD CONSTRAINT [DF__dv_hub_li__updat__382F5661] DEFAULT (suser_name()) FOR [updated_by];


GO
PRINT N'Creating [dbo].[DF__dv_hub_li__updat__39237A9A]...';


GO
ALTER TABLE [dbo].[dv_hub_link]
    ADD CONSTRAINT [DF__dv_hub_li__updat__39237A9A] DEFAULT (sysdatetimeoffset()) FOR [updated_datetime];


GO
PRINT N'Creating unnamed constraint on [dbo].[dv_link]...';


GO
ALTER TABLE [dbo].[dv_link]
    ADD DEFAULT ((0)) FOR [is_retired];


GO
PRINT N'Creating [dbo].[DF_dv_link_release_key]...';


GO
ALTER TABLE [dbo].[dv_link]
    ADD CONSTRAINT [DF_dv_link_release_key] DEFAULT ((0)) FOR [release_key];


GO
PRINT N'Creating [dbo].[DF__dv_link__version__6C190EBB]...';


GO
ALTER TABLE [dbo].[dv_link]
    ADD CONSTRAINT [DF__dv_link__version__6C190EBB] DEFAULT ((1)) FOR [version_number];


GO
PRINT N'Creating [dbo].[DF__dv_link__updated__6D0D32F4]...';


GO
ALTER TABLE [dbo].[dv_link]
    ADD CONSTRAINT [DF__dv_link__updated__6D0D32F4] DEFAULT (suser_name()) FOR [updated_by];


GO
PRINT N'Creating [dbo].[DF__dv_link__updated__6E01572D]...';


GO
ALTER TABLE [dbo].[dv_link]
    ADD CONSTRAINT [DF__dv_link__updated__6E01572D] DEFAULT (sysdatetimeoffset()) FOR [updated_datetime];


GO
PRINT N'Creating unnamed constraint on [dbo].[dv_source_system]...';


GO
ALTER TABLE [dbo].[dv_source_system]
    ADD DEFAULT ((0)) FOR [is_retired];


GO
PRINT N'Creating [dbo].[DF_dv_source_system_release_key]...';


GO
ALTER TABLE [dbo].[dv_source_system]
    ADD CONSTRAINT [DF_dv_source_system_release_key] DEFAULT ((0)) FOR [release_key];


GO
PRINT N'Creating [dbo].[DF__dv_source__versi__02084FDA]...';


GO
ALTER TABLE [dbo].[dv_source_system]
    ADD CONSTRAINT [DF__dv_source__versi__02084FDA] DEFAULT ((1)) FOR [version_number];


GO
PRINT N'Creating [dbo].[DF__dv_source__updat__02FC7413]...';


GO
ALTER TABLE [dbo].[dv_source_system]
    ADD CONSTRAINT [DF__dv_source__updat__02FC7413] DEFAULT (suser_name()) FOR [updated_by];


GO
PRINT N'Creating [dbo].[DF__dv_source__updat__03F0984C]...';


GO
ALTER TABLE [dbo].[dv_source_system]
    ADD CONSTRAINT [DF__dv_source__updat__03F0984C] DEFAULT (sysdatetimeoffset()) FOR [update_date_time];


GO
PRINT N'Creating [dbo].[DF__dv_source__sourc__07C12930]...';


GO
ALTER TABLE [dbo].[dv_source_table]
    ADD CONSTRAINT [DF__dv_source__sourc__07C12930] DEFAULT ('Full') FOR [source_table_load_type];


GO
PRINT N'Creating unnamed constraint on [dbo].[dv_source_table]...';


GO
ALTER TABLE [dbo].[dv_source_table]
    ADD DEFAULT ((0)) FOR [is_retired];


GO
PRINT N'Creating [dbo].[DF_dv_source_table_release_key]...';


GO
ALTER TABLE [dbo].[dv_source_table]
    ADD CONSTRAINT [DF_dv_source_table_release_key] DEFAULT ((0)) FOR [release_key];


GO
PRINT N'Creating [dbo].[DF__dv_source__versi__08B54D69]...';


GO
ALTER TABLE [dbo].[dv_source_table]
    ADD CONSTRAINT [DF__dv_source__versi__08B54D69] DEFAULT ((1)) FOR [version_number];


GO
PRINT N'Creating [dbo].[DF__dv_source__updat__09A971A2]...';


GO
ALTER TABLE [dbo].[dv_source_table]
    ADD CONSTRAINT [DF__dv_source__updat__09A971A2] DEFAULT (suser_name()) FOR [updated_by];


GO
PRINT N'Creating [dbo].[DF__dv_source__updat__0A9D95DB]...';


GO
ALTER TABLE [dbo].[dv_source_table]
    ADD CONSTRAINT [DF__dv_source__updat__0A9D95DB] DEFAULT (sysdatetimeoffset()) FOR [update_date_time];


GO
PRINT N'Creating [dbo].[DF__dv_satell__hub_k__72C60C4A]...';


GO
ALTER TABLE [dbo].[dv_satellite]
    ADD CONSTRAINT [DF__dv_satell__hub_k__72C60C4A] DEFAULT ((0)) FOR [hub_key];


GO
PRINT N'Creating [dbo].[DF__dv_satell__link___73BA3083]...';


GO
ALTER TABLE [dbo].[dv_satellite]
    ADD CONSTRAINT [DF__dv_satell__link___73BA3083] DEFAULT ((0)) FOR [link_key];


GO
PRINT N'Creating [dbo].[DF__dv_satell__link___74AE54BC]...';


GO
ALTER TABLE [dbo].[dv_satellite]
    ADD CONSTRAINT [DF__dv_satell__link___74AE54BC] DEFAULT ('H') FOR [link_hub_satellite_flag];


GO
PRINT N'Creating [dbo].[DF_dv_satellite_duplicate_removal_threshold]...';


GO
ALTER TABLE [dbo].[dv_satellite]
    ADD CONSTRAINT [DF_dv_satellite_duplicate_removal_threshold] DEFAULT ((0)) FOR [duplicate_removal_threshold];


GO
PRINT N'Creating [dbo].[DF__dv_satell__is_co__75A278F5]...';


GO
ALTER TABLE [dbo].[dv_satellite]
    ADD CONSTRAINT [DF__dv_satell__is_co__75A278F5] DEFAULT ((0)) FOR [is_columnstore];


GO
PRINT N'Creating unnamed constraint on [dbo].[dv_satellite]...';


GO
ALTER TABLE [dbo].[dv_satellite]
    ADD DEFAULT ((0)) FOR [is_retired];


GO
PRINT N'Creating [dbo].[DF_dv_satellite_release_key]...';


GO
ALTER TABLE [dbo].[dv_satellite]
    ADD CONSTRAINT [DF_dv_satellite_release_key] DEFAULT ((0)) FOR [release_key];


GO
PRINT N'Creating [dbo].[DF__dv_satell__versi__76969D2E]...';


GO
ALTER TABLE [dbo].[dv_satellite]
    ADD CONSTRAINT [DF__dv_satell__versi__76969D2E] DEFAULT ((1)) FOR [version_number];


GO
PRINT N'Creating [dbo].[DF__dv_satell__updat__778AC167]...';


GO
ALTER TABLE [dbo].[dv_satellite]
    ADD CONSTRAINT [DF__dv_satell__updat__778AC167] DEFAULT (suser_name()) FOR [updated_by];


GO
PRINT N'Creating [dbo].[DF__dv_satell__updat__787EE5A0]...';


GO
ALTER TABLE [dbo].[dv_satellite]
    ADD CONSTRAINT [DF__dv_satell__updat__787EE5A0] DEFAULT (sysdatetimeoffset()) FOR [updated_datetime];


GO
PRINT N'Creating [dbo].[DF_dv_hub_column_release_key]...';


GO
ALTER TABLE [dbo].[dv_hub_column]
    ADD CONSTRAINT [DF_dv_hub_column_release_key] DEFAULT ((0)) FOR [release_key];


GO
PRINT N'Creating [dbo].[DF__dv_hub_co__versi__2AD55B43]...';


GO
ALTER TABLE [dbo].[dv_hub_column]
    ADD CONSTRAINT [DF__dv_hub_co__versi__2AD55B43] DEFAULT ((1)) FOR [version_number];


GO
PRINT N'Creating [dbo].[DF__dv_hub_co__updat__2BC97F7C]...';


GO
ALTER TABLE [dbo].[dv_hub_column]
    ADD CONSTRAINT [DF__dv_hub_co__updat__2BC97F7C] DEFAULT (suser_name()) FOR [updated_by];


GO
PRINT N'Creating [dbo].[DF__dv_hub_co__updat__2CBDA3B5]...';


GO
ALTER TABLE [dbo].[dv_hub_column]
    ADD CONSTRAINT [DF__dv_hub_co__updat__2CBDA3B5] DEFAULT (sysdatetimeoffset()) FOR [updated_datetime];


GO
PRINT N'Creating [dbo].[DF_dv_satellite_column_release_key]...';


GO
ALTER TABLE [dbo].[dv_satellite_column]
    ADD CONSTRAINT [DF_dv_satellite_column_release_key] DEFAULT ((0)) FOR [release_key];


GO
PRINT N'Creating [dbo].[DF__dv_satell__versi__3CF40B7E]...';


GO
ALTER TABLE [dbo].[dv_satellite_column]
    ADD CONSTRAINT [DF__dv_satell__versi__3CF40B7E] DEFAULT ((1)) FOR [version_number];


GO
PRINT N'Creating [dbo].[DF__dv_satell__updat__3DE82FB7]...';


GO
ALTER TABLE [dbo].[dv_satellite_column]
    ADD CONSTRAINT [DF__dv_satell__updat__3DE82FB7] DEFAULT (suser_name()) FOR [updated_by];


GO
PRINT N'Creating [dbo].[DF__dv_satell__updat__3EDC53F0]...';


GO
ALTER TABLE [dbo].[dv_satellite_column]
    ADD CONSTRAINT [DF__dv_satell__updat__3EDC53F0] DEFAULT (sysdatetimeoffset()) FOR [updated_datetime];


GO
PRINT N'Creating unnamed constraint on [dv_log].[dv_load_state]...';


GO
ALTER TABLE [dv_log].[dv_load_state]
    ADD DEFAULT ((-1)) FOR [source_table_key];


GO
PRINT N'Creating unnamed constraint on [dv_log].[dv_load_state]...';


GO
ALTER TABLE [dv_log].[dv_load_state]
    ADD DEFAULT ((-1)) FOR [object_key];


GO
PRINT N'Creating unnamed constraint on [dv_log].[dv_load_state]...';


GO
ALTER TABLE [dv_log].[dv_load_state]
    ADD DEFAULT ('<Unknown>') FOR [object_type];


GO
PRINT N'Creating unnamed constraint on [dv_log].[dv_load_state]...';


GO
ALTER TABLE [dv_log].[dv_load_state]
    ADD DEFAULT ((-1)) FOR [execution_key];


GO
PRINT N'Creating unnamed constraint on [dv_log].[dv_load_state]...';


GO
ALTER TABLE [dv_log].[dv_load_state]
    ADD DEFAULT ((0)) FOR [rows_inserted];


GO
PRINT N'Creating unnamed constraint on [dv_log].[dv_load_state]...';


GO
ALTER TABLE [dv_log].[dv_load_state]
    ADD DEFAULT ((0)) FOR [rows_updated];


GO
PRINT N'Creating unnamed constraint on [dv_log].[dv_load_state]...';


GO
ALTER TABLE [dv_log].[dv_load_state]
    ADD DEFAULT ((0)) FOR [rows_deleted];


GO
PRINT N'Creating unnamed constraint on [dv_log].[dv_load_state]...';


GO
ALTER TABLE [dv_log].[dv_load_state]
    ADD DEFAULT (user_name()) FOR [updated_by];


GO
PRINT N'Creating unnamed constraint on [dv_log].[dv_load_state]...';


GO
ALTER TABLE [dv_log].[dv_load_state]
    ADD DEFAULT (sysdatetimeoffset()) FOR [update_date_time];


GO
PRINT N'Creating unnamed constraint on [dv_log].[dv_execution]...';


GO
ALTER TABLE [dv_log].[dv_execution]
    ADD DEFAULT (sysdatetimeoffset()) FOR [execution_start_datetime];


GO
PRINT N'Creating unnamed constraint on [dv_log].[dv_execution]...';


GO
ALTER TABLE [dv_log].[dv_execution]
    ADD DEFAULT (user_name()) FOR [created_by];


GO
PRINT N'Creating unnamed constraint on [dv_log].[dv_execution]...';


GO
ALTER TABLE [dv_log].[dv_execution]
    ADD DEFAULT (user_name()) FOR [updated_by];


GO
PRINT N'Creating unnamed constraint on [dv_log].[dv_execution]...';


GO
ALTER TABLE [dv_log].[dv_execution]
    ADD DEFAULT (sysdatetimeoffset()) FOR [update_date_time];


GO
PRINT N'Creating [dv_release].[DF_dv_release_build_release_number]...';


GO
ALTER TABLE [dv_release].[dv_release_build]
    ADD CONSTRAINT [DF_dv_release_build_release_number] DEFAULT ((0)) FOR [release_number];


GO
PRINT N'Creating [dv_release].[DF_dv_release_build_release_statement_type]...';


GO
ALTER TABLE [dv_release].[dv_release_build]
    ADD CONSTRAINT [DF_dv_release_build_release_statement_type] DEFAULT ('Header') FOR [release_statement_type];


GO
PRINT N'Creating [dv_release].[DF_dv_release_build_affected_row_count]...';


GO
ALTER TABLE [dv_release].[dv_release_build]
    ADD CONSTRAINT [DF_dv_release_build_affected_row_count] DEFAULT ((0)) FOR [affected_row_count];


GO
PRINT N'Creating [dv_release].[DF_release.dv_release_master_build_number]...';


GO
ALTER TABLE [dv_release].[dv_release_master]
    ADD CONSTRAINT [DF_release.dv_release_master_build_number] DEFAULT ((0)) FOR [build_number];


GO
PRINT N'Creating [dv_release].[DF_release.dv_release_master_release_count]...';


GO
ALTER TABLE [dv_release].[dv_release_master]
    ADD CONSTRAINT [DF_release.dv_release_master_release_count] DEFAULT ((0)) FOR [release_count];


GO
PRINT N'Creating [dv_release].[DF_release.dv_release_master_version_number]...';


GO
ALTER TABLE [dv_release].[dv_release_master]
    ADD CONSTRAINT [DF_release.dv_release_master_version_number] DEFAULT ((1)) FOR [version_number];


GO
PRINT N'Creating [dv_release].[DF_release.dv_release_master_updated_by]...';


GO
ALTER TABLE [dv_release].[dv_release_master]
    ADD CONSTRAINT [DF_release.dv_release_master_updated_by] DEFAULT (suser_name()) FOR [updated_by];


GO
PRINT N'Creating [dv_release].[DF_release.dv_release_master_updated_datetime]...';


GO
ALTER TABLE [dv_release].[dv_release_master]
    ADD CONSTRAINT [DF_release.dv_release_master_updated_datetime] DEFAULT (sysdatetimeoffset()) FOR [updated_datetime];


GO
PRINT N'Creating [dv_scheduler].[DF__dv_run__run_status]...';


GO
ALTER TABLE [dv_scheduler].[dv_run]
    ADD CONSTRAINT [DF__dv_run__run_status] DEFAULT ('Scheduled') FOR [run_status];


GO
PRINT N'Creating [dv_scheduler].[DF__dv_run__updated__datetime]...';


GO
ALTER TABLE [dv_scheduler].[dv_run]
    ADD CONSTRAINT [DF__dv_run__updated__datetime] DEFAULT (sysdatetimeoffset()) FOR [updated_datetime];


GO
PRINT N'Creating [dv_scheduler].[DF_dv_source_table_hierarchy_is_deleted]...';


GO
ALTER TABLE [dv_scheduler].[dv_source_table_hierarchy]
    ADD CONSTRAINT [DF_dv_source_table_hierarchy_is_deleted] DEFAULT ((0)) FOR [is_cancelled];


GO
PRINT N'Creating [dv_scheduler].[DF_dv_source_table_hierarchy_release_key]...';


GO
ALTER TABLE [dv_scheduler].[dv_source_table_hierarchy]
    ADD CONSTRAINT [DF_dv_source_table_hierarchy_release_key] DEFAULT ((0)) FOR [release_key];


GO
PRINT N'Creating [dv_scheduler].[DF_dv_source_table_hierarchy_version_number]...';


GO
ALTER TABLE [dv_scheduler].[dv_source_table_hierarchy]
    ADD CONSTRAINT [DF_dv_source_table_hierarchy_version_number] DEFAULT ((1)) FOR [version_number];


GO
PRINT N'Creating [dv_scheduler].[DF_dv_source_table_hierarchy_updated_by]...';


GO
ALTER TABLE [dv_scheduler].[dv_source_table_hierarchy]
    ADD CONSTRAINT [DF_dv_source_table_hierarchy_updated_by] DEFAULT (suser_name()) FOR [updated_by];


GO
PRINT N'Creating [dv_scheduler].[DF_dv_source_table_hierarchy_update_date_time]...';


GO
ALTER TABLE [dv_scheduler].[dv_source_table_hierarchy]
    ADD CONSTRAINT [DF_dv_source_table_hierarchy_update_date_time] DEFAULT (sysdatetimeoffset()) FOR [update_date_time];


GO
PRINT N'Creating [dv_scheduler].[DF_dv_schedule_source_table_source_table_load_type]...';


GO
ALTER TABLE [dv_scheduler].[dv_schedule_source_table]
    ADD CONSTRAINT [DF_dv_schedule_source_table_source_table_load_type] DEFAULT ('Full') FOR [source_table_load_type];


GO
PRINT N'Creating [dv_scheduler].[DF_dv_schedule_source_table_is_deleted]...';


GO
ALTER TABLE [dv_scheduler].[dv_schedule_source_table]
    ADD CONSTRAINT [DF_dv_schedule_source_table_is_deleted] DEFAULT ((0)) FOR [is_cancelled];


GO
PRINT N'Creating [dv_scheduler].[DF__dv_schedule_source_table_release_key]...';


GO
ALTER TABLE [dv_scheduler].[dv_schedule_source_table]
    ADD CONSTRAINT [DF__dv_schedule_source_table_release_key] DEFAULT ((0)) FOR [release_key];


GO
PRINT N'Creating [dv_scheduler].[DF__dv_schedule_source_table__version___534D60F1]...';


GO
ALTER TABLE [dv_scheduler].[dv_schedule_source_table]
    ADD CONSTRAINT [DF__dv_schedule_source_table__version___534D60F1] DEFAULT ((1)) FOR [version_number];


GO
PRINT N'Creating [dv_scheduler].[DF__dv_schedule_source_table__updated___5441852A]...';


GO
ALTER TABLE [dv_scheduler].[dv_schedule_source_table]
    ADD CONSTRAINT [DF__dv_schedule_source_table__updated___5441852A] DEFAULT (suser_name()) FOR [updated_by];


GO
PRINT N'Creating [dv_scheduler].[DF__dv_schedule_source_table__updated___5535A963]...';


GO
ALTER TABLE [dv_scheduler].[dv_schedule_source_table]
    ADD CONSTRAINT [DF__dv_schedule_source_table__updated___5535A963] DEFAULT (sysdatetimeoffset()) FOR [updated_datetime];


GO
PRINT N'Creating [dv_scheduler].[DF_dv_schedule_is_deleted]...';


GO
ALTER TABLE [dv_scheduler].[dv_schedule]
    ADD CONSTRAINT [DF_dv_schedule_is_deleted] DEFAULT ((0)) FOR [is_cancelled];


GO
PRINT N'Creating [dv_scheduler].[DF__dv_schedule_release_key]...';


GO
ALTER TABLE [dv_scheduler].[dv_schedule]
    ADD CONSTRAINT [DF__dv_schedule_release_key] DEFAULT ((0)) FOR [release_key];


GO
PRINT N'Creating [dv_scheduler].[DF__dv_schedule__version___534D60F1]...';


GO
ALTER TABLE [dv_scheduler].[dv_schedule]
    ADD CONSTRAINT [DF__dv_schedule__version___534D60F1] DEFAULT ((1)) FOR [version_number];


GO
PRINT N'Creating [dv_scheduler].[DF__dv_schedule__updated___5441852A]...';


GO
ALTER TABLE [dv_scheduler].[dv_schedule]
    ADD CONSTRAINT [DF__dv_schedule__updated___5441852A] DEFAULT (suser_name()) FOR [updated_by];


GO
PRINT N'Creating [dv_scheduler].[DF__dv_schedule__updated___5535A963]...';


GO
ALTER TABLE [dv_scheduler].[dv_schedule]
    ADD CONSTRAINT [DF__dv_schedule__updated___5535A963] DEFAULT (sysdatetimeoffset()) FOR [updated_datetime];


GO
PRINT N'Creating [dv_scheduler].[DF_dv_run_manifest_hierarchy_update_date_time]...';


GO
ALTER TABLE [dv_scheduler].[dv_run_manifest_hierarchy]
    ADD CONSTRAINT [DF_dv_run_manifest_hierarchy_update_date_time] DEFAULT (sysdatetimeoffset()) FOR [update_date_time];


GO
PRINT N'Creating [dv_scheduler].[DF_dv_run_manifest_queue]...';


GO
ALTER TABLE [dv_scheduler].[dv_run_manifest]
    ADD CONSTRAINT [DF_dv_run_manifest_queue] DEFAULT ('002') FOR [queue];


GO
PRINT N'Creating [dv_scheduler].[DF_dv_run_manifest_run_status]...';


GO
ALTER TABLE [dv_scheduler].[dv_run_manifest]
    ADD CONSTRAINT [DF_dv_run_manifest_run_status] DEFAULT ('Scheduled') FOR [run_status];


GO
PRINT N'Creating [dv_scheduler].[DF_dv_run_manifest_row_count]...';


GO
ALTER TABLE [dv_scheduler].[dv_run_manifest]
    ADD CONSTRAINT [DF_dv_run_manifest_row_count] DEFAULT ((0)) FOR [row_count];


GO
PRINT N'Creating [log4].[DF_Journal_UtcDate]...';


GO
ALTER TABLE [log4].[Journal]
    ADD CONSTRAINT [DF_Journal_UtcDate] DEFAULT (getutcdate()) FOR [UtcDate];


GO
PRINT N'Creating [log4].[DF_Journal_SystemDate]...';


GO
ALTER TABLE [log4].[Journal]
    ADD CONSTRAINT [DF_Journal_SystemDate] DEFAULT (getdate()) FOR [SystemDate];


GO
PRINT N'Creating [log4].[DF_Journal_Task]...';


GO
ALTER TABLE [log4].[Journal]
    ADD CONSTRAINT [DF_Journal_Task] DEFAULT ('') FOR [Task];


GO
PRINT N'Creating [log4].[DF_Exception_UtcDate]...';


GO
ALTER TABLE [log4].[Exception]
    ADD CONSTRAINT [DF_Exception_UtcDate] DEFAULT (getutcdate()) FOR [UtcDate];


GO
PRINT N'Creating [log4].[DF_Exception_SystemDate]...';


GO
ALTER TABLE [log4].[Exception]
    ADD CONSTRAINT [DF_Exception_SystemDate] DEFAULT (getdate()) FOR [SystemDate];


GO
PRINT N'Creating [dbo].[FK__dv_column__dv_source_table]...';


GO
ALTER TABLE [dbo].[dv_column]
    ADD CONSTRAINT [FK__dv_column__dv_source_table] FOREIGN KEY ([table_key]) REFERENCES [dbo].[dv_source_table] ([source_table_key]);


GO
PRINT N'Creating [dbo].[FK_dv_column_dv_release_master]...';


GO
ALTER TABLE [dbo].[dv_column]
    ADD CONSTRAINT [FK_dv_column_dv_release_master] FOREIGN KEY ([release_key]) REFERENCES [dv_release].[dv_release_master] ([release_key]);


GO
PRINT N'Creating [dbo].[FK__dv_column__dv_column_relationship]...';


GO
ALTER TABLE [dbo].[dv_column_relationship]
    ADD CONSTRAINT [FK__dv_column__dv_column_relationship] FOREIGN KEY ([foreign_column_key]) REFERENCES [dbo].[dv_column] ([column_key]);


GO
PRINT N'Creating [dbo].[FK_dv_column_relationship_dv_release_master]...';


GO
ALTER TABLE [dbo].[dv_column_relationship]
    ADD CONSTRAINT [FK_dv_column_relationship_dv_release_master] FOREIGN KEY ([release_key]) REFERENCES [dv_release].[dv_release_master] ([release_key]);


GO
PRINT N'Creating [dbo].[FK_dv_default_column_dv_release_master]...';


GO
ALTER TABLE [dbo].[dv_default_column]
    ADD CONSTRAINT [FK_dv_default_column_dv_release_master] FOREIGN KEY ([release_key]) REFERENCES [dv_release].[dv_release_master] ([release_key]);


GO
PRINT N'Creating [dbo].[FK_dv_defaults_dv_release_master]...';


GO
ALTER TABLE [dbo].[dv_defaults]
    ADD CONSTRAINT [FK_dv_defaults_dv_release_master] FOREIGN KEY ([release_key]) REFERENCES [dv_release].[dv_release_master] ([release_key]);


GO
PRINT N'Creating [dbo].[FK_dv_hub_dv_release_master]...';


GO
ALTER TABLE [dbo].[dv_hub]
    ADD CONSTRAINT [FK_dv_hub_dv_release_master] FOREIGN KEY ([release_key]) REFERENCES [dv_release].[dv_release_master] ([release_key]);


GO
PRINT N'Creating [dbo].[FK__dv_hub_key_column__dv_hub]...';


GO
ALTER TABLE [dbo].[dv_hub_key_column]
    ADD CONSTRAINT [FK__dv_hub_key_column__dv_hub] FOREIGN KEY ([hub_key]) REFERENCES [dbo].[dv_hub] ([hub_key]);


GO
PRINT N'Creating [dbo].[FK_dv_hub_key_column_dv_release_master]...';


GO
ALTER TABLE [dbo].[dv_hub_key_column]
    ADD CONSTRAINT [FK_dv_hub_key_column_dv_release_master] FOREIGN KEY ([release_key]) REFERENCES [dv_release].[dv_release_master] ([release_key]);


GO
PRINT N'Creating [dbo].[FK__dv_hub_link__dv_hub]...';


GO
ALTER TABLE [dbo].[dv_hub_link]
    ADD CONSTRAINT [FK__dv_hub_link__dv_hub] FOREIGN KEY ([hub_key]) REFERENCES [dbo].[dv_hub] ([hub_key]);


GO
PRINT N'Creating [dbo].[FK__dv_hub_link__dv_link]...';


GO
ALTER TABLE [dbo].[dv_hub_link]
    ADD CONSTRAINT [FK__dv_hub_link__dv_link] FOREIGN KEY ([link_key]) REFERENCES [dbo].[dv_link] ([link_key]);


GO
PRINT N'Creating [dbo].[FK_dv_hub_link_dv_release_master]...';


GO
ALTER TABLE [dbo].[dv_hub_link]
    ADD CONSTRAINT [FK_dv_hub_link_dv_release_master] FOREIGN KEY ([release_key]) REFERENCES [dv_release].[dv_release_master] ([release_key]);


GO
PRINT N'Creating [dbo].[FK_dv_link_dv_release_master]...';


GO
ALTER TABLE [dbo].[dv_link]
    ADD CONSTRAINT [FK_dv_link_dv_release_master] FOREIGN KEY ([release_key]) REFERENCES [dv_release].[dv_release_master] ([release_key]);


GO
PRINT N'Creating [dbo].[FK_dv_source_system_dv_release_master]...';


GO
ALTER TABLE [dbo].[dv_source_system]
    ADD CONSTRAINT [FK_dv_source_system_dv_release_master] FOREIGN KEY ([release_key]) REFERENCES [dv_release].[dv_release_master] ([release_key]);


GO
PRINT N'Creating [dbo].[FK__dv_source_table__dv_source_system]...';


GO
ALTER TABLE [dbo].[dv_source_table]
    ADD CONSTRAINT [FK__dv_source_table__dv_source_system] FOREIGN KEY ([system_key]) REFERENCES [dbo].[dv_source_system] ([source_system_key]);


GO
PRINT N'Creating [dbo].[FK_dv_source_table_dv_release_master]...';


GO
ALTER TABLE [dbo].[dv_source_table]
    ADD CONSTRAINT [FK_dv_source_table_dv_release_master] FOREIGN KEY ([release_key]) REFERENCES [dv_release].[dv_release_master] ([release_key]);


GO
PRINT N'Creating [dbo].[FK__dv_satellite__dv_hub]...';


GO
ALTER TABLE [dbo].[dv_satellite]
    ADD CONSTRAINT [FK__dv_satellite__dv_hub] FOREIGN KEY ([hub_key]) REFERENCES [dbo].[dv_hub] ([hub_key]);


GO
PRINT N'Creating [dbo].[FK__dv_satellite__dv_link]...';


GO
ALTER TABLE [dbo].[dv_satellite]
    ADD CONSTRAINT [FK__dv_satellite__dv_link] FOREIGN KEY ([link_key]) REFERENCES [dbo].[dv_link] ([link_key]);


GO
PRINT N'Creating [dbo].[FK_dv_satellite_dv_release_master]...';


GO
ALTER TABLE [dbo].[dv_satellite]
    ADD CONSTRAINT [FK_dv_satellite_dv_release_master] FOREIGN KEY ([release_key]) REFERENCES [dv_release].[dv_release_master] ([release_key]);


GO
PRINT N'Creating [dbo].[FK__dv_hub_column__dv_column]...';


GO
ALTER TABLE [dbo].[dv_hub_column]
    ADD CONSTRAINT [FK__dv_hub_column__dv_column] FOREIGN KEY ([column_key]) REFERENCES [dbo].[dv_column] ([column_key]);


GO
PRINT N'Creating [dbo].[FK__dv_hub_column__dv_hub_key_column]...';


GO
ALTER TABLE [dbo].[dv_hub_column]
    ADD CONSTRAINT [FK__dv_hub_column__dv_hub_key_column] FOREIGN KEY ([hub_key_column_key]) REFERENCES [dbo].[dv_hub_key_column] ([hub_key_column_key]);


GO
PRINT N'Creating [dbo].[FK_dv_hub_column_dv_release_master]...';


GO
ALTER TABLE [dbo].[dv_hub_column]
    ADD CONSTRAINT [FK_dv_hub_column_dv_release_master] FOREIGN KEY ([release_key]) REFERENCES [dv_release].[dv_release_master] ([release_key]);


GO
PRINT N'Creating [dbo].[FK__dv_satellite_column__dv_column]...';


GO
ALTER TABLE [dbo].[dv_satellite_column]
    ADD CONSTRAINT [FK__dv_satellite_column__dv_column] FOREIGN KEY ([column_key]) REFERENCES [dbo].[dv_column] ([column_key]);


GO
PRINT N'Creating [dbo].[FK__dv_satellite_column__dv_satellite]...';


GO
ALTER TABLE [dbo].[dv_satellite_column]
    ADD CONSTRAINT [FK__dv_satellite_column__dv_satellite] FOREIGN KEY ([satellite_key]) REFERENCES [dbo].[dv_satellite] ([satellite_key]);


GO
PRINT N'Creating [dbo].[FK_dv_satellite_column_dv_release_master]...';


GO
ALTER TABLE [dbo].[dv_satellite_column]
    ADD CONSTRAINT [FK_dv_satellite_column_dv_release_master] FOREIGN KEY ([release_key]) REFERENCES [dv_release].[dv_release_master] ([release_key]);


GO
PRINT N'Creating [dv_scheduler].[FK_dv_source_table_hierarchy__prior_source_table]...';


GO
ALTER TABLE [dv_scheduler].[dv_source_table_hierarchy]
    ADD CONSTRAINT [FK_dv_source_table_hierarchy__prior_source_table] FOREIGN KEY ([prior_table_key]) REFERENCES [dbo].[dv_source_table] ([source_table_key]);


GO
PRINT N'Creating [dv_scheduler].[FK_dv_source_table_hierarchy__source_table]...';


GO
ALTER TABLE [dv_scheduler].[dv_source_table_hierarchy]
    ADD CONSTRAINT [FK_dv_source_table_hierarchy__source_table] FOREIGN KEY ([source_table_key]) REFERENCES [dbo].[dv_source_table] ([source_table_key]);


GO
PRINT N'Creating [dv_scheduler].[FK_dv_source_table_hierarchy_dv_release_master]...';


GO
ALTER TABLE [dv_scheduler].[dv_source_table_hierarchy]
    ADD CONSTRAINT [FK_dv_source_table_hierarchy_dv_release_master] FOREIGN KEY ([release_key]) REFERENCES [dv_release].[dv_release_master] ([release_key]);


GO
PRINT N'Creating [dv_scheduler].[FK_dv_schedule_source_table_dv_release_master]...';


GO
ALTER TABLE [dv_scheduler].[dv_schedule_source_table]
    ADD CONSTRAINT [FK_dv_schedule_source_table_dv_release_master] FOREIGN KEY ([release_key]) REFERENCES [dv_release].[dv_release_master] ([release_key]);


GO
PRINT N'Creating [dv_scheduler].[FK_dv_schedule_source_table_dv_schedule]...';


GO
ALTER TABLE [dv_scheduler].[dv_schedule_source_table]
    ADD CONSTRAINT [FK_dv_schedule_source_table_dv_schedule] FOREIGN KEY ([schedule_key]) REFERENCES [dv_scheduler].[dv_schedule] ([schedule_key]);


GO
PRINT N'Creating [dv_scheduler].[FK_dv_schedule_source_table_dv_source_table]...';


GO
ALTER TABLE [dv_scheduler].[dv_schedule_source_table]
    ADD CONSTRAINT [FK_dv_schedule_source_table_dv_source_table] FOREIGN KEY ([source_table_key]) REFERENCES [dbo].[dv_source_table] ([source_table_key]);


GO
PRINT N'Creating [dv_scheduler].[FK_dv_schedule_dv_release_master]...';


GO
ALTER TABLE [dv_scheduler].[dv_schedule]
    ADD CONSTRAINT [FK_dv_schedule_dv_release_master] FOREIGN KEY ([release_key]) REFERENCES [dv_release].[dv_release_master] ([release_key]);


GO
PRINT N'Creating [dv_scheduler].[FK_dv_run_manifest_hierarchy__manifest_key]...';


GO
ALTER TABLE [dv_scheduler].[dv_run_manifest_hierarchy]
    ADD CONSTRAINT [FK_dv_run_manifest_hierarchy__manifest_key] FOREIGN KEY ([run_manifest_key]) REFERENCES [dv_scheduler].[dv_run_manifest] ([run_manifest_key]);


GO
PRINT N'Creating [dv_scheduler].[FK_dv_run_manifest_hierarchy__manifest_prior_key]...';


GO
ALTER TABLE [dv_scheduler].[dv_run_manifest_hierarchy]
    ADD CONSTRAINT [FK_dv_run_manifest_hierarchy__manifest_prior_key] FOREIGN KEY ([run_manifest_prior_key]) REFERENCES [dv_scheduler].[dv_run_manifest] ([run_manifest_key]);


GO
PRINT N'Creating [dv_scheduler].[FK_dv_run_manifest__dv_run]...';


GO
ALTER TABLE [dv_scheduler].[dv_run_manifest]
    ADD CONSTRAINT [FK_dv_run_manifest__dv_run] FOREIGN KEY ([run_key]) REFERENCES [dv_scheduler].[dv_run] ([run_key]);


GO
PRINT N'Creating [log4].[FK_JournalDetail_Journal]...';


GO
ALTER TABLE [log4].[JournalDetail]
    ADD CONSTRAINT [FK_JournalDetail_Journal] FOREIGN KEY ([JournalId]) REFERENCES [log4].[Journal] ([JournalId]) ON DELETE CASCADE;


GO
PRINT N'Creating [dbo].[CK_dv_satellite__link_hub_flag]...';


GO
ALTER TABLE [dbo].[dv_satellite]
    ADD CONSTRAINT [CK_dv_satellite__link_hub_flag] CHECK ([link_hub_satellite_flag]='H' OR [link_hub_satellite_flag]='L');


GO
PRINT N'Creating [dv_scheduler].[CK_dv_run_status]...';


GO
ALTER TABLE [dv_scheduler].[dv_run]
    ADD CONSTRAINT [CK_dv_run_status] CHECK ([run_status]='Scheduled' OR [run_status]='Started' OR [run_status]='Completed' OR [run_status]='Disabled' OR [run_status]='Cancelled' OR [run_status]='Failed');


GO
PRINT N'Creating [dv_scheduler].[CK_dv_schedule_source_table__priority]...';


GO
ALTER TABLE [dv_scheduler].[dv_schedule_source_table]
    ADD CONSTRAINT [CK_dv_schedule_source_table__priority] CHECK ([priority]='Low' OR [priority]='High');


GO
PRINT N'Creating [dv_scheduler].[CK_dv_schedule_source_table__queue]...';


GO
ALTER TABLE [dv_scheduler].[dv_schedule_source_table]
    ADD CONSTRAINT [CK_dv_schedule_source_table__queue] CHECK ([queue]='001' OR [queue]='002');


GO
PRINT N'Creating [dv_scheduler].[CK_dv_schedule_source_table__run_type]...';


GO
ALTER TABLE [dv_scheduler].[dv_schedule_source_table]
    ADD CONSTRAINT [CK_dv_schedule_source_table__run_type] CHECK ([source_table_load_type]='Full' OR [source_table_load_type]='Delta' OR [source_table_load_type]='Default');


GO
PRINT N'Creating [dv_scheduler].[CK_dv_run_manifest__priority]...';


GO
ALTER TABLE [dv_scheduler].[dv_run_manifest]
    ADD CONSTRAINT [CK_dv_run_manifest__priority] CHECK ([priority]='high' OR [priority]='low');


GO
PRINT N'Creating [dv_scheduler].[CK_dv_run_manifest__queue]...';


GO
ALTER TABLE [dv_scheduler].[dv_run_manifest]
    ADD CONSTRAINT [CK_dv_run_manifest__queue] CHECK ([queue]='001' OR [queue]='002');


GO
PRINT N'Creating [dv_scheduler].[CK_dv_run_manifest__run_status]...';


GO
ALTER TABLE [dv_scheduler].[dv_run_manifest]
    ADD CONSTRAINT [CK_dv_run_manifest__run_status] CHECK ([run_status]='Scheduled' OR [run_status]='Queued' OR [run_status]='Processing' OR [run_status]='Completed' OR [run_status]='Cancelled' OR [run_status]='Failed');


GO
PRINT N'Creating [dv_scheduler].[CK_dv_run_manifest__run_type]...';


GO
ALTER TABLE [dv_scheduler].[dv_run_manifest]
    ADD CONSTRAINT [CK_dv_run_manifest__run_type] CHECK ([source_table_load_type]='Full' OR [source_table_load_type]='Delta');


GO
PRINT N'Creating [log4].[CK_JournalControl_OnOffSwitch]...';


GO
ALTER TABLE [log4].[JournalControl]
    ADD CONSTRAINT [CK_JournalControl_OnOffSwitch] CHECK ([OnOffSwitch]='OFF' OR [OnOffSwitch]='ON');


GO
PRINT N'Creating [dbo].[dv_column_audit]...';


GO


CREATE TRIGGER [dbo].[dv_column_audit]
on [dbo].[dv_column]
after insert, update
as
begin
update a
set [update_date_time] = sysdatetimeoffset(),
    [updated_by]	   = suser_name()
from [dbo].[dv_column] as a
join inserted as b 
on a.[column_key] = b.[column_key]; 
end
GO
PRINT N'Creating [dbo].[dv_column_relationship_audit]...';


GO
CREATE TRIGGER [dbo].[dv_column_relationship_audit] ON [dbo].[dv_column_relationship]
AFTER INSERT, UPDATE
AS
	BEGIN
	    UPDATE [a]
		 SET
			[updated_datetime] = SYSDATETIMEOFFSET()
		   , [updated_by] = SUSER_NAME() FROM [dbo].[dv_column_relationship] AS [a]
									   JOIN [inserted] AS [b]
									   ON [a].[column_relationship_key] = [b].[column_relationship_key];
	END;
GO
PRINT N'Creating [dbo].[dv_default_column_audit]...';


GO
CREATE TRIGGER [dbo].[dv_default_column_audit]
on [dbo].[dv_default_column]
after insert, update
as
begin
update a
set [update_date_time] = sysdatetimeoffset(),
    [updated_by]	   = suser_name()
from [dbo].[dv_default_column] as a
join inserted as b 
on a.[default_column_key] = b.[default_column_key]; 
end
GO
PRINT N'Creating [dbo].[dv_defaults_audit]...';


GO
CREATE TRIGGER [dbo].[dv_defaults_audit]
on [dbo].[dv_defaults]
after insert, update
as
begin
update a
set [updated_datetime] = sysdatetimeoffset(),
    [updated_by]	   = suser_name()
from [dbo].[dv_defaults] as a
join inserted as b 
on a.[default_key] = b.[default_key]; 
end
GO
PRINT N'Creating [dbo].[dv_hub_audit]...';


GO
CREATE TRIGGER [dbo].[dv_hub_audit] ON [dbo].[dv_hub]
AFTER INSERT, UPDATE
AS
	BEGIN
	    UPDATE [a]
		 SET
			[updated_datetime] = SYSDATETIMEOFFSET()
		   , [updated_by] = SUSER_NAME() FROM [dbo].[dv_hub] AS [a]
									   JOIN [inserted] AS [b]
									   ON [a].[hub_key] = [b].[hub_key];
	END;
GO
PRINT N'Creating [dbo].[dv_hub_key_column_audit]...';


GO
CREATE TRIGGER [dbo].[dv_hub_key_column_audit] ON [dbo].[dv_hub_key_column]
AFTER INSERT, UPDATE
AS
	BEGIN
	    UPDATE [a]
		 SET
			[updated_datetime] = SYSDATETIMEOFFSET()
		   , [updated_by] = SUSER_NAME() FROM [dbo].[dv_hub_key_column] AS [a]
									   JOIN [inserted] AS [b]
									   ON [a].[hub_key_column_key] = [b].[hub_key_column_key];
	END;
GO
PRINT N'Creating [dbo].[dv_hub_link_audit]...';


GO
CREATE TRIGGER [dbo].[dv_hub_link_audit] ON [dbo].[dv_hub_link]
AFTER INSERT, UPDATE
AS
	BEGIN
	    UPDATE [a]
		 SET
			[updated_datetime] = SYSDATETIMEOFFSET()
		   , [updated_by] = SUSER_NAME() FROM [dbo].[dv_hub_link] AS [a]
									   JOIN [inserted] AS [b]
									   ON [a].[hub_link_key] = [b].[hub_link_key];
	END;
GO
PRINT N'Creating [dbo].[dv_link_audit]...';


GO


CREATE TRIGGER [dbo].[dv_link_audit] ON [dbo].[dv_link]
AFTER INSERT, UPDATE
AS
	BEGIN
	    UPDATE [a]
		 SET
			[updated_datetime] = SYSDATETIMEOFFSET()
		   , [updated_by] = SUSER_NAME() FROM [dbo].[dv_link] AS [a]
									   JOIN [inserted] AS [b]
									   ON [a].[link_key] = [b].[link_key];
	END;
GO
PRINT N'Creating [dbo].[dv_source_system_audit]...';


GO

CREATE TRIGGER [dbo].[dv_source_system_audit] ON [dbo].[dv_source_system]
AFTER INSERT, UPDATE
AS
	BEGIN
	    UPDATE [a]
		 SET
			[update_date_time] = SYSDATETIMEOFFSET()
		   , [updated_by] = SUSER_NAME() FROM [dbo].[dv_source_system] AS [a]
									   JOIN [inserted] AS [b]
									   ON [a].[source_system_key] = [b].[source_system_key];
	END;
GO
PRINT N'Creating [dbo].[dv_source_table_audit]...';


GO
CREATE TRIGGER [dbo].[dv_source_table_audit] ON [dbo].[dv_source_table]
AFTER INSERT, UPDATE
AS
	BEGIN
	    UPDATE [a]
		 SET
			[update_date_time] = SYSDATETIMEOFFSET()
		   , [updated_by] = SUSER_NAME() FROM [dbo].[dv_source_table] AS [a]
									   JOIN [inserted] AS [b]
									   ON [a].[source_table_key] = [b].[source_table_key];
	END;
GO
PRINT N'Creating [dbo].[dv_satellite_audit]...';


GO

CREATE TRIGGER [dbo].[dv_satellite_audit] ON [dbo].[dv_satellite]
AFTER INSERT, UPDATE
AS
	BEGIN
	    UPDATE [a]
		 SET
			[updated_datetime] = SYSDATETIMEOFFSET()
		   , [updated_by] = SUSER_NAME() FROM [dbo].[dv_satellite] AS [a]
									   JOIN [inserted] AS [b]
									   ON [a].[satellite_key] = [b].[satellite_key];
	END;
GO
PRINT N'Creating [dbo].[dv_hub_column_audit]...';


GO
CREATE TRIGGER [dbo].[dv_hub_column_audit] ON [dbo].[dv_hub_column]
AFTER INSERT, UPDATE
AS
	BEGIN
	    UPDATE [a]
		 SET
			[updated_datetime] = SYSDATETIMEOFFSET()
		   , [updated_by] = SUSER_NAME() FROM [dbo].[dv_hub_column] AS [a]
									   JOIN [inserted] AS [b]
									   ON [a].[hub_col_key] = [b].[hub_col_key];
	END;
GO
PRINT N'Creating [dbo].[dv_satellite_column_audit]...';


GO
CREATE TRIGGER [dbo].[dv_satellite_column_audit] ON [dbo].[dv_satellite_column]
AFTER INSERT, UPDATE
AS
	BEGIN
	    UPDATE [a]
		 SET
			[updated_datetime] = SYSDATETIMEOFFSET()
		   , [updated_by] = SUSER_NAME() FROM [dbo].[dv_satellite_column] AS [a]
									   JOIN [inserted] AS [b]
									   ON [a].[satellite_col_key] = [b].[satellite_col_key];
	END;
GO
PRINT N'Creating [dv_log].[dv_load_state_audit]...';


GO

CREATE TRIGGER [dv_log].[dv_load_state_audit] ON [dv_log].[dv_load_state]
AFTER INSERT, UPDATE
AS
	BEGIN
	    UPDATE [a]
		 SET
			[update_date_time] = SYSDATETIMEOFFSET()
		   , [updated_by] = SUSER_NAME() FROM [dv_log].[dv_load_state] AS [a]
									   JOIN [inserted] AS [b]
									   ON [a].[load_state_key] = [b].[load_state_key];
	END;
GO
PRINT N'Creating [dv_log].[dv_execution_audit]...';


GO


CREATE TRIGGER [dv_log].[dv_execution_audit] ON [dv_log].[dv_execution]
AFTER INSERT, UPDATE
AS
	BEGIN
	    UPDATE [a]
		 SET
			[update_date_time] = SYSDATETIMEOFFSET()
		   , [updated_by] = SUSER_NAME() FROM [dv_log].[dv_execution] AS [a]
									   JOIN [inserted] AS [b]
									   ON [a].[execution_key] = [b].[execution_key];
	END;
GO
PRINT N'Creating [dv_release].[dv_release_master_audit]...';


GO
CREATE TRIGGER [dv_release].[dv_release_master_audit] ON [dv_release].[dv_release_master]
AFTER INSERT, UPDATE
AS
	BEGIN
	    UPDATE [a]
		 SET
			[updated_datetime] = SYSDATETIMEOFFSET()
		   , [updated_by] = SUSER_NAME() FROM [dv_release].[dv_release_master] AS [a]
									   JOIN [inserted] AS [b]
									   ON [a].[release_key] = [b].[release_key];
	END;
GO
PRINT N'Creating [dv_scheduler].[dv_source_table_hierarchy_audit]...';


GO
CREATE TRIGGER [dv_scheduler].[dv_source_table_hierarchy_audit] ON [dv_scheduler].[dv_source_table_hierarchy]
AFTER INSERT, UPDATE
AS
	BEGIN
	    UPDATE [a]
		 SET
			[update_date_time] = SYSDATETIMEOFFSET()
		   , [updated_by] = SUSER_NAME() FROM [dv_scheduler].[dv_source_table_hierarchy] AS [a]
									   JOIN [inserted] AS [b]
									   ON [a].[source_table_hierarchy_key] = [b].[source_table_hierarchy_key];
	END;
GO
PRINT N'Creating [dv_scheduler].[dv_schedule_source_table_audit]...';


GO
CREATE TRIGGER [dv_scheduler].[dv_schedule_source_table_audit] ON [dv_scheduler].[dv_schedule_source_table]
AFTER INSERT, UPDATE
AS
	BEGIN
	    UPDATE [a]
		 SET
			[updated_datetime] = SYSDATETIMEOFFSET()
		   , [updated_by] = SUSER_NAME() FROM [dv_scheduler].[dv_schedule_source_table] AS [a]
									   JOIN [inserted] AS [b]
									   ON [a].[schedule_source_table_key] = [b].[schedule_source_table_key];
	END;
GO
PRINT N'Creating [dv_scheduler].[dv_schedule_audit]...';


GO
CREATE TRIGGER [dv_scheduler].[dv_schedule_audit] ON [dv_scheduler].[dv_schedule]
AFTER INSERT, UPDATE
AS
	BEGIN
	    UPDATE [a]
		 SET
			[updated_datetime] = SYSDATETIMEOFFSET()
		   , [updated_by] = SUSER_NAME() FROM [dv_scheduler].[dv_schedule] AS [a]
									   JOIN [inserted] AS [b]
									   ON [a].[schedule_key] = [b].[schedule_key];
	END;
GO
PRINT N'Creating [dv_scheduler].[trg_dv_manifest_status]...';


GO
CREATE Trigger [dv_scheduler].[trg_dv_manifest_status] on [dv_scheduler].[dv_run_manifest]
AFTER UPDATE AS
BEGIN
  /* Insert Can Only be Status 'Scheduled'*/
BEGIN TRY
IF EXISTS (SELECT 1 FROM inserted i
            inner join deleted d
			on i.[run_manifest_key] = d.[run_manifest_key]
			WHERE ((i.[run_status] = 'Queued'		and d.[run_status] <> 'Scheduled' )	or
			       (i.[run_status] = 'Processing'	and d.[run_status] <> 'Queued'	  ) or
				   (i.[run_status] = 'Completed'	and d.[run_status] <> 'Processing')	or
				   (i.[run_status] = 'Failed'		and d.[run_status] <> 'Processing') 			
				   )
			)
      THROW 50000, N'Invalid Status Change Detected', 1;
END TRY
BEGIN CATCH
	IF (@@TRANCOUNT > 0)
		ROLLBACK;
		THROW; 
END CATCH;
END;
GO
PRINT N'Creating [dv_scheduler_m001]...';


GO
CREATE MESSAGE TYPE [dv_scheduler_m001]
    AUTHORIZATION [dbo]
    VALIDATION = NONE;


GO
PRINT N'Creating [dv_scheduler_m002]...';


GO
CREATE MESSAGE TYPE [dv_scheduler_m002]
    AUTHORIZATION [dbo]
    VALIDATION = NONE;


GO
PRINT N'Creating [dv_scheduler_c001]...';


GO
CREATE CONTRACT [dv_scheduler_c001]
    AUTHORIZATION [dbo]
    ([dv_scheduler_m001] SENT BY ANY);


GO
PRINT N'Creating [dv_scheduler_c002]...';


GO
CREATE CONTRACT [dv_scheduler_c002]
    AUTHORIZATION [dbo]
    ([dv_scheduler_m002] SENT BY ANY);


GO
PRINT N'Creating [dbo].[fn_build_column_definition]...';


GO
CREATE
FUNCTION [dbo].[fn_build_column_definition] 
(
	@DataType varchar(50)
   ,@DataLength int
   ,@precision int 
   ,@scale int 
   ,@CollationName varchar(50)
   ,@is_nullable bit
   ,@is_identity bit
)
RETURNS varchar(256)
AS
BEGIN
DECLARE @ResultVar varchar(256)

select @ResultVar = UPPER(@DataType)
             + CASE
--NUMERIC
               WHEN UPPER(@DataType) IN ('decimal','numeric')
               THEN '('
                    + CONVERT(VARCHAR,@precision)
                    + ','
                    + CONVERT(VARCHAR,@scale)
                    + ') '
                    + SPACE(6 - LEN(CONVERT(VARCHAR,@precision)
                    + ','
                    + CONVERT(VARCHAR,@scale)))
                    + SPACE(7)
                    + SPACE(16 - LEN(UPPER(@DataType)))
                    
--FLOAT
               WHEN  UPPER(@DataType) IN ('float', 'datetime2') 
               THEN
                    CASE
                      WHEN @precision = 53
                      THEN SPACE(11 - LEN(CONVERT(VARCHAR,@precision)))
                           + SPACE(7)
                           + SPACE(16 - LEN(UPPER(@DataType)))
                      ELSE '('
						   + CONVERT(VARCHAR,@scale)
                           + ') '
                           + SPACE(6 - LEN(CONVERT(VARCHAR,@precision)))
                           + SPACE(7) + SPACE(16 - LEN(UPPER(@DataType)))
   
                      END

               WHEN  UPPER(@DataType) IN ('char','varchar')
               THEN CASE
                      WHEN  @DataLength = -1
                      THEN  '(max)'
                            + SPACE(6 - LEN(CONVERT(VARCHAR,@DataLength)))
                            + SPACE(7) + SPACE(16 - LEN(UPPER(@DataType)))

                      ELSE '('
                           + CONVERT(VARCHAR,@DataLength)
                           + ') '
                           + SPACE(6 - LEN(CONVERT(VARCHAR,@DataLength)))
                           + SPACE(7) + SPACE(16 - LEN(UPPER(@DataType)))
 
                    END
--NVARCHAR
               WHEN UPPER(@DataType) IN ('nchar','nvarchar')
               THEN CASE
                      WHEN  @DataLength = -1
                      THEN '(max)'
                           + SPACE(6 - LEN(CONVERT(VARCHAR,(@DataLength / 2))))
                           + SPACE(7)
                           + SPACE(16 - LEN(UPPER(@DataType)))
                      ELSE '('
                           + CONVERT(VARCHAR,(@DataLength / 2))
                           + ') '
                           + SPACE(6 - LEN(CONVERT(VARCHAR,(@DataLength / 2))))
                           + SPACE(7)
                           + SPACE(16 - LEN(UPPER(@DataType)))
  
                    END
--datetime
               WHEN UPPER(@DataType) IN ('datetime','money','text','image','real')
               THEN SPACE(18 - LEN(UPPER(@DataType)))
                    + '              '
 
--VARBINARY
              WHEN UPPER(@DataType) = 'varbinary'
              THEN
                CASE
                  WHEN @DataLength = -1
                  THEN '(max)'
                       + SPACE(6 - LEN(CONVERT(VARCHAR,(@DataLength))))
                       + SPACE(7)
                       + SPACE(16 - LEN(UPPER(@DataType)))
   
                  ELSE '('
                       + CONVERT(VARCHAR,(@DataLength))
                       + ') '
                       + SPACE(6 - LEN(CONVERT(VARCHAR,(@DataLength))))
                       + SPACE(7)
                       + SPACE(16 - LEN(UPPER(@DataType)))

                END
--INT
               ELSE SPACE(16 - LEN(UPPER(@DataType)))   
                            + SPACE(2)
                            
               END

IF UPPER(@DataType) IN ('nchar','nvarchar','char','varchar')
   IF isnull(@CollationName, '') <> ''
      set @ResultVar = rtrim(@ResultVar) + ' COLLATE ' + @CollationName

set @ResultVar = rtrim(@ResultVar) + case when isnull (@is_identity, 1) = 1 then ' IDENTITY(1,1) ' else ' ' END 

set @ResultVar = rtrim(@ResultVar) + case when isnull (@is_nullable, 1) = 1 then '' else ' NOT' END + ' NULL'
RETURN @ResultVar

END
GO
PRINT N'Creating [dbo].[fn_get_default_value]...';


GO
CREATE 
FUNCTION [dbo].[fn_get_default_value] 
(
	@default_name varchar(50)
   ,@default_type varchar(50)
)
RETURNS sql_variant
AS
BEGIN
DECLARE @ResultVar sql_variant

select @ResultVar = 
     case when [data_type] = 'varchar'	then cast([default_varchar]	 as sql_variant)
	      when [data_type] = 'int'		then cast([default_integer]	 as sql_variant)
		  when [data_type] = 'datetime' then cast([default_dateTime] as sql_variant)
		  else null
		  end
from [dbo].[dv_defaults]
where 1=1
and [default_type] = @default_type
and [default_subtype] = @default_name
RETURN @ResultVar

END
GO
PRINT N'Creating [dbo].[fn_Get_Next_Abbreviation]...';


GO
CREATE FUNCTION [dbo].[fn_Get_Next_Abbreviation] 
(
)	
RETURNS char(4)
AS
BEGIN

DECLARE @ResultVar char(4)

-- See Jeff Modem's article The "Numbers" or "Tally" Table: What it is and how it replaces a loop.
-- at http://www.sqlservercentral.com/articles/T-SQL/62867/  .
;WITH 
Tens     (N) AS (SELECT 0 UNION ALL SELECT 0 UNION ALL SELECT 0 UNION ALL 
                 SELECT 0 UNION ALL SELECT 0 UNION ALL SELECT 0 UNION ALL 
                 SELECT 0 UNION ALL SELECT 0 UNION ALL SELECT 0 UNION ALL SELECT 0) 
,Thousands(N) AS (SELECT 1 FROM Tens t1 CROSS JOIN Tens t2 CROSS JOIN Tens t3)
,Millions (N) AS (SELECT 1 FROM Thousands t1 CROSS JOIN Thousands t2) 
,Billions (N) AS (SELECT 1 FROM Millions t1 CROSS JOIN Millions t2) 
,Tally    (N) AS (SELECT ROW_NUMBER() OVER (ORDER BY (SELECT 0)) FROM Billions)
,CTE1     (A) AS (SELECT CHAR(N+96) FROM Tally WHERE N between 1 and 26)
,CTE2     (B) AS (SELECT c1.A + c2.A FROM CTE1 c1 CROSS JOIN CTE1 c2)
,CTE3     (C) AS (SELECT c1.A + c2.A + c3.A FROM CTE1 c1 CROSS JOIN CTE1 c2 CROSS JOIN CTE1 c3)
,CTE4     (D) AS (SELECT c1.A + c2.A + c3.A + c4.A FROM CTE1 c1 CROSS JOIN CTE1 c2 CROSS JOIN CTE1 c3 CROSS JOIN CTE1 c4)
,CTE5     (E) AS (SELECT c1.A + c2.A + c3.A + c4.A + c5.A FROM CTE1 c1 CROSS JOIN CTE1 c2 CROSS JOIN CTE1 c3 CROSS JOIN CTE1 c4 CROSS JOIN CTE1 c5)
,CTE          AS (SELECT A, RN = 1 FROM CTE1 UNION ALL
                 SELECT B, RN = 2  FROM CTE2 UNION ALL
                 SELECT C, RN = 3  FROM CTE3 UNION ALL
				 SELECT D, RN = 4  FROM CTE4 UNION ALL
                 SELECT E, RN = 5  FROM CTE5)
,max_abbreviation as (
select max(abbreviation) as max_abbreviation from (
select hub_abbreviation as abbreviation from dv_hub
union
--select pit_abbreviation from dv_pit
--union
select link_abbreviation from dv_link
union
select satellite_abbreviation from dv_satellite
union select '0000') a)
select @ResultVar = min( A )FROM CTE where RN = 4 and A > (select max_abbreviation from max_abbreviation)
RETURN @ResultVar

END
GO
PRINT N'Creating [dbo].[fn_get_object_name]...';


GO
CREATE 
FUNCTION [dbo].[fn_get_object_name] 
(
	@object_name varchar(256)
   ,@object_type varchar(50)   
)
RETURNS varchar(256)
AS
BEGIN
DECLARE @ResultVar varchar(256)

select @ResultVar = case
			when [default_subtype] = 'prefix' then [default_varchar] + @object_name
            when [default_subtype] = 'suffix' then @object_name + [default_varchar]
			end 
from [dbo].[dv_defaults]
where 1=1
and [default_type] = @object_type
and [default_subtype] in('prefix', 'suffix')
RETURN @ResultVar

END
GO
PRINT N'Creating [dbo].[fn_proper_case]...';


GO
CREATE FUNCTION [dbo].[fn_proper_case](@Text as varchar(1000))
returns varchar(1000)
as
begin
   declare @Ret varchar(1000);
   set @Ret = lower(@Text)
   set @ret = 
   replace(replace(replace(replace(replace(replace(replace(
replace(replace(replace(replace(replace(replace(replace(
replace(replace(replace(replace(replace(replace(replace(
replace(replace(replace(replace(replace(
' '+@Ret,
' a',' A'),' b',' B'),' c',' C'),' d',' D'),' e',' E'),' f',' F'),
' g',' G'),' h',' H'),' i',' I'),' j',' J'),' k',' K'),' l',' L'),
' m',' M'),' n',' N'),' o',' O'),' p',' P'),' q',' Q'),' r',' R'),
' s',' S'),' t',' T'),' u',' U'),' v',' V'),' w',' W'),' x',' X'),
' y',' Y'),' z',' Z')
   return @Ret
end
GO
PRINT N'Creating [log4].[FormatElapsedTime]...';


GO
/*************************************************************************************************/
--</MaintenanceHeader>

CREATE FUNCTION [log4].[FormatElapsedTime]
(
  @StartTime                      datetime
, @EndTime                        datetime  = NULL
, @ShowMillisecsIfUnderNumSecs    tinyint   = NULL
)

RETURNS varchar  (  48 )

AS

--<CommentHeader>
/**************************************************************************************************

Properties
==========
FUNCTION NAME:      [log4].[FormatElapsedTime]
DESCRIPTION:        Returns a string describing the time elapsed between start and end time
DATE OF ORIGIN:		16-FEB-2007
ORIGINAL AUTHOR:	Greg M. Lucas (data-centric solutions ltd. http://www.data-centric.co.uk)
BUILD DATE:			13-MAR-2012
BUILD VERSION:		0.0.10
DEPENDANTS:         Various
DEPENDENCIES:       None

Additional Notes
================
Builds a string that looks like this: "0 hr(s) 1 min(s) and 22 sec(s)" or "1345 milliseconds"

Revision history
==================================================================================================
ChangeDate		Author	Version		Narrative
============	======	=======		==============================================================
16-FEB-2007		GML		v0.0.2		Created
------------	------	-------		--------------------------------------------------------------

=================================================================================================
(C) Copyright 2006-12 data-centric solutions ltd. (http://log4tsql.sourceforge.net/)

This library is free software; you can redistribute it and/or modify it under the terms of the
GNU Lesser General Public License as published by the Free Software Foundation (www.fsf.org);
either version 3.0 of the License, or (at your option) any later version.

This library is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;
without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
See the GNU Lesser General Public License for more details.

You should have received a copy of the GNU Lesser General Public License along with this
library; if not, you can find it at http://www.opensource.org/licenses/lgpl-3.0.html
or http://www.gnu.org/licenses/lgpl.html

**************************************************************************************************/
--</CommentHeader>

BEGIN
	DECLARE	  @time                     int
			, @hrs                      int
			, @mins                     int
			, @secs                     int
			, @msecs                    int
			, @Duration                 varchar   (   48 )

	IF @StartTime IS NULL AND @EndTime IS NULL
		SET @Duration = 'Start and End Times are both NULL'
	ELSE IF @StartTime IS NULL
		SET @Duration = 'Start Time is NULL'
	ELSE
		BEGIN
			IF @EndTime IS NULL SET @EndTime = GETDATE()

			SET @time = DATEDIFF(ss, @StartTime, @EndTime)

			IF @time > ISNULL(@ShowMillisecsIfUnderNumSecs, 5)
				BEGIN
					SET @hrs        = @time / 3600
					SET @mins       = (@time % 3600) / 60
					SET @secs       = (@time % 3600) % 60
					SET @Duration   = CASE
										WHEN @hrs = 0 THEN ''
										WHEN @hrs = 1 THEN CAST(@hrs AS varchar) + ' hr, '
										ELSE CAST(@hrs AS varchar) + ' hrs, '
									  END
									+ CASE
										WHEN @mins = 1 THEN CAST(@mins AS varchar) + ' min'
										ELSE CAST(@mins AS varchar) + ' mins'
									  END
									+ ' and '
									+ CASE
										WHEN @secs = 1 THEN CAST(@secs AS varchar) + ' sec'
										ELSE CAST(@secs AS varchar) + ' secs'
									  END
				END
			ELSE
				BEGIN
					SET @msecs      = DATEDIFF(ms, @StartTime, @EndTime)
					SET @Duration   = CAST(@msecs AS varchar) + ' milliseconds'
				END
		END

	RETURN @Duration
END
GO
PRINT N'Creating [log4].[GetJournalControl]...';


GO
/*************************************************************************************************/
--</MaintenanceHeader>

CREATE FUNCTION [log4].[GetJournalControl]
(
  @ModuleName		varchar	(  255 )
, @GroupName		varchar	(  255 )
)

RETURNS varchar		(  3 )

AS

--<CommentHeader>
/**************************************************************************************************

Properties
==========
FUNCTION NAME:      [log4].[GetJournalControl]
DESCRIPTION:		Returns the ON/OFF value for the specified Journal Name, or Group Name if
					Module not found or the system default if neither is found
DATE OF ORIGIN:		15-APR-2008
ORIGINAL AUTHOR:	Greg M. Lucas (data-centric solutions ltd. http://www.data-centric.co.uk)
BUILD DATE:			13-MAR-2012
BUILD VERSION:		0.0.10
DEPENDANTS:         Various
DEPENDENCIES:       None

Additional Notes
================
Builds a string that looks like this: "0 hr(s) 1 min(s) and 22 sec(s)" or "1345 milliseconds"

Revision history
==================================================================================================
ChangeDate		Author	Version		Narrative
============	======	=======		==============================================================
15-APR-2008		GML		v0.0.3		Created
------------	------	-------		--------------------------------------------------------------

=================================================================================================
(C) Copyright 2006-12 data-centric solutions ltd. (http://log4tsql.sourceforge.net/)

This library is free software; you can redistribute it and/or modify it under the terms of the
GNU Lesser General Public License as published by the Free Software Foundation (www.fsf.org);
either version 3.0 of the License, or (at your option) any later version.

This library is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;
without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
See the GNU Lesser General Public License for more details.

You should have received a copy of the GNU Lesser General Public License along with this
library; if not, you can find it at http://www.opensource.org/licenses/lgpl-3.0.html
or http://www.gnu.org/licenses/lgpl.html

**************************************************************************************************/
--</CommentHeader>

BEGIN
	RETURN
		(
			SELECT
				TOP 1 OnOffSwitch
			FROM
				(
						SELECT
							  OnOffSwitch
							, 1 AS [Precedence]
						FROM
							[log4].[JournalControl]
						WHERE
							ModuleName = 'SYSTEM_OVERRIDE'
						AND
							OnOffSwitch = 'OFF' -- only care about the override when it's OFF
					UNION
						SELECT
							  OnOffSwitch
							, 10 AS [Precedence]
						FROM
							[log4].[JournalControl]
						WHERE
							ModuleName = @ModuleName
					UNION
						SELECT
							  OnOffSwitch
							, 100 AS [Precedence]
						FROM
							[log4].[JournalControl]
						WHERE
							ModuleName = @GroupName
					UNION
						SELECT
							  OnOffSwitch
							, 200 AS [Precedence]
						FROM
							[log4].[JournalControl]
						WHERE
							ModuleName = 'SYSTEM_DEFAULT'
					UNION
						SELECT
							  'OFF'		AS [OnOffSwitch]
							, 300		AS [Precedence]
				) AS [x]
			ORDER BY
				[Precedence] ASC
		)
END
GO
PRINT N'Creating [dbo].[fn_get_key_definition]...';


GO
CREATE FUNCTION [dbo].[fn_get_key_definition]
(@object_name varchar(256)
,@object_type varchar(30)
)
RETURNS TABLE 
AS
RETURN 
(
select top 1 [column_name] = rtrim(quotename(isnull(column_prefix, '') + replace(column_name, '%',@object_name) + isnull(column_suffix, '')))
    ,[column_type]
    ,[column_length]
	,[column_precision]
	,[column_scale]
	,[collation_Name]
	,[bk_ordinal_position] = -1
    ,[ordinal_position]
	,[Satellite_Ordinal_Position] = -1
FROM [dbo].[dv_default_column]
where 1=1
and object_type = @object_type
and object_column_type = 'Object_Key'
)
GO
PRINT N'Creating [dbo].[fn_get_list_of_days]...';


GO
CREATE FUNCTION [dbo].[fn_get_list_of_days]
-- Note that this function works in Local Server Time, as opposed to Offset time as used elsewhere.
-- That is because this function is setting midnight, in User Terms (local).
-- When joining against this function , with Offset columns, be sure to convert them to dateime2(7) to get the required result.
-- provides an inclusive list of dates - midnight on @start_date to midnight on @end_date
(@start_date	date
,@end_date		date
)
RETURNS TABLE 
AS
RETURN 
(select dateadd(ms, -1, dateadd(day, 1, a.Date)) pit_date
from (select dateadd(day,-(a.a + (10 * b.a) + (100 * c.a) + (1000 * d.a) + (10000 * e.a))
	 ,convert(datetime2(7), @end_date)) as Date
    from (select 0 as a union all select 1 union all select 2 union all select 3 union all select 4 union all select 5 union all select 6 union all select 7 union all select 8 union all select 9) as a
    cross join (select 0 as a union all select 1 union all select 2 union all select 3 union all select 4 union all select 5 union all select 6 union all select 7 union all select 8 union all select 9) as b
    cross join (select 0 as a union all select 1 union all select 2 union all select 3 union all select 4 union all select 5 union all select 6 union all select 7 union all select 8 union all select 9) as c
	cross join (select 0 as a union all select 1 union all select 2 union all select 3 union all select 4 union all select 5 union all select 6 union all select 7 union all select 8 union all select 9) as d
	cross join (select 0 as a union all select 1 union all select 2 union all select 3 union all select 4 union all select 5 union all select 6 union all select 7 union all select 8 union all select 9) as e
) a
where a.Date > dateadd(day, -1, @start_date) 
)
GO
PRINT N'Creating [dbo].[fn_split_strings]...';


GO
SET ANSI_NULLS ON;

SET QUOTED_IDENTIFIER OFF;


GO
CREATE FUNCTION dbo.fn_split_strings
(
	@List VARCHAR(8000),
	@Delimiter VARCHAR(255)
)
-- Courtesy of Jeff Moden.
RETURNS TABLE
WITH SCHEMABINDING AS
RETURN
  WITH E1(N)		AS ( SELECT 1 UNION ALL SELECT 1 UNION ALL SELECT 1 UNION ALL 
						 SELECT 1 UNION ALL SELECT 1 UNION ALL SELECT 1 UNION ALL 
						 SELECT 1 UNION ALL SELECT 1 UNION ALL SELECT 1 UNION ALL SELECT 1),
		E2(N)		AS (SELECT 1 FROM E1 a, E1 b),
		E4(N)		AS (SELECT 1 FROM E2 a, E2 b),
		E42(N)		AS (SELECT 1 FROM E4 a, E2 b),
		cteTally(N) AS (SELECT TOP (ISNULL(DATALENGTH(@List),0)) ROW_NUMBER() OVER (ORDER BY (SELECT NULL)) FROM E4),
		cteStart(N1) AS (SELECT 1 UNION ALL
						 SELECT t.N+1 FROM cteTally t WHERE SUBSTRING(@List,t.N,1) = @Delimiter),
		cteLen(N1,L1) AS(SELECT s.N1, ISNULL(NULLIF(CHARINDEX(@Delimiter,@List,s.N1),0)-s.N1,8000) FROM cteStart s)
	SELECT --ItemNumber = ROW_NUMBER() OVER(ORDER BY l.N1), --item number is disabled
		Item		= SUBSTRING(@List, l.N1, l.L1)
	FROM cteLen l
GO
SET ANSI_NULLS, QUOTED_IDENTIFIER ON;


GO
PRINT N'Creating [dv_release].[fn_config_table_list]...';


GO


CREATE FUNCTION [dv_release].[fn_config_table_list]()
RETURNS TABLE 
AS
RETURN 
(
      SELECT dv_schema_name = cast('dbo'			as sysname), dv_table_name = cast('dv_default_column'			as sysname), dv_key_name = cast('default_column_key'		as sysname), dv_load_order = cast(10  as int)
union SELECT dv_schema_name = cast('dbo'			as sysname), dv_table_name = cast('dv_defaults'					as sysname), dv_key_name = cast('default_key'				as sysname), dv_load_order = cast(20  as int)
union SELECT dv_schema_name = cast('dbo'			as sysname), dv_table_name = cast('dv_source_system'			as sysname), dv_key_name = cast('source_system_key'			as sysname), dv_load_order = cast(30  as int)
union SELECT dv_schema_name = cast('dbo'			as sysname), dv_table_name = cast('dv_source_table'				as sysname), dv_key_name = cast('source_table_key'			as sysname), dv_load_order = cast(40  as int)
union SELECT dv_schema_name = cast('dbo'			as sysname), dv_table_name = cast('dv_column'					as sysname), dv_key_name = cast('column_key'				as sysname), dv_load_order = cast(50  as int)
union SELECT dv_schema_name = cast('dv_scheduler'	as sysname), dv_table_name = cast('dv_schedule'					as sysname), dv_key_name = cast('schedule_key'				as sysname), dv_load_order = cast(60  as int)
union SELECT dv_schema_name = cast('dv_scheduler'	as sysname), dv_table_name = cast('dv_source_table_hierarchy'	as sysname), dv_key_name = cast('source_table_hierarchy_key'as sysname), dv_load_order = cast(70  as int)
union SELECT dv_schema_name = cast('dv_scheduler'	as sysname), dv_table_name = cast('dv_schedule_source_table'	as sysname), dv_key_name = cast('schedule_source_table_key'	as sysname), dv_load_order = cast(80  as int)
union SELECT dv_schema_name = cast('dbo'			as sysname), dv_table_name = cast('dv_column_relationship'		as sysname), dv_key_name = cast('column_relationship_key'	as sysname), dv_load_order = cast(90  as int)
union SELECT dv_schema_name = cast('dbo'			as sysname), dv_table_name = cast('dv_hub'						as sysname), dv_key_name = cast('hub_key'					as sysname), dv_load_order = cast(100 as int)
union SELECT dv_schema_name = cast('dbo'			as sysname), dv_table_name = cast('dv_hub_key_column'			as sysname), dv_key_name = cast('hub_key_column_key'		as sysname), dv_load_order = cast(110 as int)
union SELECT dv_schema_name = cast('dbo'			as sysname), dv_table_name = cast('dv_hub_column'				as sysname), dv_key_name = cast('hub_col_key'				as sysname), dv_load_order = cast(120 as int)
union SELECT dv_schema_name = cast('dbo'			as sysname), dv_table_name = cast('dv_link'						as sysname), dv_key_name = cast('link_key'					as sysname), dv_load_order = cast(130 as int)
union SELECT dv_schema_name = cast('dbo'			as sysname), dv_table_name = cast('dv_hub_link'					as sysname), dv_key_name = cast('hub_link_key'				as sysname), dv_load_order = cast(140 as int)
union SELECT dv_schema_name = cast('dbo'			as sysname), dv_table_name = cast('dv_satellite'				as sysname), dv_key_name = cast('satellite_key'				as sysname), dv_load_order = cast(150 as int)
union SELECT dv_schema_name = cast('dbo'			as sysname), dv_table_name = cast('dv_satellite_column'			as sysname), dv_key_name = cast('satellite_col_key'			as sysname), dv_load_order = cast(160 as int)
)
GO
PRINT N'Creating [dv_scheduler].[fn_check_manifest_for_circular_reference]...';


GO
CREATE FUNCTION [dv_scheduler].[fn_check_manifest_for_circular_reference](@run_key int)

RETURNS TABLE	
AS
RETURN

with wBaseSet as (
select mh.run_manifest_key
      ,mh.run_manifest_prior_key

from [dv_scheduler].[dv_run] r
inner join [dv_scheduler].[dv_run_manifest] m
on r.run_key = m.run_key
left join [dv_scheduler].[dv_run_manifest_hierarchy] mh
on m.run_manifest_key = mh.run_manifest_key
where 1=1
  and m.run_key = @run_key
  and coalesce(mh.run_manifest_key,mh.run_manifest_prior_key) is not null
) 
,wFindRoot AS
(
    SELECT run_manifest_key,run_manifest_prior_key, CAST(run_manifest_prior_key as nvarchar(max)) BreadCrumb, 0 Distance
    FROM wBaseSet

    UNION ALL

    SELECT c.run_manifest_key, p.run_manifest_prior_key, c.BreadCrumb + N' > ' + cast(p.run_manifest_prior_key as nvarchar(max)), c.Distance + 1
    FROM wBaseSet p
    JOIN wFindRoot c
    ON c.run_manifest_prior_key = p.run_manifest_key AND p.run_manifest_prior_key <> p.run_manifest_key AND c.run_manifest_prior_key <> c.run_manifest_key
 )
select *
FROM wFindRoot r
WHERE r.run_manifest_key = r.run_manifest_prior_key 
  AND r.run_manifest_prior_key <> 0
  AND r.Distance > 0
GO
PRINT N'Creating [dv_scheduler].[fn_get_waiting_scheduler_tasks]...';


GO

CREATE FUNCTION [dv_scheduler].[fn_get_waiting_scheduler_tasks]
(@run_key int
,@runnable varchar(10) = 'Runnable' 
)
RETURNS TABLE 
AS
RETURN 
(
-- 'Potential' tells the Function to look for tasks, for which all precedents are either Completed, Queued or Processing (and can Potentially be added to the queue for running).
-- Any other Value looks for tasks, for which all precendents are Completed (and can therefore be placed on the queue for processing immediately)
select m.source_system_name
      ,m.source_timevault
	  ,m.source_table_schema	
	  ,m.source_table_name	
	  ,m.source_procedure_schema
	  ,m.source_procedure_name
	  ,m.source_table_load_type	
	  ,m.[queue]
	  ,m.[priority]
	from [dv_scheduler].[dv_run] r
	inner join [dv_scheduler].[dv_run_manifest] m
	on m.run_key = r.run_key
	left join [dv_scheduler].[dv_run_manifest_hierarchy] h
	on m.run_manifest_key = h.run_manifest_key
	left join [dv_scheduler].[dv_run_manifest] m1
	on m1.run_manifest_key = h.[run_manifest_prior_key]
	where 1=1
	and r.run_key = @run_key
	and r.run_status = 'Started'
	and m.run_status = 'Scheduled'
	and 'Completed' = 
		case when @runnable <> 'Potential' 
	         then 
			      case when m1.run_status is null then 'Completed'
					   when m1.run_status = 'Completed' then 'Completed'
					   else 'Unknown'
					   end
			 else	
				  case when m1.run_status is null then 'Completed'
				       when m1.run_status = 'Completed' then 'Completed'
					   when m1.run_status = 'Queued'    then 'Completed'
					   when m1.run_status = 'Processing' then 'Completed'
					   else 'Unknown'
					   end
			end
			 
except
select m.source_system_name
	  ,m.source_timevault	
	  ,m.source_table_schema	
	  ,m.source_table_name	
	  ,m.source_procedure_schema
	  ,m.source_procedure_name
	  ,m.source_table_load_type	
	  ,m.[queue]
	  ,m.[priority]
	from [dv_scheduler].[dv_run] r
	inner join [dv_scheduler].[dv_run_manifest] m
	on m.run_key = r.run_key
	left join [dv_scheduler].[dv_run_manifest_hierarchy] h
	on m.run_manifest_key = h.run_manifest_key
	left join [dv_scheduler].[dv_run_manifest] m1
	on m1.run_manifest_key = h.[run_manifest_prior_key]
	where 1=1
	and r.run_key = @run_key
	and r.run_status = 'Started'
	and m.run_status = 'Scheduled'
	and not 'Completed'  =
		case when @runnable <> 'Potential' 
	         then 
			      case when m1.run_status is null then 'Completed'
					   when m1.run_status = 'Completed' then 'Completed'
					   else 'Unknown'
					   end
			 else	
				  case when m1.run_status is null then 'Completed'
				       when m1.run_status = 'Completed' then 'Completed'
					   when m1.run_status = 'Queued'    then 'Completed'
					   when m1.run_status = 'Processing' then 'Completed'
					   else 'Unknown'
					   end
				  end

)
GO
PRINT N'Creating [dbo].[vw_running_processes]...';


GO
create view dbo.vw_running_processes 
as
SELECT spid
      , CAST(((DATEDIFF(s,start_time,GetDate()))/3600) as varchar) + ' hour(s), '
      + CAST((DATEDIFF(s,start_time,GetDate())%3600)/60 as varchar) + 'min, '
      + CAST((DATEDIFF(s,start_time,GetDate())%60) as varchar) + ' sec' as running_time
	  ,ER.command
	  ,ER.blocking_session_id
	  ,SP.dbid
	  ,last_wait_type = LASTWAITTYPE
	  ,db_name = DB_NAME(SP.DBID) 
	  ,SUBSTRING(est.text, (ER.statement_start_offset/2)+1
	  ,((CASE ER.statement_end_offset
					 WHEN -1 THEN DATALENGTH(est.text)
					 ELSE ER.statement_end_offset
					 END - ER.statement_start_offset)/2) + 1) as query_text 
	  ,cpu
	  ,host_name = HOSTNAME
	  ,login_time
	  ,login_name = LOGINAME
	  ,SP.status
	  ,program_name
	  ,NT_domain
	  ,NT_username
FROM SYSPROCESSES SP
INNER JOIN sys.dm_exec_requests ER
ON sp.spid = ER.session_id
CROSS APPLY SYS.DM_EXEC_SQL_TEXT(er.sql_handle) EST
GO
PRINT N'Creating [dv_scheduler].[vw_running_processes]...';


GO
create view [dv_scheduler].[vw_running_processes] 
as
SELECT spid
      , CAST(((DATEDIFF(s,start_time,GetDate()))/3600) as varchar) + ' hour(s), '
      + CAST((DATEDIFF(s,start_time,GetDate())%3600)/60 as varchar) + 'min, '
      + CAST((DATEDIFF(s,start_time,GetDate())%60) as varchar) + ' sec' as running_time
	  ,ER.command
	  ,ER.blocking_session_id
	  ,SP.dbid
	  ,last_wait_type = LASTWAITTYPE
	  ,db_name = DB_NAME(SP.DBID) 
	  ,SUBSTRING(est.text, (ER.statement_start_offset/2)+1
	  ,((CASE ER.statement_end_offset
					 WHEN -1 THEN DATALENGTH(est.text)
					 ELSE ER.statement_end_offset
					 END - ER.statement_start_offset)/2) + 1) as query_text 
	  ,cpu
	  ,host_name = HOSTNAME
	  ,login_time
	  ,login_name = LOGINAME
	  ,SP.status
	  ,program_name
	  ,NT_domain
	  ,NT_username
FROM SYSPROCESSES SP
INNER JOIN sys.dm_exec_requests ER
ON sp.spid = ER.session_id
CROSS APPLY SYS.DM_EXEC_SQL_TEXT(er.sql_handle) EST
GO
PRINT N'Creating [dv_scheduler].[vw_queue_status]...';


GO
create view dv_scheduler.vw_queue_status
as
SELECT t1.NAME AS [Service_Name]
	,t3.NAME AS [Schema_Name]
	,t2.NAME AS [Queue_Name]
	,CASE 
		WHEN t4.STATE IS NULL
			THEN 'Not available'
		ELSE t4.STATE
		END AS [Queue_State]
	,CASE 
		WHEN t4.tasks_waiting IS NULL
			THEN '--'
		ELSE CONVERT(VARCHAR, t4.tasks_waiting)
		END AS tasks_waiting
	,CASE 
		WHEN t4.last_activated_time IS NULL
			THEN '--'
		ELSE CONVERT(VARCHAR, t4.last_activated_time)
		END AS last_activated_time
	,CASE 
		WHEN t4.last_empty_rowset_time IS NULL
			THEN '--'
		ELSE CONVERT(VARCHAR, t4.last_empty_rowset_time)
		END AS last_empty_rowset_time
	,(
		SELECT COUNT(*)
		FROM sys.transmission_queue t6
		WHERE (t6.from_service_name = t1.NAME)
		) AS [Tran_Message_Count]
FROM sys.services t1
INNER JOIN sys.service_queues t2 ON (t1.service_queue_id = t2.object_id)
INNER JOIN sys.schemas t3 ON (t2.schema_id = t3.schema_id)
LEFT JOIN sys.dm_broker_queue_monitors t4 ON (
		t2.object_id = t4.queue_id
		AND t4.database_id = DB_ID()
		)
INNER JOIN sys.databases t5 ON (t5.database_id = DB_ID())
WHERE t1.NAME NOT IN (
		'http://schemas.microsoft.com/SQL/Notifications/QueryNotificationService'
		,'http://schemas.microsoft.com/SQL/Notifications/EventNotificationService'
		,'http://schemas.microsoft.com/SQL/ServiceBroker/ServiceBroker'
		)
GO
PRINT N'Creating [dv_scheduler].[vw_manifest_status]...';


GO
CREATE view [dv_scheduler].[vw_manifest_status]
as
select
         [source_table_name]		= quotename(m.[source_system_name]) + '.' + quotename(m.[source_table_schema]) + '.' + quotename(m.[source_table_name])
		,[run_manifest_status]		= m.[run_status]
        ,m.[start_datetime]
        ,m.[completed_datetime]
        ,[task_duration]			= convert(time, dateadd(second, datediff(second, m.[start_datetime], m.[completed_datetime]), 0))
        ,m.[queue]
        ,m.[priority]
		,[load_type]				= m.[source_table_load_type]
        ,r.[run_schedule_name]
        ,r.[run_start_datetime]
        ,r.[run_end_datetime]
        ,[run_duration]				= convert(time, dateadd(second, datediff(second, r.[run_start_datetime], r.[run_end_datetime]), 0))
        ,r.[run_status]
        ,m.[session_id]
        ,r.[run_key]
from [dv_scheduler].[dv_run] r
inner join [dv_scheduler].[dv_run_manifest] m
on m.[run_key] = r.[run_key]
GO
PRINT N'Creating [dv_scheduler].[vw_dv_source_table_hierarchy_current]...';


GO
create view [dv_scheduler].[vw_dv_source_table_hierarchy_current]
as
SELECT [source_table_hierarchy_key]
      ,[source_table_key]
      ,[prior_table_key]
      ,[release_key]
      ,[version_number]
      ,[updated_by]
      ,[update_date_time]
  FROM [dv_scheduler].[dv_source_table_hierarchy]
  where isnull([is_cancelled], 0) = 0
GO
PRINT N'Creating [dv_scheduler].[vw_dv_schedule_source_table_current]...';


GO
create view [dv_scheduler].[vw_dv_schedule_source_table_current]
as
SELECT [schedule_source_table_key]
      ,[schedule_key]
      ,[source_table_key]
      ,[source_table_load_type]
      ,[priority]
      ,[queue]
      ,[release_key]
      ,[version_number]
      ,[updated_by]
      ,[updated_datetime]
  FROM [dv_scheduler].[dv_schedule_source_table]
  where isnull([is_cancelled], 0) = 0
GO
PRINT N'Creating [dv_scheduler].[vw_dv_schedule_current]...';


GO
CREATE view [dv_scheduler].[vw_dv_schedule_current] as 
SELECT [schedule_key]
      ,[schedule_name]
      ,[schedule_description]
      ,[schedule_frequency]
      ,[release_key]
      ,[version_number]
      ,[updated_by]
      ,[updated_datetime]
  FROM [dv_scheduler].[dv_schedule]
  where isnull([is_cancelled], 0) = 0
GO
PRINT N'Creating [dv_scheduler].[fn_check_schedule_for_circular_reference]...';


GO
Create FUNCTION [dv_scheduler].[fn_check_schedule_for_circular_reference](@schedule_list varchar(4000))

RETURNS TABLE	
AS
RETURN
with wSchedule_Table as (
      select s.schedule_key
	        ,st.[source_table_key]
	        ,ss.source_system_name
	        ,st.source_table_schema
			,st.source_table_name
	  from [dv_scheduler].[vw_dv_schedule_current] s
	  inner join [dv_scheduler].[vw_dv_schedule_source_table_current] sst
	  on sst.schedule_key = s.schedule_key
	  inner join [dbo].[dv_source_table] st
	  on st.[source_table_key] = sst.source_table_key
	  inner join [dbo].[dv_source_system] ss
	  on ss.[source_system_key] = st.system_key
	  where s.schedule_name in(select ltrim(rtrim(Item)) FROM [dbo].[fn_split_strings] (@schedule_list, ','))
	)
,wBaseSet as (
select sth.[source_table_key]
      ,sth.[prior_table_key]

from wSchedule_Table schtp
left join [dv_scheduler].[vw_dv_source_table_hierarchy_current] sth
    on sth.[source_table_key] = schtp.[source_table_key] 
where 1=1
  and coalesce(sth.[source_table_key],sth.[prior_table_key]) is not null
) 
,wFindRoot AS
(
    SELECT [source_table_key],[prior_table_key], CAST([source_table_key] as nvarchar(max)) BreadCrumb, 0 Distance
    FROM wBaseSet

    UNION ALL

    SELECT c.[source_table_key], p.[prior_table_key], c.BreadCrumb + N' > ' + cast(p.[prior_table_key] as nvarchar(max)), c.Distance + 1
    FROM wBaseSet p
    JOIN wFindRoot c
    ON c.[prior_table_key] = p.[source_table_key] AND p.[prior_table_key] <> p.[source_table_key] AND c.[prior_table_key] <> c.[source_table_key]
 )
select *
FROM wFindRoot r
WHERE 1=1
  and r.[source_table_key] = r.[prior_table_key] 
  AND r.[prior_table_key] <> 0
  AND r.Distance > 0
GO
PRINT N'Creating [dbo].[dv_satellite_column_delete]...';


GO
CREATE PROC [dbo].[dv_satellite_column_delete] 
    @satellite_col_key int
AS 
	SET NOCOUNT ON 
	SET XACT_ABORT ON  
	
	BEGIN TRAN

	DELETE
	FROM   [dbo].[dv_satellite_column]
	WHERE  [satellite_col_key] = @satellite_col_key

	COMMIT
GO
PRINT N'Creating [dbo].[dv_satellite_column_insert]...';


GO
SET ANSI_NULLS ON;

SET QUOTED_IDENTIFIER OFF;


GO
CREATE PROC [dbo].[dv_satellite_column_insert] 
    @satellite_key int,
    @column_key int,
	@release_number int
AS 
	SET NOCOUNT ON 
	SET XACT_ABORT ON  
	
	BEGIN TRAN
	
	declare @release_key int
	       ,@rc int
	select @release_key = [release_key] from [dv_release].[dv_release_master] where [release_number] = @release_number
	set @rc = @@rowcount
	if @rc <> 1 
		RAISERROR('Release Number %i Does Not Exist', 16, 1, @release_number)

	INSERT INTO [dbo].[dv_satellite_column] ([satellite_key], [column_key],[release_key])
	SELECT @satellite_key, @column_key, @release_key
	
	-- Begin Return Select <- do not remove
	SELECT [satellite_col_key], [satellite_key], [column_key],[release_key], [version_number], [updated_by], [updated_datetime]
	FROM   [dbo].[dv_satellite_column]
	WHERE  [satellite_col_key] = SCOPE_IDENTITY()
	-- End Return Select <- do not remove
               
	COMMIT
       RETURN SCOPE_IDENTITY()
GO
SET ANSI_NULLS, QUOTED_IDENTIFIER ON;


GO
PRINT N'Creating [dbo].[dv_satellite_column_update]...';


GO
CREATE PROC [dbo].[dv_satellite_column_update] 
    @satellite_col_key int,
    @satellite_key int,
    @column_key int
AS 
	SET NOCOUNT ON 
	SET XACT_ABORT ON  
	
	BEGIN TRAN

	UPDATE [dbo].[dv_satellite_column]
	SET    [satellite_key] = @satellite_key, [column_key] = @column_key
	WHERE  [satellite_col_key] = @satellite_col_key
	
	-- Begin Return Select <- do not remove
	SELECT [satellite_col_key], [satellite_key], [column_key], [version_number], [updated_by], [updated_datetime]
	FROM   [dbo].[dv_satellite_column]
	WHERE  [satellite_col_key] = @satellite_col_key	
	-- End Return Select <- do not remove

	COMMIT
GO
PRINT N'Creating [dbo].[dv_satellite_delete]...';


GO
SET ANSI_NULLS ON;

SET QUOTED_IDENTIFIER OFF;


GO
CREATE PROC [dbo].[dv_satellite_delete] 
    @satellite_key int
AS 
	SET NOCOUNT ON 
	SET XACT_ABORT ON  
	
	BEGIN TRAN

	DELETE
	FROM   [dbo].[dv_satellite]
	WHERE  [satellite_key] = @satellite_key

	COMMIT
GO
SET ANSI_NULLS, QUOTED_IDENTIFIER ON;


GO
PRINT N'Creating [dbo].[dv_satellite_insert]...';


GO
CREATE PROC [dbo].[dv_satellite_insert] 
    @hub_key						int,
    @link_key						int,
    @link_hub_satellite_flag		char(1),
    @satellite_name					varchar(128),
    @satellite_abbreviation			varchar(4) = NULL,
    @satellite_schema				varchar(128),
    @satellite_database				varchar(128),
	@duplicate_removal_threshold	int,
    @is_columnstore					bit,
	@is_retired                     bit,
	@release_number					int
AS 
	SET NOCOUNT ON 
	SET XACT_ABORT ON  
	
	BEGIN TRAN
	
	declare @release_key int
	       ,@rc int
	select @release_key = [release_key] from [dv_release].[dv_release_master] where [release_number] = @release_number
	set @rc = @@rowcount
	if @rc <> 1 
		RAISERROR('Release Number %i Does Not Exist', 16, 1, @release_number)

	INSERT INTO [dbo].[dv_satellite] ([hub_key], [link_key], [link_hub_satellite_flag], [satellite_name], [satellite_abbreviation], [satellite_schema], [satellite_database], [duplicate_removal_threshold] , [is_columnstore], [is_retired], [release_key])
	SELECT @hub_key, @link_key, @link_hub_satellite_flag, @satellite_name, @satellite_abbreviation, @satellite_schema, @satellite_database,  @duplicate_removal_threshold, @is_columnstore, @is_retired, @release_key
	
	-- Begin Return Select <- do not remove
	SELECT [satellite_key], [hub_key], [link_key], [link_hub_satellite_flag], [satellite_name], [satellite_abbreviation], [satellite_schema], [satellite_database], [duplicate_removal_threshold], [is_columnstore], [is_retired], [release_key], [version_number], [updated_by], [updated_datetime]
	FROM   [dbo].[dv_satellite]
	WHERE  [satellite_key] = SCOPE_IDENTITY()
	-- End Return Select <- do not remove
               
	COMMIT
       RETURN SCOPE_IDENTITY()
GO
PRINT N'Creating [dbo].[dv_satellite_update]...';


GO
CREATE PROC [dbo].[dv_satellite_update] 
    @satellite_key int,
    @hub_key int,
    @link_key int,
    @link_hub_satellite_flag char(1),
    @satellite_name varchar(128),
    @satellite_abbreviation varchar(4) = NULL,
    @satellite_schema varchar(128),
    @satellite_database varchar(128),
	@duplicate_removal_threshold	int,
    @is_columnstore bit,
	@is_retired bit
AS 
	SET NOCOUNT ON 
	SET XACT_ABORT ON  
	
	BEGIN TRAN

	UPDATE [dbo].[dv_satellite]
	SET    [hub_key] = @hub_key, [link_key] = @link_key, [link_hub_satellite_flag] = @link_hub_satellite_flag, [satellite_name] = @satellite_name, [satellite_abbreviation] = @satellite_abbreviation, [satellite_schema] = @satellite_schema, [satellite_database] = @satellite_database, [duplicate_removal_threshold] = @duplicate_removal_threshold, [is_columnstore] = @is_columnstore, [is_retired] = @is_retired
	WHERE  [satellite_key] = @satellite_key
	
	-- Begin Return Select <- do not remove
	SELECT [satellite_key], [hub_key], [link_key], [link_hub_satellite_flag], [satellite_name], [satellite_abbreviation], [satellite_schema], [satellite_database], [duplicate_removal_threshold], [is_columnstore],[is_retired]
	FROM   [dbo].[dv_satellite]
	WHERE  [satellite_key] = @satellite_key	
	-- End Return Select <- do not remove

	COMMIT
GO
PRINT N'Creating [dbo].[dv_source_system_delete]...';


GO
CREATE PROC [dbo].[dv_source_system_delete] 
    @system_key int
AS 
	SET NOCOUNT ON 
	SET XACT_ABORT ON  
	
	BEGIN TRAN

	DELETE
	FROM   [dbo].[dv_source_system]
	WHERE  [source_system_key] = @system_key

	COMMIT
GO
PRINT N'Creating [dbo].[dv_source_system_insert]...';


GO
CREATE PROC [dbo].[dv_source_system_insert] 
    @source_system_name varchar(50),
    @timevault_name varchar(50),
	@is_retired bit,
	@release_number int
AS 
	SET NOCOUNT ON 
	SET XACT_ABORT ON  
	
	BEGIN TRAN
	
	declare @release_key int
	       ,@rc int
	select @release_key = [release_key] from [dv_release].[dv_release_master] where [release_number] = @release_number
	set @rc = @@rowcount
	if @rc <> 1 
		RAISERROR('Release Number %i Does Not Exist', 16, 1, @release_number)
	
	INSERT INTO [dbo].[dv_source_system] ([source_system_name], [timevault_name], [is_retired], [release_key])
	SELECT @source_system_name, @timevault_name, @is_retired, @release_key
	
	-- Begin Return Select <- do not remove
	SELECT [source_system_key], [source_system_name], [timevault_name],[release_key]
	FROM   [dbo].[dv_source_system]
	WHERE  [source_system_key] = SCOPE_IDENTITY()
	-- End Return Select <- do not remove
               
	COMMIT
       RETURN SCOPE_IDENTITY()
GO
PRINT N'Creating [dbo].[dv_source_system_update]...';


GO
CREATE PROC [dbo].[dv_source_system_update] 
    @system_key int,
    @source_system_name varchar(50),
    @timevault_name varchar(50),
	@is_retired bit
AS 
	SET NOCOUNT ON 
	SET XACT_ABORT ON  
	
	BEGIN TRAN

	UPDATE [dbo].[dv_source_system]
	SET    [source_system_name] = @source_system_name, [timevault_name] = @timevault_name, [is_retired] = @is_retired
	WHERE  [source_system_key] = @system_key
	
	-- Begin Return Select <- do not remove
	SELECT [source_system_key], [source_system_name], [timevault_name], [is_retired]
	FROM   [dbo].[dv_source_system]
	WHERE  [source_system_key] = @system_key	
	-- End Return Select <- do not remove

	COMMIT
GO
PRINT N'Creating [dbo].[dv_source_table_delete]...';


GO
CREATE PROC [dbo].[dv_source_table_delete] 
    @table_key int
AS 
	SET NOCOUNT ON 
	SET XACT_ABORT ON  
	
	BEGIN TRAN

	DELETE
	FROM   [dbo].[dv_source_table]
	WHERE  [source_table_key] = @table_key

	COMMIT
GO
PRINT N'Creating [dbo].[dv_source_table_insert]...';


GO
CREATE PROC [dbo].[dv_source_table_insert] 
    @system_key					int,
    @source_table_schema		varchar(128),
    @source_table_name			varchar(128),
    @source_table_load_type		varchar(50),
	@source_procedure_schema	varchar(128),
	@source_procedure_name		varchar(128),
	@is_retired					bit,
	@release_number				int
AS 
	SET NOCOUNT ON 
	SET XACT_ABORT ON  
	
	BEGIN TRAN
	
	declare @release_key int
	       ,@rc int
	select @release_key = [release_key] from [dv_release].[dv_release_master] where [release_number] = @release_number
	set @rc = @@rowcount
	if @rc <> 1 
		RAISERROR('Release Number %i Does Not Exist', 16, 1, @release_number)

	INSERT INTO [dbo].[dv_source_table] ([system_key], [source_table_schema], [source_table_name], [source_table_load_type],[source_procedure_schema],[source_procedure_name], [is_retired], [release_key])
	SELECT @system_key, @source_table_schema, @source_table_name, @source_table_load_type, @source_procedure_schema, @source_procedure_name, @is_retired, @release_key 
	
	-- Begin Return Select <- do not remove
	SELECT [source_table_key], [system_key], [source_table_schema], [source_table_name], [source_table_load_type],[source_procedure_schema],[source_procedure_name],[is_retired],[release_key]
	FROM   [dbo].[dv_source_table]
	WHERE  [source_table_key] = SCOPE_IDENTITY()
	-- End Return Select <- do not remove
               
	COMMIT
       RETURN SCOPE_IDENTITY()
GO
PRINT N'Creating [dbo].[dv_source_table_update]...';


GO
CREATE PROC [dbo].[dv_source_table_update] 
    @table_key					int,
    @system_key					int,
    @source_table_schema		varchar(128),
    @source_table_name			varchar(128),
    @source_table_load_type		varchar(50),
	@source_procedure_schema	varchar(128),
	@source_procedure_name		varchar(128),
	@is_retired					bit
AS 
	SET NOCOUNT ON 
	SET XACT_ABORT ON  
	
	BEGIN TRAN

	UPDATE [dbo].[dv_source_table]
	SET    [system_key] = @system_key, [source_table_schema] = @source_table_schema, [source_table_name] = @source_table_name, [source_table_load_type] = @source_table_load_type, [source_procedure_schema] = @source_procedure_schema, [source_procedure_name] = @source_procedure_name, [is_retired] = @is_retired
	WHERE  [source_table_key] = @table_key
	
	-- Begin Return Select <- do not remove
	SELECT [source_table_key], [system_key], [source_table_schema], [source_table_name], [source_table_load_type], [source_procedure_schema],[source_procedure_name],[is_retired],[version_number], [updated_by], [update_date_time]
	FROM   [dbo].[dv_source_table]
	WHERE  [source_table_key] = @table_key	
	-- End Return Select <- do not remove

	COMMIT
GO
PRINT N'Creating [dbo].[dv_defaults_delete]...';


GO
SET ANSI_NULLS ON;

SET QUOTED_IDENTIFIER OFF;


GO
CREATE PROC [dbo].[dv_defaults_delete] 
    @default_key int
AS 
	SET NOCOUNT ON 
	SET XACT_ABORT ON  
	
	BEGIN TRAN

	DELETE
	FROM   [dbo].[dv_defaults]
	WHERE  [default_key] = @default_key

	COMMIT
GO
SET ANSI_NULLS, QUOTED_IDENTIFIER ON;


GO
PRINT N'Creating [dbo].[dv_defaults_insert]...';


GO
SET ANSI_NULLS ON;

SET QUOTED_IDENTIFIER OFF;


GO
CREATE PROC [dbo].[dv_defaults_insert] 
    @default_type varchar(50),
    @default_subtype varchar(50),
    @default_sequence int,
    @data_type varchar(50),
    @default_integer int = NULL,
    @default_varchar varchar(128) = NULL,
    @default_dateTime datetime = NULL,
	@release_number int
AS 
	SET NOCOUNT ON 
	SET XACT_ABORT ON  
	
	BEGIN TRAN
	
	declare @release_key int
	       ,@rc int
	select @release_key = [release_key] from [dv_release].[dv_release_master] where [release_number] = @release_number
	set @rc = @@rowcount
	if @rc <> 1 
		RAISERROR('Release Number %i Does Not Exist', 16, 1, @release_number)
	INSERT INTO [dbo].[dv_defaults] ([default_type], [default_subtype], [default_sequence], [data_type], [default_integer], [default_varchar], [default_dateTime],[release_key])
	SELECT @default_type, @default_subtype, @default_sequence, @data_type, @default_integer, @default_varchar, @default_dateTime, @release_key
	
	-- Begin Return Select <- do not remove
	SELECT [default_key], [default_type], [default_subtype], [default_sequence], [data_type], [default_integer], [default_varchar], [default_dateTime],[release_key], [version_number], [updated_by], [updated_datetime]
	FROM   [dbo].[dv_defaults]
	WHERE  [default_key] = SCOPE_IDENTITY()
	-- End Return Select <- do not remove
               
	COMMIT
       RETURN SCOPE_IDENTITY()
GO
SET ANSI_NULLS, QUOTED_IDENTIFIER ON;


GO
PRINT N'Creating [dbo].[dv_defaults_update]...';


GO
SET ANSI_NULLS ON;

SET QUOTED_IDENTIFIER OFF;


GO
CREATE PROC [dbo].[dv_defaults_update] 
    @default_key int,
    @default_type varchar(50),
    @default_subtype varchar(50),
    @default_sequence int,
    @data_type varchar(50),
    @default_integer int = NULL,
    @default_varchar varchar(128) = NULL,
    @default_dateTime datetime = NULL
AS 
	SET NOCOUNT ON 
	SET XACT_ABORT ON  
	
	BEGIN TRAN

	UPDATE [dbo].[dv_defaults]
	SET    [default_type] = @default_type, [default_subtype] = @default_subtype, [default_sequence] = @default_sequence, [data_type] = @data_type, [default_integer] = @default_integer, [default_varchar] = @default_varchar, [default_dateTime] = @default_dateTime
	WHERE  [default_key] = @default_key
	
	-- Begin Return Select <- do not remove
	SELECT [default_key], [default_type], [default_subtype], [default_sequence], [data_type], [default_integer], [default_varchar], [default_dateTime], [version_number], [updated_by], [updated_datetime]
	FROM   [dbo].[dv_defaults]
	WHERE  [default_key] = @default_key	
	-- End Return Select <- do not remove

	COMMIT
GO
SET ANSI_NULLS, QUOTED_IDENTIFIER ON;


GO
PRINT N'Creating [dbo].[dv_hub_column_delete]...';


GO
CREATE PROC [dbo].[dv_hub_column_delete] 
    @hub_col_key int
AS 
	SET NOCOUNT ON 
	SET XACT_ABORT ON  
	
	BEGIN TRAN

	DELETE
	FROM   [dbo].[dv_hub_column]
	WHERE  [hub_col_key] = @hub_col_key

	COMMIT
GO
PRINT N'Creating [dbo].[dv_hub_column_insert]...';


GO
SET ANSI_NULLS ON;

SET QUOTED_IDENTIFIER OFF;


GO
CREATE PROC [dbo].[dv_hub_column_insert] 
    @hub_key_column_key int,
    @column_key int,
	@release_number int
AS 
	SET NOCOUNT ON 
	SET XACT_ABORT ON  
	
	BEGIN TRAN
	
	declare @release_key int
	       ,@rc int
	select @release_key = [release_key] from [dv_release].[dv_release_master] where [release_number] = @release_number
	set @rc = @@rowcount
	if @rc <> 1 
		RAISERROR('Release Number %i Does Not Exist', 16, 1, @release_number)

	INSERT INTO [dbo].[dv_hub_column] ([hub_key_column_key], [column_key],[release_key])
	SELECT @hub_key_column_key, @column_key, @release_key
	
	-- Begin Return Select <- do not remove
	SELECT [hub_col_key], [hub_key_column_key], [column_key], [version_number], [updated_by], [updated_datetime],[release_key]
	FROM   [dbo].[dv_hub_column]
	WHERE  [hub_col_key] = SCOPE_IDENTITY()
	-- End Return Select <- do not remove
               
	COMMIT
       RETURN SCOPE_IDENTITY()
GO
SET ANSI_NULLS, QUOTED_IDENTIFIER ON;


GO
PRINT N'Creating [dbo].[dv_hub_column_update]...';


GO
CREATE PROC [dbo].[dv_hub_column_update] 
    @hub_col_key int,
    @hub_key_column_key int,
    @column_key int
AS 
	SET NOCOUNT ON 
	SET XACT_ABORT ON  
	
	BEGIN TRAN

	UPDATE [dbo].[dv_hub_column]
	SET    [hub_key_column_key] = @hub_key_column_key, [column_key] = @column_key
	WHERE  [hub_col_key] = @hub_col_key
	
	-- Begin Return Select <- do not remove
	SELECT [hub_col_key], [hub_key_column_key], [column_key], [version_number], [updated_by], [updated_datetime]
	FROM   [dbo].[dv_hub_column]
	WHERE  [hub_col_key] = @hub_col_key	
	-- End Return Select <- do not remove

	COMMIT
GO
PRINT N'Creating [dbo].[dv_hub_delete]...';


GO
SET ANSI_NULLS ON;

SET QUOTED_IDENTIFIER OFF;


GO
CREATE PROC [dbo].[dv_hub_delete] 
    @hub_key int
AS 
	SET NOCOUNT ON 
	SET XACT_ABORT ON  
	
	BEGIN TRAN

	DELETE
	FROM   [dbo].[dv_hub]
	WHERE  [hub_key] = @hub_key

	COMMIT
GO
SET ANSI_NULLS, QUOTED_IDENTIFIER ON;


GO
PRINT N'Creating [dbo].[dv_hub_insert]...';


GO
SET ANSI_NULLS ON;

SET QUOTED_IDENTIFIER OFF;


GO
CREATE PROC [dbo].[dv_hub_insert] 
    @hub_name varchar(128),
    @hub_abbreviation varchar(4) = NULL,
    @hub_schema varchar(128),
    @hub_database varchar(128),
	@is_retired bit,
	@release_number int
AS 
	SET NOCOUNT ON 
	SET XACT_ABORT ON  
	
	BEGIN TRAN
	
	declare @release_key int
	       ,@rc int
	select @release_key = [release_key] from [dv_release].[dv_release_master] where [release_number] = @release_number
	set @rc = @@rowcount
	if @rc <> 1 
		RAISERROR('Release Number %i Does Not Exist', 16, 1, @release_number)

	INSERT INTO [dbo].[dv_hub] ([hub_name], [hub_abbreviation], [hub_schema], [hub_database],[is_retired],[release_key])
	SELECT @hub_name, @hub_abbreviation, @hub_schema, @hub_database,@is_retired,@release_key 
	
	-- Begin Return Select <- do not remove
	SELECT [hub_key], [hub_name], [hub_abbreviation], [hub_schema], [hub_database], [is_retired], [release_key], [version_number], [updated_by], [updated_datetime]
	FROM   [dbo].[dv_hub]
	WHERE  [hub_key] = SCOPE_IDENTITY()
	-- End Return Select <- do not remove
               
	COMMIT
       RETURN SCOPE_IDENTITY()
GO
SET ANSI_NULLS, QUOTED_IDENTIFIER ON;


GO
PRINT N'Creating [dbo].[dv_hub_key_delete]...';


GO
SET ANSI_NULLS ON;

SET QUOTED_IDENTIFIER OFF;


GO
CREATE PROC [dbo].[dv_hub_key_delete] 
    @hub_key_column_key int
AS 
	SET NOCOUNT ON 
	SET XACT_ABORT ON  
	
	BEGIN TRAN

	DELETE
	FROM   [dbo].[dv_hub_key_column]
	WHERE  [hub_key_column_key] = @hub_key_column_key

	COMMIT
GO
SET ANSI_NULLS, QUOTED_IDENTIFIER ON;


GO
PRINT N'Creating [dbo].[dv_hub_key_insert]...';


GO
SET ANSI_NULLS ON;

SET QUOTED_IDENTIFIER OFF;


GO
CREATE PROC [dbo].[dv_hub_key_insert] 
    @hub_key int,
    @hub_key_column_name varchar(128),
    @hub_key_column_type varchar(30),
    @hub_key_column_length int = NULL,
    @hub_key_column_precision int = NULL,
    @hub_key_column_scale int = NULL,
    @hub_key_Collation_Name nvarchar(128) = NULL,
    @hub_key_ordinal_position int,
	@release_number int
AS 
	SET NOCOUNT ON 
	SET XACT_ABORT ON  
	
	BEGIN TRAN
	
	declare @release_key int
	       ,@rc int
	select @release_key = [release_key] from [dv_release].[dv_release_master] where [release_number] = @release_number
	set @rc = @@rowcount
	if @rc <> 1 
		RAISERROR('Release Number %i Does Not Exist', 16, 1, @release_number)

	INSERT INTO [dbo].[dv_hub_key_column] ([hub_key], [hub_key_column_name], [hub_key_column_type], [hub_key_column_length], [hub_key_column_precision], [hub_key_column_scale], [hub_key_Collation_Name], [hub_key_ordinal_position],[release_key])
	SELECT @hub_key, @hub_key_column_name, @hub_key_column_type, @hub_key_column_length, @hub_key_column_precision, @hub_key_column_scale, @hub_key_Collation_Name, @hub_key_ordinal_position, @release_key
	
	-- Begin Return Select <- do not remove
	SELECT [hub_key_column_key], [hub_key], [hub_key_column_name], [hub_key_column_type], [hub_key_column_length], [hub_key_column_precision], [hub_key_column_scale], [hub_key_Collation_Name], [hub_key_ordinal_position],[release_key], [version_number], [updated_by], [updated_datetime]
	FROM   [dbo].[dv_hub_key_column]
	WHERE  [hub_key_column_key] = SCOPE_IDENTITY()
	-- End Return Select <- do not remove
               
	COMMIT
       RETURN SCOPE_IDENTITY()
GO
SET ANSI_NULLS, QUOTED_IDENTIFIER ON;


GO
PRINT N'Creating [dbo].[dv_hub_key_update]...';


GO
SET ANSI_NULLS ON;

SET QUOTED_IDENTIFIER OFF;


GO
CREATE PROC [dbo].[dv_hub_key_update] 
    @hub_key_column_key int,
    @hub_key int,
    @hub_key_column_name varchar(128),
    @hub_key_column_type varchar(30),
    @hub_key_column_length int = NULL,
    @hub_key_column_precision int = NULL,
    @hub_key_column_scale int = NULL,
    @hub_key_Collation_Name nvarchar(128) = NULL,
    @hub_key_ordinal_position int
AS 
	SET NOCOUNT ON 
	SET XACT_ABORT ON  
	
	BEGIN TRAN

	UPDATE [dbo].[dv_hub_key_column]
	SET    [hub_key] = @hub_key, [hub_key_column_name] = @hub_key_column_name, [hub_key_column_type] = @hub_key_column_type, [hub_key_column_length] = @hub_key_column_length, [hub_key_column_precision] = @hub_key_column_precision, [hub_key_column_scale] = @hub_key_column_scale, [hub_key_Collation_Name] = @hub_key_Collation_Name, [hub_key_ordinal_position] = @hub_key_ordinal_position 
	WHERE  [hub_key_column_key] = @hub_key_column_key
	
	-- Begin Return Select <- do not remove
	SELECT [hub_key_column_key], [hub_key], [hub_key_column_name], [hub_key_column_type], [hub_key_column_length], [hub_key_column_precision], [hub_key_column_scale], [hub_key_Collation_Name], [hub_key_ordinal_position], [version_number], [updated_by], [updated_datetime]
	FROM   [dbo].[dv_hub_key_column]
	WHERE  [hub_key_column_key] = @hub_key_column_key	
	-- End Return Select <- do not remove

	COMMIT
GO
SET ANSI_NULLS, QUOTED_IDENTIFIER ON;


GO
PRINT N'Creating [dbo].[dv_hub_link_delete]...';


GO
SET ANSI_NULLS ON;

SET QUOTED_IDENTIFIER OFF;


GO
CREATE PROC [dbo].[dv_hub_link_delete] 
    @hub_key int
   ,@link_key int
AS 
	SET NOCOUNT ON 
	SET XACT_ABORT ON  
	
	BEGIN TRAN

	DELETE
	FROM   [dbo].[dv_hub_link]
	WHERE  [hub_key]   = @hub_key
	  AND  [link_key]  = @link_key

	COMMIT
GO
SET ANSI_NULLS, QUOTED_IDENTIFIER ON;


GO
PRINT N'Creating [dbo].[dv_hub_link_insert]...';


GO
SET ANSI_NULLS ON;

SET QUOTED_IDENTIFIER OFF;


GO
CREATE PROC [dbo].[dv_hub_link_insert] 
    @link_key int,
    @hub_key int,
	@release_number int
AS 
	SET NOCOUNT ON 
	SET XACT_ABORT ON  
	
	BEGIN TRAN
	
	declare @release_key int
	       ,@rc int
	select @release_key = [release_key] from [dv_release].[dv_release_master] where [release_number] = @release_number
	set @rc = @@rowcount
	if @rc <> 1 
		RAISERROR('Release Number %i Does Not Exist', 16, 1, @release_number)

	INSERT INTO [dbo].[dv_hub_link] ([link_key], [hub_key],[release_key])
	SELECT @link_key, @hub_key, @release_key
	
	-- Begin Return Select <- do not remove
	SELECT [hub_link_key], [link_key], [hub_key],[release_key], [version_number], [updated_by], [updated_datetime]
	FROM   [dbo].[dv_hub_link]
	WHERE  [hub_link_key] = SCOPE_IDENTITY()
	-- End Return Select <- do not remove
               
	COMMIT
       RETURN SCOPE_IDENTITY()
GO
SET ANSI_NULLS, QUOTED_IDENTIFIER ON;


GO
PRINT N'Creating [dbo].[dv_hub_update]...';


GO
SET ANSI_NULLS ON;

SET QUOTED_IDENTIFIER OFF;


GO
CREATE PROC [dbo].[dv_hub_update] 
    @hub_key int,
    @hub_name varchar(128),
    @hub_abbreviation varchar(4) = NULL,
    @hub_schema varchar(128),
    @hub_database varchar(128),
	@is_retired bit
AS 
	SET NOCOUNT ON 
	SET XACT_ABORT ON  
	
	BEGIN TRAN

	UPDATE [dbo].[dv_hub]
	SET    [hub_name] = @hub_name, [hub_abbreviation] = @hub_abbreviation, [hub_schema] = @hub_schema, [hub_database] = @hub_database, [is_retired] = @is_retired
	WHERE  [hub_key] = @hub_key
	
	-- Begin Return Select <- do not remove
	SELECT [hub_key], [hub_name], [hub_abbreviation], [hub_schema], [hub_database], [is_retired]
	FROM   [dbo].[dv_hub]
	WHERE  [hub_key] = @hub_key	
	-- End Return Select <- do not remove

	COMMIT
GO
SET ANSI_NULLS, QUOTED_IDENTIFIER ON;


GO
PRINT N'Creating [dbo].[dv_link_delete]...';


GO
SET ANSI_NULLS ON;

SET QUOTED_IDENTIFIER OFF;


GO
CREATE PROC [dbo].[dv_link_delete] 
    @link_key int
AS 
	SET NOCOUNT ON 
	SET XACT_ABORT ON  
	
	BEGIN TRAN

	DELETE
	FROM   [dbo].[dv_link]
	WHERE  [link_key] = @link_key

	COMMIT
GO
SET ANSI_NULLS, QUOTED_IDENTIFIER ON;


GO
PRINT N'Creating [dbo].[dv_link_insert]...';


GO
SET ANSI_NULLS ON;

SET QUOTED_IDENTIFIER OFF;


GO
CREATE PROC [dbo].[dv_link_insert] 
    @link_name varchar(128),
    @link_abbreviation varchar(4) = NULL,
    @link_schema varchar(128),
    @link_database varchar(128),
	@is_retired bit,
	@release_number int
AS 
	SET NOCOUNT ON 
	SET XACT_ABORT ON  
	
	BEGIN TRAN
	
	declare @release_key int
	       ,@rc int
	select @release_key = [release_key] from [dv_release].[dv_release_master] where [release_number] = @release_number
	set @rc = @@rowcount
	if @rc <> 1 
		RAISERROR('Release Number %i Does Not Exist', 16, 1, @release_number)

	INSERT INTO [dbo].[dv_link] ([link_name], [link_abbreviation], [link_schema], [link_database], [is_retired], [release_key])
	SELECT @link_name, @link_abbreviation, @link_schema, @link_database, @is_retired, @release_key
	
	-- Begin Return Select <- do not remove
	SELECT [link_key], [link_name], [link_abbreviation], [link_schema], [link_database], [is_retired], [release_key], [version_number], [updated_by], [updated_datetime]
	FROM   [dbo].[dv_link]
	WHERE  [link_key] = SCOPE_IDENTITY()
	-- End Return Select <- do not remove
               
	COMMIT
       RETURN SCOPE_IDENTITY()
GO
SET ANSI_NULLS, QUOTED_IDENTIFIER ON;


GO
PRINT N'Creating [dbo].[dv_link_update]...';


GO
SET ANSI_NULLS ON;

SET QUOTED_IDENTIFIER OFF;


GO
CREATE PROC [dbo].[dv_link_update] 
    @link_key int,
    @link_name varchar(128),
    @link_abbreviation varchar(4) = NULL,
    @link_schema varchar(128),
    @link_database varchar(128),
	@is_retired bit
AS 
	SET NOCOUNT ON 
	SET XACT_ABORT ON  
	
	BEGIN TRAN

	UPDATE [dbo].[dv_link]
	SET    [link_name] = @link_name, [link_abbreviation] = @link_abbreviation, [link_schema] = @link_schema, [link_database] = @link_database, [is_retired] = @is_retired
	WHERE  [link_key] = @link_key
	
	-- Begin Return Select <- do not remove
	SELECT [link_key], [link_name], [link_abbreviation], [link_schema], [link_database], [is_retired], [version_number], [updated_by], [updated_datetime]
	FROM   [dbo].[dv_link]
	WHERE  [link_key] = @link_key	
	-- End Return Select <- do not remove

	COMMIT
GO
SET ANSI_NULLS, QUOTED_IDENTIFIER ON;


GO
PRINT N'Creating [dbo].[dv_column_delete]...';


GO
CREATE PROC [dbo].[dv_column_delete] 
    @column_key int
AS 
	SET NOCOUNT ON 
	SET XACT_ABORT ON  
	
	BEGIN TRAN

	DELETE
	FROM   [dbo].[dv_column]
	WHERE  [column_key] = @column_key

	COMMIT
GO
PRINT N'Creating [dbo].[dv_column_insert]...';


GO
SET ANSI_NULLS ON;

SET QUOTED_IDENTIFIER OFF;


GO
CREATE PROC [dbo].[dv_column_insert] 
    @table_key int,
	@release_number int,
    @column_name varchar(128),
    @column_type varchar(30),
    @column_length int = NULL,
    @column_precision int = NULL,
    @column_scale int = NULL,
    @Collation_Name nvarchar(128) = NULL,
    @bk_ordinal_position int,
    @source_ordinal_position int,
    @satellite_ordinal_position int,
    @is_source_date bit,
    @discard_flag bit,
    @is_retired bit
AS 
	SET NOCOUNT ON 
	SET XACT_ABORT ON  
	
	BEGIN TRAN
		declare @release_key int
	       ,@rc int
	select @release_key = [release_key] from [dv_release].[dv_release_master] where [release_number] = @release_number
	set @rc = @@rowcount
	if @rc <> 1 
		RAISERROR('Release Number %i Does Not Exist', 16, 1, @release_number)
	INSERT INTO [dbo].[dv_column] ([table_key], [column_name], [column_type], [column_length], [column_precision], [column_scale], [Collation_Name], [bk_ordinal_position], [source_ordinal_position], [satellite_ordinal_position], [is_source_date], [discard_flag], [is_retired],[release_key])
	SELECT @table_key, @column_name, @column_type, @column_length, @column_precision, @column_scale, @Collation_Name, @bk_ordinal_position, @source_ordinal_position, @satellite_ordinal_position, @is_source_date, @discard_flag, @is_retired, @release_key
	
	-- Begin Return Select <- do not remove
	SELECT [column_key], [table_key], [column_name], [column_type], [column_length], [column_precision], [column_scale], [Collation_Name], [bk_ordinal_position], [source_ordinal_position], [satellite_ordinal_position], [is_source_date], [discard_flag], [is_retired],[release_key],[version_number], [updated_by], [update_date_time]
	FROM   [dbo].[dv_column]
	WHERE  [column_key] = SCOPE_IDENTITY()
	-- End Return Select <- do not remove
               
	COMMIT
       RETURN SCOPE_IDENTITY()
GO
SET ANSI_NULLS, QUOTED_IDENTIFIER ON;


GO
PRINT N'Creating [dbo].[dv_column_update]...';


GO
CREATE PROC [dbo].[dv_column_update] 
    @column_key int,
    @table_key int,
    @column_name varchar(128),
    @column_type varchar(30),
    @column_length int = NULL,
    @column_precision int = NULL,
    @column_scale int = NULL,
    @Collation_Name nvarchar(128) = NULL,
    @bk_ordinal_position int,
    @source_ordinal_position int,
    @satellite_ordinal_position int,
    @is_source_date bit,
    @discard_flag bit,
    @is_retired bit
AS 
	SET NOCOUNT ON 
	SET XACT_ABORT ON  
	
	BEGIN TRAN

	UPDATE [dbo].[dv_column]
	SET    [table_key] = @table_key, [column_name] = @column_name, [column_type] = @column_type, [column_length] = @column_length, [column_precision] = @column_precision, [column_scale] = @column_scale, [Collation_Name] = @Collation_Name, [bk_ordinal_position] = @bk_ordinal_position, [source_ordinal_position] = @source_ordinal_position, [satellite_ordinal_position] = @satellite_ordinal_position, [is_source_date] = @is_source_date, [discard_flag] = @discard_flag, [is_retired] = @is_retired
	WHERE  [column_key] = @column_key
	
	-- Begin Return Select <- do not remove
	SELECT [column_key], [table_key], [column_name], [column_type], [column_length], [column_precision], [column_scale], [Collation_Name], [bk_ordinal_position], [source_ordinal_position], [satellite_ordinal_position], [is_source_date], [discard_flag], [is_retired], [version_number], [updated_by], [update_date_time]
	FROM   [dbo].[dv_column]
	WHERE  [column_key] = @column_key	
	-- End Return Select <- do not remove

	COMMIT
GO
PRINT N'Creating [dbo].[dv_default_column_delete]...';


GO
SET ANSI_NULLS ON;

SET QUOTED_IDENTIFIER OFF;


GO
CREATE PROC [dbo].[dv_default_column_delete] 
    @default_column_key int
AS 
	SET NOCOUNT ON 
	SET XACT_ABORT ON  
	
	BEGIN TRAN

	DELETE
	FROM   [dbo].[dv_default_column]
	WHERE  [default_column_key] = @default_column_key

	COMMIT
GO
SET ANSI_NULLS, QUOTED_IDENTIFIER ON;


GO
PRINT N'Creating [dbo].[dv_default_column_insert]...';


GO
SET ANSI_NULLS ON;

SET QUOTED_IDENTIFIER OFF;


GO
CREATE PROC [dbo].[dv_default_column_insert] 
    @object_type varchar(30),
	@release_number int,
    @object_column_type varchar(30),
    @ordinal_position int,
    @column_prefix varchar(30) = NULL,
    @column_name varchar(256),
    @column_suffix varchar(30) = NULL,
    @column_type varchar(30),
    @column_length int = NULL,
    @column_precision int = NULL,
    @column_scale int = NULL,
    @collation_Name nvarchar(128) = NULL,
    @is_nullable bit,
    @is_pk bit,
    @discard_flag bit
AS 
	SET NOCOUNT ON 
	SET XACT_ABORT ON  
	
	BEGIN TRAN
	
	declare @release_key int
	       ,@rc int
	select @release_key = [release_key] from [dv_release].[dv_release_master] where [release_number] = @release_number
	set @rc = @@rowcount
	if @rc <> 1 
		RAISERROR('Release Number %i Does Not Exist', 16, 1, @release_number)
	INSERT INTO [dbo].[dv_default_column] ([object_type], [object_column_type], [ordinal_position], [column_prefix], [column_name], [column_suffix], [column_type], [column_length], [column_precision], [column_scale], [collation_Name], [is_nullable], [is_pk], [discard_flag],[release_key])
	SELECT @object_type, @object_column_type, @ordinal_position, @column_prefix, @column_name, @column_suffix, @column_type, @column_length, @column_precision, @column_scale, @collation_Name, @is_nullable, @is_pk, @discard_flag, @release_key
	
	-- Begin Return Select <- do not remove
	SELECT [default_column_key], [object_type], [object_column_type], [ordinal_position], [column_prefix], [column_name], [column_suffix], [column_type], [column_length], [column_precision], [column_scale], [collation_Name], [is_nullable], [is_pk], [discard_flag], [release_key], [version_number], [updated_by], [update_date_time]
	FROM   [dbo].[dv_default_column]
	WHERE  [default_column_key] = SCOPE_IDENTITY()
	-- End Return Select <- do not remove
               
	COMMIT
       RETURN SCOPE_IDENTITY()
GO
SET ANSI_NULLS, QUOTED_IDENTIFIER ON;


GO
PRINT N'Creating [dbo].[dv_default_column_update]...';


GO
SET ANSI_NULLS ON;

SET QUOTED_IDENTIFIER OFF;


GO
CREATE PROC [dbo].[dv_default_column_update] 
    @default_column_key int,
    @object_type varchar(30),
    @object_column_type varchar(30),
    @ordinal_position int,
    @column_prefix varchar(30) = NULL,
    @column_name varchar(256),
    @column_suffix varchar(30) = NULL,
    @column_type varchar(30),
    @column_length int = NULL,
    @column_precision int = NULL,
    @column_scale int = NULL,
    @collation_Name nvarchar(128) = NULL,
    @is_nullable bit,
    @is_pk bit,
    @discard_flag bit
AS 
	SET NOCOUNT ON 
	SET XACT_ABORT ON  
	
	BEGIN TRAN

	UPDATE [dbo].[dv_default_column]
	SET    [object_type] = @object_type, [object_column_type] = @object_column_type, [ordinal_position] = @ordinal_position, [column_prefix] = @column_prefix, [column_name] = @column_name, [column_suffix] = @column_suffix, [column_type] = @column_type, [column_length] = @column_length, [column_precision] = @column_precision, [column_scale] = @column_scale, [collation_Name] = @collation_Name, [is_nullable] = @is_nullable, [is_pk] = @is_pk, [discard_flag] = @discard_flag
	WHERE  [default_column_key] = @default_column_key
	
	-- Begin Return Select <- do not remove
	SELECT [default_column_key], [object_type], [object_column_type], [ordinal_position], [column_prefix], [column_name], [column_suffix], [column_type], [column_length], [column_precision], [column_scale], [collation_Name], [is_nullable], [is_pk], [discard_flag], [version_number], [updated_by], [update_date_time]
	FROM   [dbo].[dv_default_column]
	WHERE  [default_column_key] = @default_column_key	
	-- End Return Select <- do not remove

	COMMIT
GO
SET ANSI_NULLS, QUOTED_IDENTIFIER ON;


GO
PRINT N'Creating [dv_log].[dv_log_progress]...';


GO
CREATE PROCEDURE [dv_log].[dv_log_progress]
(
  @vault_object_type             varchar(50)    = NULL
, @vault_object_name             varchar(128)   = NULL
, @vault_object_schema           varchar(128)   = NULL
, @vault_object_database         varchar(128)   = NULL
, @vault_source_name             varchar(128)   = NULL
, @vault_source_schema           varchar(128)   = NULL
, @vault_source_system           varchar(128)   = NULL
, @vault_execution_id            int            = NULL
, @vault_load_high_water		 datetimeoffset(7)  = NULL
--, @vault_load_finish_datetime	 datetimeoffset(7)  = NULL
--, @vault_load_duration			 int			= NULL
, @vault_rows_inserted			 int			= NULL
, @vault_rows_updated			 int			= NULL
, @vault_rows_deleted			 int			= NULL
)
AS
BEGIN
SET NOCOUNT ON

DECLARE @source_table_key	int
	   ,@object_key			int

set @source_table_key = 0

if @vault_object_type = 'sat'
begin
	select @source_table_key = st.[source_table_key]
	from [dbo].[dv_source_system] ss
	inner join [dbo].[dv_source_table] st
	on ss.[source_system_key] = st.system_key
	where 1=1
	and ss.source_system_name	= @vault_source_system
	and st.source_table_name	= @vault_source_name
	and st.source_table_schema	= @vault_source_schema
end

if @vault_object_type = 'sat'
begin
	select @object_key = satellite_key
	from [dbo].[dv_satellite]
	where 1=1
	and [satellite_database]	= @vault_object_database
	and [satellite_schema]		= @vault_object_schema
	and [satellite_name]		= @vault_object_name
end
--if @vault_object_type = 'pit'
--begin
--   select @object_key = pit_key
--   from [dbo].[dv_pit]
--   where 1=1
--    and [pit_database]		    = @vault_object_database
--	and [pit_schema]			= @vault_object_schema
--	and [pit_name]				= @vault_object_name
--end

INSERT INTO [dv_log].[dv_load_state_history]
SELECT [load_state_key],left([Action], 1),[source_table_key],[object_key],[object_type],[execution_key],[load_high_water]--,[load_finish_datetime],[load_duration]
          ,[rows_inserted],[rows_updated],[rows_deleted],[updated_by],[update_date_time]
FROM(
MERGE INTO [dv_log].[dv_load_state] AS tgt                              
USING (VALUES 
		(@source_table_key 
		,@object_key 
		,@vault_object_type 
		,@vault_execution_id 
		,@vault_load_high_water 
		--,@vault_load_finish_datetime 
		--,@vault_load_duration 
		,@vault_rows_inserted 
		,@vault_rows_updated 
		,@vault_rows_deleted)) 
AS src	([source_table_key]
		,[object_key]
		,[object_type]
		,[execution_key]
		,[load_high_water]
		--,[load_finish_datetime]
		--,[load_duration]
		,[rows_inserted]
		,[rows_updated]
		,[rows_deleted])
ON 
    src.[source_table_key]		= tgt.[source_table_key]
and src.[object_key]			= tgt.[object_key]
and src.[object_type]			= tgt.[object_type]
and src.[execution_key]			= tgt.[execution_key]
                             
WHEN MATCHED THEN UPDATE
SET 
	 tgt.[load_high_water]		= src.[load_high_water]
	--,tgt.[load_finish_datetime]	= src.[load_finish_datetime]
	--,tgt.[load_duration]		= src.[load_duration]
	,tgt.[rows_inserted]		= src.[rows_inserted]
	,tgt.[rows_updated]			= src.[rows_updated]
	,tgt.[rows_deleted]			= src.[rows_deleted]
	,tgt.[update_date_time]     = sysdatetimeoffset()
                              
WHEN NOT MATCHED THEN INSERT
	([source_table_key]
	,[object_key]
	,[object_type]
	,[execution_key]
	,[load_high_water]
	--,[load_finish_datetime]
	--,[load_duration]
	,[rows_inserted]
	,[rows_updated]
	,[rows_deleted])
VALUES (
	 src.[source_table_key]
	,src.[object_key]
	,src.[object_type]
	,src.[execution_key]
	,src.[load_high_water]
	--,src.[load_finish_datetime]
	--,src.[load_duration]
	,src.[rows_inserted]
	,src.[rows_updated]
	,src.[rows_deleted])
output $action, inserted.*
) 
as changes 
([Action], [load_state_key],[source_table_key],[object_key],[object_type],[execution_key],[load_high_water]--,[load_finish_datetime],[load_duration]
          ,[rows_inserted],[rows_updated],[rows_deleted],[updated_by],[update_date_time])
;
END
GO
PRINT N'Creating [dv_release].[dv_release_master_update]...';


GO
CREATE PROC [dv_release].[dv_release_master_update] 
	@release_number int,
    @release_description varchar(256) = NULL,
    @reference_number varchar(50) = NULL,
    @reference_source varchar(50) = NULL
  
AS 
	SET NOCOUNT ON 
	SET XACT_ABORT ON  
	
	BEGIN TRAN

	UPDATE [dv_release].[dv_release_master]
	SET    [release_description] = @release_description, [reference_number] = @reference_number, [reference_source] = @reference_source
	WHERE  [release_number] = @release_number
	-- Begin Return Select <- do not remove
	SELECT [release_key], [release_number], [release_description], [reference_number], [reference_source]
	FROM   [dv_release].[dv_release_master]
	WHERE  [release_number] = @release_number	
	-- End Return Select <- do not remove

	COMMIT
GO
PRINT N'Creating [dv_release].[dv_release_master_delete]...';


GO
CREATE PROC [dv_release].[dv_release_master_delete] 
    @release_key int
AS 
	SET NOCOUNT ON 
	SET XACT_ABORT ON  
	
	BEGIN TRAN

	DELETE
	FROM   [dv_release].[dv_release_master]
	WHERE  [release_key] = @release_key

	COMMIT
GO
PRINT N'Creating [dv_release].[dv_release_master_insert]...';


GO
CREATE PROC [dv_release].[dv_release_master_insert] 
    @release_number int,
    @release_description varchar(256) = NULL,
    @reference_number varchar(50) = NULL,
    @reference_source varchar(50) = NULL
AS 
	SET NOCOUNT ON 
	SET XACT_ABORT ON  
	
	BEGIN TRAN
	
	INSERT INTO [dv_release].[dv_release_master] ([release_number], [release_description], [reference_number], [reference_source])
	SELECT @release_number, @release_description, @reference_number, @reference_source
	-- Begin Return Select <- do not remove
	SELECT [release_key], [release_number], [release_description], [reference_number], [reference_source]
	FROM   [dv_release].[dv_release_master]
	WHERE  [release_key] = SCOPE_IDENTITY()
	-- End Return Select <- do not remove
               
	COMMIT
       RETURN SCOPE_IDENTITY()
GO
PRINT N'Creating [dv_scheduler].[dv_schedule_insert]...';


GO
CREATE PROC [dv_scheduler].[dv_schedule_insert] 
     @schedule_name				varchar(128)
    ,@schedule_description		varchar(256)
    ,@schedule_frequency		varchar(128)
	,@release_number int
AS 
	SET NOCOUNT ON 
	SET XACT_ABORT ON  
	
	BEGIN TRAN
	
	declare @release_key				int
	       ,@schedule_name_no_spaces	varchar(128)
	       ,@rc							int
	select @release_key = [release_key] from [dv_release].[dv_release_master] where [release_number] = @release_number
	set @rc = @@rowcount
	if @rc <> 1 
		RAISERROR('Release Number %i Does Not Exist', 16, 1, @release_number)
    else
	begin
	    select @schedule_name_no_spaces = replace(@schedule_name, ' ','')
		INSERT INTO [dv_scheduler].[dv_schedule]
			   ([schedule_name],[schedule_description],[schedule_frequency],[release_key])
		SELECT @schedule_name, @schedule_description, @schedule_frequency, @release_key
	end
	-- Begin Return Select <- do not remove
		SELECT [schedule_key]
			  ,[schedule_name]
			  ,[schedule_description]
			  ,[schedule_frequency]
			  ,[release_key]
			  ,[version_number]
			  ,[updated_by]
			  ,[updated_datetime]
		  FROM [dv_scheduler].[dv_schedule]
			WHERE  [schedule_key] = SCOPE_IDENTITY()
	-- End Return Select <- do not remove
               
	COMMIT
       RETURN SCOPE_IDENTITY()
GO
PRINT N'Creating [dv_scheduler].[dv_schedule_delete]...';


GO
CREATE PROC [dv_scheduler].[dv_schedule_delete] 
    @schedule_key int,
	@force		  bit = 0
AS 
	SET NOCOUNT ON 
	SET XACT_ABORT ON  
	declare @rn1 int
	       ,@rn2 int
	BEGIN TRAN
	select @rn1 = count(*)
	from [dv_scheduler].[dv_schedule]
	where  [schedule_key] = @schedule_key
	if @rn1 > 0
	    begin
		select @rn2 = count(*)
		from [dv_scheduler].[dv_schedule]
		where  [schedule_key] = @schedule_key
		  and (isnull(@force, 0) | isnull([is_cancelled], 0) = 1)
		if @rn2 <> @rn1
			raiserror('Only Cancelled Schedules may be deleted, unless the Force Parameter has been set', 16, 1)
		else
			delete
			from [dv_scheduler].[dv_schedule]
			where  [schedule_key] = @schedule_key
			  and (isnull(@force, 0) | isnull([is_cancelled], 0) = 1)
		end

 	COMMIT
GO
PRINT N'Creating [dv_scheduler].[dv_run_insert]...';


GO
CREATE PROC [dv_scheduler].[dv_run_insert] 
     @schedule_list				varchar(4000)
AS 
	SET NOCOUNT ON 
	SET XACT_ABORT ON  
	
	BEGIN TRAN

	declare @schedule_list_var	varchar(4000)
	       ,@rc					int
	declare @tbl_schedule_list table(schedule_name varchar(128))

	select @schedule_list_var = replace(@schedule_list, ' ','')	
	insert @tbl_schedule_list select item from [dbo].[fn_split_strings] (@schedule_list_var, ',')	
	select @rc = count(*) 
		from @tbl_schedule_list
		where schedule_name not in (select schedule_name from [dv_scheduler].[vw_dv_schedule_current])
	if @rc > 0 
		RAISERROR('Invalid Schedule Name Provided:  %s', 16, 1, @schedule_list)
	else 
	    begin
		INSERT INTO [dv_scheduler].[dv_run]
			   ([run_schedule_name]) values(@schedule_list_var)	
		end
		-- Begin Return Select <- do not remove
		SELECT [run_key]
			  ,[run_status]
			  ,[run_schedule_name]
			  ,[run_start_datetime]
			  ,[run_end_datetime]
			  ,[updated_datetime]
		  FROM [dv_scheduler].[dv_run]
		WHERE  [run_key] = SCOPE_IDENTITY()
	-- End Return Select <- do not remove
               
	COMMIT
       RETURN SCOPE_IDENTITY()
GO
PRINT N'Creating [dv_scheduler].[dv_source_table_hierarchy_update]...';


GO
CREATE PROC [dv_scheduler].[dv_source_table_hierarchy_update] 
    @source_table_hierarchy_key int,
    @source_table_key int,
    @prior_table_key int,
	@is_cancelled bit
AS 
	SET NOCOUNT ON 
	SET XACT_ABORT ON  
	
	BEGIN TRAN

	UPDATE [dv_scheduler].[dv_source_table_hierarchy]
	SET    [source_table_key] = @source_table_key, [prior_table_key] = @prior_table_key, is_cancelled = @is_cancelled
	WHERE  [source_table_hierarchy_key] = @source_table_hierarchy_key
	
	-- Begin Return Select <- do not remove
	SELECT [source_table_hierarchy_key], [source_table_key], [prior_table_key], [is_cancelled]
	FROM   [dv_scheduler].[dv_source_table_hierarchy]
	WHERE  [source_table_hierarchy_key] = @source_table_hierarchy_key	
	-- End Return Select <- do not remove

	COMMIT
GO
PRINT N'Creating [dv_scheduler].[dv_source_table_hierarchy_insert]...';


GO
CREATE PROC [dv_scheduler].[dv_source_table_hierarchy_insert] 
	 @source_system_name		varchar(50)
	,@source_table_schema		varchar(128)
    ,@source_table_name			varchar(128)
	,@prior_source_system_name	varchar(50)
	,@prior_source_table_schema	varchar(128)
	,@prior_source_table_name	varchar(128)
	,@release_number			int
AS
BEGIN 
	SET NOCOUNT ON 
	SET XACT_ABORT ON  
	
	BEGIN TRAN
	
	declare @release_key						int
	       ,@source_table_key					int
		   ,@prior_source_table_key				int
		   ,@source_table_qualified_name		varchar(512)
		   ,@prior_source_table_qualified_name	varchar(512)
	       ,@rc									int
	select @release_key = [release_key] from [dv_release].[dv_release_master] where [release_number] = @release_number
	set @rc = @@rowcount
	if @rc <> 1 
		RAISERROR('Release Number %i Does Not Exist', 16, 1, @release_number)

	select @source_table_qualified_name = quotename(@source_system_name) + '.' + quotename(@source_table_schema) + '.' + quotename(@source_table_name)
	select @source_table_key = [source_table_key] 
	from [dbo].[dv_source_system] s
	inner join [dbo].[dv_source_table] st
	on s.[source_system_key] = st.[system_key]
	where s.[source_system_name]	= @source_system_name
	  and st.[source_table_schema]	= @source_table_schema
	  and [source_table_name]		= @source_table_name
	set @rc = @@rowcount
	if @rc <> 1 
		RAISERROR('Source Table %s Does Not Exist', 16, 1, @source_table_qualified_name)

	select @prior_source_table_qualified_name = quotename(@prior_source_system_name) + '.' + quotename(@prior_source_table_schema) + '.' + quotename(@prior_source_table_name)
	select @prior_source_table_key = [source_table_key] 
	from [dbo].[dv_source_system] s
	inner join [dbo].[dv_source_table] st
	on s.[source_system_key] = st.[system_key]
	where s.[source_system_name]	= @prior_source_system_name
	  and st.[source_table_schema]	= @prior_source_table_schema
	  and [source_table_name]		= @prior_source_table_name
	set @rc = @@rowcount
	if @rc <> 1 
		RAISERROR('Prior Source Table %s Does Not Exist', 16, 1, @prior_source_table_qualified_name)

	INSERT INTO [dv_scheduler].[dv_source_table_hierarchy]([source_table_key] ,[prior_table_key],[release_key])
     VALUES (@source_table_key ,@prior_source_table_key,@release_key)

	-- Begin Return Select <- do not remove

	SELECT [source_table_hierarchy_key]
		  ,[source_table_key]
		  ,[prior_table_key]
		  ,[release_key]
		  ,[version_number]
		  ,[updated_by]
		  ,[update_date_time]
	  FROM [dv_scheduler].[dv_source_table_hierarchy]
 	WHERE  [source_table_hierarchy_key] = SCOPE_IDENTITY()
	-- End Return Select <- do not remove
               
	COMMIT
       RETURN SCOPE_IDENTITY()
END
GO
PRINT N'Creating [dv_scheduler].[dv_source_table_hiearchy_delete]...';


GO
CREATE PROC [dv_scheduler].[dv_source_table_hiearchy_delete] 
    @source_table_hiearchy_key int
   ,@force					   int = 0
AS 
	SET NOCOUNT ON 
	SET XACT_ABORT ON  
	declare @rn1 int
	       ,@rn2 int
	BEGIN TRAN
	select @rn1 = count(*)
	from [dv_scheduler].[dv_source_table_hierarchy]
	where  [source_table_hierarchy_key] = @source_table_hiearchy_key
	if @rn1 > 0
	    begin
		select @rn2 = count(*)
		from [dv_scheduler].[dv_source_table_hierarchy]
		where  [source_table_hierarchy_key] = @source_table_hiearchy_key
		  and (isnull(@force, 0) | isnull([is_cancelled], 0) = 1)
		if @rn2 <> @rn1
			raiserror('Only Cancelled Source Table Hierarchies may be deleted, unless the Force Parameter has been set', 16, 1)
		else
			DELETE
			FROM   [dv_scheduler].[dv_source_table_hierarchy]
			WHERE  [source_table_hierarchy_key] = @source_table_hiearchy_key
			  and (isnull(@force, 0) | isnull([is_cancelled], 0) = 1)
		end
	COMMIT
GO
PRINT N'Creating [dv_scheduler].[dv_schedule_update]...';


GO
CREATE PROC [dv_scheduler].[dv_schedule_update] 
    @schedule_key			int,
	@schedule_name			varchar(128),	
    @schedule_description	varchar(256),	
    @schedule_frequency		varchar(128),	
	@is_cancelled				bit
AS 
	SET NOCOUNT ON 
	SET XACT_ABORT ON  
	
	BEGIN TRAN

	UPDATE [dv_scheduler].[dv_schedule]
    SET [schedule_name]				= @schedule_name			
       ,[schedule_description]		= @schedule_description	
       ,[schedule_frequency]		= @schedule_frequency	
       ,[is_cancelled]				= @is_cancelled			
	WHERE [schedule_key]			= @schedule_key
	
	-- Begin Return Select <- do not remove
	SELECT [schedule_key]
      ,[schedule_name]
      ,[schedule_description]
      ,[schedule_frequency]
      ,[is_cancelled]
      ,[release_key]
      ,[version_number]
      ,[updated_by]
      ,[updated_datetime]
    FROM [dv_scheduler].[dv_schedule]
	WHERE [schedule_key] = @schedule_key
	-- End Return Select <- do not remove

	COMMIT
GO
PRINT N'Creating [dv_scheduler].[dv_schedule_source_table_update]...';


GO
CREATE PROC [dv_scheduler].[dv_schedule_source_table_update] 
    @schedule_source_table_key		int,
    @schedule_key					int,
    @source_table_key				int,
	@source_table_load_type			varchar(50),
	@priority						varchar(50),
	@queue							varchar(50),
	@is_cancelled bit
AS 
	SET NOCOUNT ON 
	SET XACT_ABORT ON  
	
	BEGIN TRAN

	UPDATE [dv_scheduler].[dv_schedule_source_table]
    SET [schedule_key]				= @schedule_key
       ,[source_table_key]			= @source_table_key
       ,[source_table_load_type]	= @source_table_load_type
       ,[priority]					= @priority
       ,[queue]						= @queue
       ,[is_cancelled]				= @is_cancelled
 	WHERE  [schedule_source_table_key] = @schedule_source_table_key
	
	-- Begin Return Select <- do not remove
	SELECT [schedule_source_table_key]
      ,[schedule_key]
      ,[source_table_key]
      ,[source_table_load_type]
      ,[priority]
      ,[queue]
      ,[is_cancelled]
      ,[release_key]
      ,[version_number]
      ,[updated_by]
      ,[updated_datetime]
  FROM [dv_scheduler].[dv_schedule_source_table]
	WHERE  [schedule_source_table_key] = @schedule_source_table_key	
	-- End Return Select <- do not remove

	COMMIT
GO
PRINT N'Creating [dv_scheduler].[dv_report_email_manifest_progress]...';


GO
CREATE PROCEDURE [dv_scheduler].[dv_report_email_manifest_progress] (
	 @vault_offset_in_days	INT = 1
	,@vault_recipients		VARCHAR(max)
	,@vault_profile_name	VARCHAR(128)
	,@vault_output_results	BIT = 1
	,@vault_email_results	BIT = 0
	,@vault_top				INT = 50
	,@vault_html_string		VARCHAR(max) = ' ' OUTPUT					
	)
AS
BEGIN
SET NOCOUNT ON
declare @top int
if isnull(@vault_top, 0) < 10 set @top = 10 else set @top = @vault_top
select @top 
	IF EXISTS (
			SELECT 1
			FROM tempdb.dbo.sysobjects
			WHERE id = object_id(N'tempdb..#RecentExecutions')
			)
		DROP TABLE #RecentExecutions

	IF EXISTS (
			SELECT 1
			FROM tempdb.dbo.sysobjects
			WHERE id = object_id(N'tempdb..#RecentErrors')
			)
		DROP TABLE #RecentErrors

	IF EXISTS (
			SELECT 1
			FROM tempdb.dbo.sysobjects
			WHERE id = object_id(N'tempdb..#Log4Exceptions')
			)
		DROP TABLE #Log4Exceptions

	DECLARE 
	     @RecentExecutions	bit
		,@RecentErrors		bit
		,@Log4Exceptions	bit
		,@Log4Eliminated	bit
		,@HeaderColour		varchar(50)

	SELECT @RecentExecutions = 0
		,@RecentErrors = 0
		,@Log4Exceptions = 0
		,@HeaderColour = 'Black'
/******************************************************************************************************/
/******************************************************************************************************/
/*                            Table for List of Recent Executions:                                    */
/******************************************************************************************************/
/******************************************************************************************************/
;

	WITH wBaseSet
	AS (
		SELECT top (@top) [run_schedule_name]
			,[run_key] = cast([run_key] AS VARCHAR)
			,[run_status]
			,[run_start_datetime] = format([run_start_datetime], 'yyyy/MM/dd HH:mm:ss')
			,[run_end_datetime] = format([run_end_datetime], 'yyyy/MM/dd HH:mm:ss')
			,[run_duration] = convert(VARCHAR, [run_duration], 108)
			,[run_manifest_status]
			,[task_count] = count(*)
		FROM [dv_scheduler].[vw_manifest_status]
		WHERE 1 = 1
			AND [run_start_datetime] >= dateadd(day, @vault_offset_in_days * - 1, sysdatetimeoffset())
		GROUP BY [run_schedule_name]
			,[run_key]
			,[run_status]
			,[run_start_datetime]
			,[run_end_datetime]
			,[run_duration]
			,[run_manifest_status]
		)
		,wNumbered
	AS (
		SELECT [run_schedule_name]
			,[run_key]
			,[run_status]
			,[run_start_datetime]
			,[run_end_datetime]
			,[run_duration]
			,[run_manifest_status]
			,[task_count]
			,[rn] = row_number() OVER (
				ORDER BY [run_key]
					,[run_manifest_status]
				)
		FROM wBaseSet
		)
		,cte
	AS (
		SELECT [run_schedule_name]
			,[run_key]
			,[run_status]
			,[run_start_datetime]
			,[run_end_datetime]
			,[run_duration]
			,[run_manifest_status] = min([run_manifest_status])
			,[task_count] = min([task_count])
			,[rn] = min([rn])
		FROM wNumbered
		GROUP BY [run_schedule_name]
			,[run_key]
			,[run_status]
			,[run_start_datetime]
			,[run_end_datetime]
			,[run_duration]
		)
	SELECT [run_schedule_name] = isnull(c.[run_schedule_name], ' ')
		,[run_key] = isnull(c.[run_key], ' ')
		,[run_status] = isnull(c.[run_status], ' ')
		,[run_start_datetime] = isnull(c.[run_start_datetime], ' ')
		,[run_end_datetime] = isnull(c.[run_end_datetime], ' ')
		,[run_duration] = isnull(c.[run_duration], ' ')
		,[run_manifest_status] = isnull(t.[run_manifest_status], ' ')
		,[task_count] = isnull(t.[task_count], ' ')
		,[row_number] = t.[rn]
		,[TRRow] = rank() OVER (
			ORDER BY t.[run_key]
			) % 2
	INTO #RecentExecutions
	FROM wNumbered t
	LEFT JOIN cte c ON t.[rn] = c.[rn]
	ORDER BY t.[rn]

	IF (SELECT count(*) FROM #RecentExecutions WHERE [run_status] = 'Failed' ) > 0
		SET @RecentExecutions = 1
/******************************************************************************************************/
/******************************************************************************************************/
/*                            Table for List of Recent Tasks in Error:                                */
/******************************************************************************************************/
/******************************************************************************************************/

;WITH wBaseSet
	AS (
		SELECT top (@top) [run_schedule_name]
			,[run_key] = cast([run_key] AS VARCHAR)
			,[source_table_name]
			,[start_datetime] = format([start_datetime], 'yyyy/MM/dd HH:mm:ss')
			,[completed_datetime] = format(isnull([completed_datetime], [run_end_datetime]), 'yyyy/MM/dd HH:mm:ss')
			,[run_manifest_status]
			,[session_id] = cast([session_id] AS VARCHAR)
		FROM [dv_scheduler].[vw_manifest_status]
		WHERE 1 = 1
			AND [run_start_datetime] >= dateadd(day, @vault_offset_in_days * - 1, sysdatetimeoffset())
			AND [run_manifest_status] <> 'Completed'
		)
		,wNumbered
	AS (
		SELECT [run_schedule_name]
			,[run_key]
			,[source_table_name]
			,[start_datetime]
			,[completed_datetime]
			,[run_manifest_status]
			,[session_id]
			,[rn] = row_number() OVER (
				ORDER BY [run_key]
					,CASE 
						WHEN isnull([run_manifest_status], '') = 'Failed'
							THEN 1
						WHEN isnull([run_manifest_status], '') = 'Cancelled'
							THEN 2
						WHEN isnull([run_manifest_status], '') = 'Processing'
							THEN 3
						WHEN isnull([run_manifest_status], '') = 'Queued'
							THEN 4
						WHEN isnull([run_manifest_status], '') = 'Scheduled'
							THEN 5
						ELSE 99
						END
					,[source_table_name]
				)
		FROM wBaseSet
		)
		,cte
	AS (
		SELECT [run_schedule_name]
			,[run_key]
			,[source_table_name]
			,[start_datetime] = min([start_datetime])
			,[completed_datetime] = min([completed_datetime])
			,[run_manifest_status] = min([run_manifest_status])
			,[session_id] = min([session_id])
			,[rn] = min([rn])
		FROM wNumbered
		GROUP BY [run_schedule_name]
			,[run_key]
			,[source_table_name]
		)
	SELECT [run_schedule_name] = isnull(c.[run_schedule_name], ' ')
		,[run_key] = isnull(c.[run_key], ' ')
		,[source_table_name] = isnull(c.[source_table_name], ' ')
		,[start_datetime] = isnull(c.[start_datetime], '<Not Started>')
		,[completed_datetime] = isnull(c.[completed_datetime], ' ')
		,[run_manifest_status] = isnull(t.[run_manifest_status], ' ')
		,[session_id] = isnull(t.[session_id], ' ')
		,[row_number] = t.[rn]
		,[TRRow] = rank() OVER (
			ORDER BY t.[rn]
			) % 2
	INTO #RecentErrors
	FROM wNumbered t
	LEFT JOIN cte c ON t.[rn] = c.[rn]
	ORDER BY t.[rn]

	IF (SELECT count(*) FROM #RecentErrors WHERE [run_manifest_status] = 'Failed' ) > 0
		SET @RecentErrors = 1
/******************************************************************************************************/
/******************************************************************************************************/
/*                            Table for List of Recently (Log4) Logged Errors:                        */
/******************************************************************************************************/
/******************************************************************************************************/
;

	WITH wBaseSet
	AS (
		SELECT top (@top) [SessionId] = cast(e.[SessionId] AS VARCHAR)
			,[ExceptionId] = cast(e.[ExceptionId] AS VARCHAR)
			,[SessionLoginTime] = format(e.[SessionLoginTime], 'yyyy/MM/dd HH:mm:ss')
			,[SystemDate] = format(e.[SystemDate], 'yyyy/MM/dd HH:mm:ss')
			,[ErrorContext]
			,[ErrorMessage]
			,[ServerName]
			,[DatabaseName]
			,[LoginName]
			,[ErrorNumber] = cast(e.[ErrorNumber] AS VARCHAR)
			,[ErrorSeverity] = cast(e.[ErrorSeverity] AS VARCHAR)
			,[ErrorState] = cast(e.[ErrorState] AS VARCHAR)
			,[ErrorProcedure]
			,[ErrorLine] = cast(e.[ErrorLine] AS VARCHAR)
			,[UtcDate] = format(e.[UtcDate], 'yyyy/MM/dd HH:mm:ss')
			,[SourceTableName] = t.[source_table_name]
			,[RunKey] = cast(t.[run_key] AS VARCHAR)
			,[RunScheduleName] = t.[run_schedule_name]
		FROM [log4].[Exception] e
		LEFT JOIN #RecentErrors t ON e.SessionId = t.session_id
			AND e.SystemDate BETWEEN CASE 
						WHEN isnull(t.start_datetime, '') = ''
							THEN '31 Dec 9999'
						ELSE t.start_datetime
						END
				AND CASE 
						WHEN isnull(t.completed_datetime, '<Not Started>') = ''
							THEN '31 Dec 9999'
						ELSE t.completed_datetime
						END
			AND t.run_manifest_status = 'Failed'
		WHERE 1 = 1
			AND e.[SystemDate] >= dateadd(day, @vault_offset_in_days * - 1, sysdatetime())
		)
		,wNumbered
	AS (
		SELECT [SessionId]
			,[ExceptionId]
			,[SessionLoginTime]
			,[SystemDate]
			,[ErrorContext]
			,[ErrorMessage]
			,[ServerName]
			,[DatabaseName]
			,[LoginName]
			,[ErrorNumber]
			,[ErrorSeverity]
			,[ErrorState]
			,[ErrorProcedure]
			,[ErrorLine]
			,[UtcDate]
			,[SourceTableName]
			,[RunKey]
			,[RunScheduleName]
			,[rn] = row_number() OVER (
				ORDER BY [SessionLoginTime]
					,[SessionId]
					,[SystemDate]
				)
		FROM wBaseSet
		)
		,cte
	AS (
		SELECT [SessionId]
			,[SessionLoginTime]
			,[ExceptionId]
			,[SystemDate] = min([SystemDate])
			,[ErrorContext] = min([ErrorContext])
			,[ErrorMessage] = min([ErrorMessage])
			,[LoginName] = min([LoginName])
			,[ErrorNumber] = min([ErrorNumber])
			,[ErrorSeverity] = min([ErrorSeverity])
			,[ErrorState] = min([ErrorState])
			,[ErrorProcedure] = min([ErrorProcedure])
			,[ErrorLine] = min([ErrorLine])
			,[UtcDate] = min([UtcDate])
			,[SourceTableName] = min([SourceTableName])
			,[RunKey] = min([RunKey])
			,[RunScheduleName] = min([RunScheduleName])
			,[rn] = min([rn])
		FROM wNumbered
		GROUP BY [SessionId]
			,[SessionLoginTime]
			,[ExceptionId]
		)
	SELECT [SessionId] = isnull(c.[SessionId], ' ')
		,[SessionLoginTime] = isnull(c.[SessionLoginTime], ' ')
		,[SystemDate] = isnull(t.[SystemDate], ' ')
		,[ErrorContext] = isnull(t.[ErrorContext], ' ')
		,[ErrorMessage] = isnull(t.[ErrorMessage], ' ')
		,[LoginName] = isnull(t.[LoginName], ' ')
		,[ErrorNumber] = isnull(t.[ErrorNumber], ' ')
		,[ErrorSeverity] = isnull(t.[ErrorSeverity], ' ')
		,[ErrorState] = isnull(t.[ErrorState], ' ')
		,[ErrorProcedure] = isnull(t.[ErrorProcedure], '')
		,[ErrorLine] = isnull(t.[ErrorLine], ' ')
		,[UtcDate] = isnull(t.[UtcDate], '')
		,[SourceTableName] = isnull(t.[SourceTableName], '')
		,[RunKey] = isnull(t.[RunKey], '')
		,[RunScheduleName] = isnull(t.[RunScheduleName], '')
		,[row_number] = t.[rn]
		,[TRRow] = rank() OVER (
			ORDER BY t.[SessionLoginTime] DESC
				,t.[SessionId]
			) % 2
	INTO #Log4Exceptions
	FROM wNumbered t
	LEFT JOIN cte c ON t.[rn] = c.[rn]
	ORDER BY t.[rn]

	IF @@ROWCOUNT > 0
		SET @Log4Exceptions = 1

/******************************************************************************************************/
/******************************************************************************************************/
/*                            Table for List of Recently Eliminated Duplicates:                        */
/******************************************************************************************************/
/******************************************************************************************************/
;

	WITH wBaseSet
	AS (
		select top (@top) [JournalId]		= cast([JournalId] AS VARCHAR)
			  ,[SystemDate]		= format([SystemDate], 'yyyy/MM/dd HH:mm:ss')
			  ,[FunctionName]		
			  ,[MessageText]		
	from [log4].[Journal] 

	where 1=1
	  and [SystemDate] >= dateadd(day, @vault_offset_in_days * - 1, sysdatetime())
	  and FunctionName = 'dv_load_source_table_key_lookup'
	  and StepInFunction = 'Remove Duplicates before Loading Source Table'
	  and MessageText like 'Duplicate Keys Removed while Loading%'
	  )

,wNumbered
	AS (
		SELECT
			 [JournalId]	
			,[SystemDate]	
			,[FunctionName]
			,[MessageText]			
			,[rn] = row_number() OVER (
				ORDER BY [JournalId]
				)
		FROM wBaseSet
		)
,cte
	AS (
		SELECT [JournalId]
			,[SystemDate]
			,[FunctionName]
			,[MessageText]	= min([MessageText])
			,[rn]			= min([rn])
		FROM wNumbered
		GROUP BY [JournalId]
			,[SystemDate]
			,[FunctionName]
		)
	SELECT [JournalId] = isnull(c.[JournalId], ' ')
		,[SystemDate] = isnull(c.[SystemDate], ' ')
		,[FunctionName] = isnull(t.[FunctionName], ' ')
		,[MessageText] = isnull(t.[MessageText], ' ')
		,[row_number] = t.[rn]
		,[TRRow] = rank() OVER (
			ORDER BY t.[SystemDate] DESC
				,t.[JournalId]
			) % 2
	INTO #Log4Eliminated
	FROM wNumbered t
	LEFT JOIN cte c ON t.[rn] = c.[rn]
	ORDER BY t.[rn]

	IF @@ROWCOUNT > 0
		SET @Log4Eliminated = 1


	IF @vault_output_results = 1
	BEGIN
		SELECT * FROM #RecentExecutions
		SELECT * FROM #RecentErrors
		SELECT * FROM #Log4Exceptions
		SELECT * FROM #Log4Eliminated
	END

	/******************************************************************************************************/
	/******************************************************************************************************/
	/*                            Build an HTML String                                                                                */
	/******************************************************************************************************/
	/******************************************************************************************************/
	DECLARE @Message VARCHAR(max)
		,@Subject NVARCHAR(255)
		,@Body VARCHAR(max)
		,@TableHead VARCHAR(max)
		,@TableTail VARCHAR(max)
		,@HTMLHead VARCHAR(max)
		,@HTMLTail VARCHAR(max)
		,@StartDateChar VARCHAR(50)

	SET @subject = 'ODE Progress Report Sent from ' + @@Servername

	SELECT @StartDateChar = format(dateadd(day, @vault_offset_in_days * - 1, sysdatetime()), 'yyyy/MM/dd HH:mm')

	-- HTML Header and Trailer setup
	IF (@RecentExecutions | @RecentErrors | @Log4Exceptions) = 1
		SET @HeaderColour = 'Red'
	SET @HTMLHead = '<html>' + 
						'<head>' + 
							'<style>' + 
							'td {border: 1px solid #aabcfe;padding-left:5px;padding-right:5px;padding-top:1px;padding-bottom:1px;font-size:11pt;} ' + 
							'</style>' + 
						'</head>' + 
						'<body>' + 
						'<H1><font color="' + @HeaderColour + '">' + @Subject + '</H1>'
	SET @HTMLTail = '</body></html>'
	SET @TableTail = '</table>'
	SET @Message = @HTMLHead
	/******************************************************************************************************/
	/******************************************************************************************************/
	/*                            Table for List of Recent Executions:                                    */
	/******************************************************************************************************/
	/******************************************************************************************************/
	SET @TableHead = '<H3><font color="' + @HeaderColour + '">ODE Scheduled Executions Since ' + @StartDateChar + ' </H3>' + 
					 '<table cellpadding=0 cellspacing=0 border=0>' + 
						'<tr bgcolor=#aabcfe>' + 
							'<td align=center><b>Schedule Name</b></td>' + 
							'<td align=right><b>Run Key</b></td>' + 
							'<td align=center><b>Run Status</b></td>' + 
							'<td align=center><b>Run Start</b></td>' + 
							'<td align=center><b>Run End</b></td>' + 
							'<td align=center><b>Run Duration</b></td>' + 
							'<td align=center><b>Task Status</b></td>' + 
							'<td align=right><b>Task Status Count</b></td>' + 
						'</tr>';

	SELECT @Body = (
			SELECT [TRRow] = rank() OVER (ORDER BY [run_key]) % 2
				,[TD] = isnull([run_schedule_name], ' ')
				,[TD align = right] = isnull([run_key], ' ')
				,[TD] = isnull([run_status], ' ')
				,[TD] = isnull([run_start_datetime], ' ')
				,[TD] = isnull([run_end_datetime], ' ')
				,[TD] = isnull([run_duration], ' ')
				,[TD align = center] = isnull([run_manifest_status], ' ')
				,[TD align = right] = isnull([task_count], ' ')
			FROM #RecentExecutions
			ORDER BY [row_number] 
			FOR XML raw('tr')
				,Elements
			)

	-- Replace the entity codes and row numbers
	SET @Body = Replace(@Body, '_x0020_', space(1))
	SET @Body = Replace(@Body, '_x003D_', '=')
	SET @Body = Replace(@Body, '<tr><TRRow>0</TRRow>', '<tr bgcolor=Gainsboro>')
	SET @Body = Replace(@Body, '<tr><TRRow>1</TRRow>', '<tr bgcolor=Snow>')
	SET @Body = Replace(@Body, '<TD align = center>Failed</TD align = center>', '<td align = center bgcolor=red>Failed</TD align = center>')

	IF @Body IS NULL
		SELECT @Body = '<H3><font color="' + @HeaderColour + '">No ODE Scheduled Executions Since ' + @StartDateChar + ' </H3>'
	ELSE
		SELECT @Body = @TableHead + @Body + @TableTail

	SET @Message = @Message + @Body
	/******************************************************************************************************/
	/******************************************************************************************************/
	/*                            Table for List of Recent Tasks in Error:                                */
	/******************************************************************************************************/
	/******************************************************************************************************/
	SET @TableHead = '<H3><font color="' + @HeaderColour + '">ODE Tasks Not Completed Since ' + @StartDateChar + ' </H3>' + '<table cellpadding=0 cellspacing=0 border=0>' + '<tr bgcolor=#aabcfe><td align=center><b>Schedule Name</b></td>' + '<td align=right><b>Run Key</b></td>' + '<td align=center><b>Source Table</b></td>' + '<td align=center><b>Run Start</b></td>' + '<td align=center><b>Task Status</b></td>' + '<td align=right><b>Session ID</b></td>' + '</tr>';

	SELECT @Body = (
			SELECT [TRRow] = rank() OVER (
					ORDER BY [row_number]
					) % 2
				,[TD] = isnull([run_schedule_name], ' ')
				,[TD align = right] = isnull([run_key], ' ')
				,[TD] = isnull([source_table_name], ' ')
				,[TD align = center] = isnull([start_datetime], '<Not Started>')
				,[TD align = center] = isnull([run_manifest_status], ' ')
				,[TD align = right] = isnull([session_id], ' ')
			FROM #RecentErrors
			ORDER BY [row_number]
			FOR XML raw('tr')
				,Elements
			)

	-- Replace the entity codes and row numbers
	SET @Body = Replace(@Body, '_x0020_', space(1))
	SET @Body = Replace(@Body, '_x003D_', '=')
	SET @Body = Replace(@Body, '<tr><TRRow>0</TRRow>', '<tr bgcolor=Gainsboro>')
	SET @Body = Replace(@Body, '<tr><TRRow>1</TRRow>', '<tr bgcolor=Snow>')
	SET @Body = Replace(@Body, '<TD align = center>Failed</TD align = center>', '<td align = center bgcolor=red>Failed</TD align = center>')

	IF @Body IS NULL
		SELECT @Body = '<H3><font color="' + @HeaderColour + '"> No ODE Tasks Not Completed Since ' + @StartDateChar + ' </H3>'
	ELSE
		SELECT @Body = @TableHead + @Body + @TableTail

	SET @Message = @Message + @Body
	/******************************************************************************************************/
	/******************************************************************************************************/
	/*                            Table for List of Recently (Log4) Logged Errors:                        */
	/******************************************************************************************************/
	/******************************************************************************************************/
	SET @TableHead = '<H3><font color="' + @HeaderColour + '">ODE Errors Raised Since ' + @StartDateChar + ' </H3>' + '<table cellpadding=0 cellspacing=0 border=0>' + '<tr bgcolor=#aabcfe><td align=center><b>Session ID</b></td>' + '<td align=right><b>Session Login Time</b></td>' + '<td align=center><b>System Date</b></td>' + '<td align=center><b>Error Context</b></td>' + '<td align=right><b>Error Message</b></td>' + '<td align=right><b>Login Name</b></td>' + '<td align=center><b>Error Number</b></td>' + '<td align=center><b>Error Severity</b></td>' + '<td align=right><b>Error State</b></td>' + '<td align=center><b>Error Procedure</b></td>' + '<td align=center><b>Error Line</b></td>' + '<td align=center><b>Load Task</b></td>' + '<td align=center><b>Run Key</b></td>' + '<td align=right><b>Schedule</b></td>' + '</tr>';

	SELECT @Body = (
			SELECT [TRRow] = rank() OVER (
					ORDER BY [SessionLoginTime] DESC
						,[SessionId]
					) % 2
				,[TD align = right] = isnull([SessionId], ' ')
				,[TD] = isnull([SessionLoginTime], ' ')
				,[TD] = isnull([SystemDate], ' ')
				,[TD] = isnull([ErrorContext], ' ')
				,[TD] = isnull([ErrorMessage], ' ')
				,[TD] = isnull([LoginName], ' ')
				,[TD align = right] = isnull([ErrorNumber], ' ')
				,[TD align = right] = isnull([ErrorSeverity], ' ')
				,[TD align = right] = isnull([ErrorState], ' ')
				,[TD] = isnull([ErrorProcedure], '')
				,[TD align = right] = isnull([ErrorLine], ' ')
				,[TD] = isnull([SourceTableName], ' ')
				,[TD] = isnull([RunKey], ' ')
				,[TD] = isnull([RunScheduleName], ' ')
			FROM #Log4Exceptions
			ORDER BY [row_number]
			FOR XML raw('tr')
				,Elements
			)

	-- Replace the entity codes and row numbers
	SET @Body = Replace(@Body, '_x0020_', space(1))
	SET @Body = Replace(@Body, '_x003D_', '=')
	SET @Body = Replace(@Body, '<tr><TRRow>0</TRRow>', '<tr bgcolor=Gainsboro>')
	SET @Body = Replace(@Body, '<tr><TRRow>1</TRRow>', '<tr bgcolor=Snow>')
	SET @Body = Replace(@Body, '<TD align = center>Failed</TD align = center>', '<td align = center bgcolor=red>Failed</TD align = center')

	IF @Body IS NULL
		SELECT @Body = '<H3><font color="' + @HeaderColour + '">No ODE Errors to Report Since ' + @StartDateChar + ' </H3>'
	ELSE
		SELECT @Body = @TableHead + @Body + @TableTail

	SET @Message = @Message + @Body

	/******************************************************************************************************/
	/******************************************************************************************************/
	/*                            Table for List of Eliminated Duplicates:                                */
	/******************************************************************************************************/
	/******************************************************************************************************/
	SET @TableHead = '<H3><font color="' + @HeaderColour + '">ODE Duplicate Rows Eliminated Since ' + @StartDateChar + ' </H3>' + 
					 '<table cellpadding=0 cellspacing=0 border=0>' + 
						'<tr bgcolor=#aabcfe>' + 
							'<td align=center><b>Journal ID</b></td>' + 
							'<td align=right><b>System Date</b></td>' + 
							'<td align=center><b>Function Name</b></td>' + 
							'<td align=center><b>Message</b></td>' +							
						'</tr>';
	SELECT @Body = (
		SELECT [TRRow] = rank() OVER (ORDER BY [JournalId]) % 2
			  ,[TD] = isnull([JournalId], ' ')
			  ,[TD] = isnull([SystemDate], ' ')
			  ,[TD] = isnull([FunctionName], ' ')
			  ,[TD] = isnull([MessageText], ' ')

		FROM #Log4Eliminated
		ORDER BY [row_number] desc
		FOR XML raw('tr')
			,Elements
		)

-- Replace the entity codes and row numbers
	SET @Body = Replace(@Body, '_x0020_', space(1))
	SET @Body = Replace(@Body, '_x003D_', '=')
	SET @Body = Replace(@Body, '<tr><TRRow>0</TRRow>', '<tr bgcolor=Gainsboro>')
	SET @Body = Replace(@Body, '<tr><TRRow>1</TRRow>', '<tr bgcolor=Snow>')
	--SET @Body = Replace(@Body, '<TD align = center>Failed</TD align = center>', '<td align = center bgcolor=red>Failed</TD align = center>')

	IF @Body IS NULL
		SELECT @Body = '<H3><font color="' + @HeaderColour + '">No ODE Duplicates Removed Since ' + @StartDateChar + ' </H3>'
	ELSE
		SELECT @Body = @TableHead + @Body + @TableTail

	SET @Message = @Message + @Body
	-- Add the HTML Tail:
	--SET @Message = @Message + @HTMLTail
	/******************************************************************************************************/
	/******************************************************************************************************/
	/*                             Add the HTML Tail and Output the String                                */
	/******************************************************************************************************/
	/******************************************************************************************************/
	SET @Message = @Message + @HTMLTail
	SET @vault_html_string = @Message

	/******************************************************************************************************/
	/******************************************************************************************************/
	/*                            Table for List of Recent Executions:                                    */
	/******************************************************************************************************/
	/******************************************************************************************************/
	IF @vault_email_results = 1
		EXEC msdb.dbo.sp_send_dbmail @profile_name = @vault_profile_name
			,@recipients = @vault_recipients
			,@subject = @subject
			,@body = @Message
			,@body_format = 'HTML'
END
GO
PRINT N'Creating [dv_scheduler].[dv_manifest_status_update]...';


GO
CREATE PROCEDURE [dv_scheduler].[dv_manifest_status_update]
(
  @vault_run_key				 int			= NULL
, @vault_source_system_name      varchar(50)	= NULL
, @vault_source_table_schema     varchar(128)   = NULL
, @vault_source_table_name       varchar(128)   = NULL
, @vault_run_status				 varchar(20)	= NULL
, @dogenerateerror               bit            = 0
, @dothrowerror                  bit			= 1
)
AS
BEGIN
SET NOCOUNT ON

if @vault_run_status in ('Queued', 'Failed', 'Cancelled')
	UPDATE [dv_scheduler].[dv_run_manifest]
			SET   [run_status] = @vault_run_status
			WHERE [run_key] = @vault_run_key
			  AND [source_system_name]	= @vault_source_system_name
			  AND [source_table_schema] = @vault_source_table_schema
              AND [source_table_name]	= @vault_source_table_name
else if @vault_run_status in ('Processing')
	UPDATE [dv_scheduler].[dv_run_manifest]
			SET [run_status] = @vault_run_status
			   ,[start_datetime] = SYSDATETIMEOFFSET()
               ,[session_id] = @@SPID
			WHERE [run_key] = @vault_run_key
			  AND [source_system_name]	= @vault_source_system_name
			  AND [source_table_schema] = @vault_source_table_schema
              AND [source_table_name]	= @vault_source_table_name
else if @vault_run_status in ('Completed')
    UPDATE [dv_scheduler].[dv_run_manifest]
			SET [completed_datetime] = SYSDATETIMEOFFSET()
               ,[run_status] = 'Completed'
			WHERE [run_key] = @vault_run_key
			  AND [source_system_name]	= @vault_source_system_name
			  AND [source_table_schema] = @vault_source_table_schema
              AND [source_table_name]	= @vault_source_table_name
else
    raiserror('@vault_run_status must be one of: (Processing, Queued, Failed, Completed, Cancelled)', 16, 1)



END
GO
PRINT N'Creating [dv_scheduler].[dv_list_schedule_hierarchy]...';


GO
CREATE procedure [dv_scheduler].[dv_list_schedule_hierarchy]
( 
  @schedule_list varchar(4000)
)
as

BEGIN
set nocount on

declare @RN				int
       ,@_Message       nvarchar(512)
SELECT @RN = count(*) FROM [dv_scheduler].[fn_check_schedule_for_circular_reference](@schedule_list)
if @RN > 0
   begin
   select * FROM [dv_scheduler].[fn_check_schedule_for_circular_reference](@schedule_list)
   select @_Message = 'The Schedule: ' + @schedule_list + ' has Circular Reference and cannot be displayed'
   raiserror(@_Message, 16, 1)
   return
   end

;with wSchedule_Table as (
      select s.schedule_key
	        ,st.[source_table_key]
	        ,ss.source_system_name
	        ,st.source_table_schema
			,st.source_table_name
	  from [dv_scheduler].[vw_dv_schedule_current] s
	  inner join [dv_scheduler].[vw_dv_schedule_source_table_current] sst
	  on sst.schedule_key = s.schedule_key
	  inner join [dbo].[dv_source_table] st
	  on st.[source_table_key] = sst.source_table_key
	  inner join [dbo].[dv_source_system] ss
	  on ss.[source_system_key] = st.system_key
	  where s.schedule_name in(select ltrim(rtrim(Item)) FROM [dbo].[fn_split_strings] (@schedule_list, ','))
	)
,wBaseSetPrior as (
select 
    schtp.[source_table_key] as table_key_prior
   ,scht.[source_table_key]
   ,source_table_name = cast(
						quotename(schtp.[source_system_name]) + '.' +  
						quotename(schtp.[source_table_schema]) + '.' +  
						quotename(schtp.[source_table_name]) as nvarchar(512))   
    
from wSchedule_Table schtp
left join [dv_scheduler].[vw_dv_source_table_hierarchy_current] sth
    on sth.[prior_table_key] = schtp.[source_table_key] 
left join wSchedule_Table scht
	on sth.[source_table_key] = scht.[source_table_key]
left join [dv_scheduler].[vw_dv_source_table_hierarchy_current] sthp
	on sthp.[source_table_key] = schtp.[source_table_key]
left join wSchedule_Table sthpst
	on sthpst.[source_table_key] = sthp.[prior_table_key] 
where sthpst.[source_table_key] is null
)
,wBaseSet as (
select  
    schtp.[source_table_key] as table_key_prior
   ,scht.[source_table_key]
   ,source_table_name = cast(
						quotename(schtp.[source_system_name]) + '.' +  
						quotename(schtp.[source_table_schema]) + '.' +  
						quotename(schtp.[source_table_name]) as nvarchar(512))   

from wSchedule_Table schtp
left join [dv_scheduler].[vw_dv_source_table_hierarchy_current] sth
    on sth.[prior_table_key] = schtp.[source_table_key] 
left join wSchedule_Table scht
	on sth.[source_table_key] = scht.[source_table_key]
)

,wBOM as (
select *
from wBaseSetPrior

union all
select
    b.table_key_prior
   ,b.[source_table_key]
   ,CAST(cte.source_table_name + ' >>> ' + b.source_table_name as nvarchar(512)) 
   
from wBaseSet b
inner join wBOM AS cte 
    ON cte.source_table_key = b.table_key_prior 
)

select distinct source_table_name 
from wBOM
order by source_table_name
OPTION (MAXRECURSION 5000)
END
GO
PRINT N'Creating [dv_scheduler].[dv_list_manifest_hierarchy]...';


GO
CREATE procedure [dv_scheduler].[dv_list_manifest_hierarchy]
( 
  @vault_run_key int
)
as

BEGIN
set nocount on

declare @RN				int
       ,@_Message       nvarchar(512)
SELECT @RN = count(*) FROM [dv_scheduler].[fn_check_manifest_for_circular_reference] (@vault_run_key)
if @RN > 0
   begin
   select * from [dv_scheduler].[fn_check_manifest_for_circular_reference] (@vault_run_key)
   select @_Message = 'The Manifest for run_key ' + cast(@vault_run_key as varchar(20)) + ' has Circular Reference and cannot be displayed'
   raiserror(@_Message, 16, 1)
   return
   end

;with  wBaseSetPrior as (
select
    mp.run_manifest_key as run_manifest_key_prior
   ,m.run_manifest_key
   ,source_table_name = cast(
							quotename(mp.[source_system_name]) + '.' +  
							quotename(mp.[source_table_schema]) + '.' +  
							quotename(mp.[source_table_name])  
						as nvarchar(512))   
 
from [dv_scheduler].[dv_run] r
inner join [dv_scheduler].[dv_run_manifest] mp
	on r.run_key = mp.run_key
left join [dv_scheduler].[dv_run_manifest_hierarchy] mh
    on mh.run_manifest_prior_key = mp.run_manifest_key 
left join [dv_scheduler].[dv_run_manifest] m
    on m.run_manifest_key = mh.run_manifest_key
left join [dv_scheduler].[dv_run_manifest_hierarchy] mhp
	on mhp.run_manifest_key = mp.run_manifest_key

where 1=1
  and r.run_key = @vault_run_key
  and mhp.run_manifest_prior_key is null
)
,wBaseSet as (
select
    mp.run_manifest_key as run_manifest_key_prior
   ,m.run_manifest_key
   ,source_table_name = cast(
							quotename(mp.[source_system_name]) + '.' +  
							quotename(mp.[source_table_schema]) + '.' +  
							quotename(mp.[source_table_name])  
						as nvarchar(512))   
    
from [dv_scheduler].[dv_run] r
inner join [dv_scheduler].[dv_run_manifest] mp
	on r.run_key = mp.run_key
left join [dv_scheduler].[dv_run_manifest_hierarchy] mh
    on mh.run_manifest_prior_key = mp.run_manifest_key 
left join [dv_scheduler].[dv_run_manifest] m
    on m.run_manifest_key = mh.run_manifest_key
where r.run_key = @vault_run_key
)
,wBOM as (
select *
from wBaseSetPrior

union all
select
    b.run_manifest_key_prior
   ,b.run_manifest_key
   ,CAST(cte.source_table_name + ' >>> ' + b.source_table_name as nvarchar(512)) 
   
from wBaseSet b
inner join wBOM AS cte 
    ON cte.run_manifest_key = b.run_manifest_key_prior
)

select distinct source_table_name 
from wBOM
order by source_table_name
OPTION (MAXRECURSION 5000)
END
GO
PRINT N'Creating [dv_scheduler].[dv_schedule_source_table_insert]...';


GO
CREATE PROC [dv_scheduler].[dv_schedule_source_table_insert] 
     @schedule_name				varchar(128)
	,@source_system_name		varchar(50)
	,@source_table_schema		varchar(128)
    ,@source_table_name			varchar(128)
    ,@source_table_load_type	varchar(50)
	,@priority					varchar(50)
	,@queue						VARCHAR(50)
	,@release_number			int
AS
BEGIN 
	SET NOCOUNT ON 
	SET XACT_ABORT ON  
	
	BEGIN TRAN
	
	declare @release_key					int
	       ,@schedule_key					int
	       ,@source_table_key				int
		   ,@source_table_qualified_name	varchar(512)
	       ,@rc								int
	select @release_key = [release_key] from [dv_release].[dv_release_master] where [release_number] = @release_number
	set @rc = @@rowcount
	if @rc <> 1 
		RAISERROR('Release Number %i Does Not Exist', 16, 1, @release_number)
		else
			begin
			select @schedule_key = [schedule_key] from [dv_scheduler].[dv_schedule] 
				where [schedule_name] = @schedule_name
				  and is_cancelled <> 1
			set @rc = @@rowcount
			if @rc <> 1 
				RAISERROR('Schedule Name %s Does Not Exist', 16, 1, @schedule_name)
				else
					begin
					select @source_table_qualified_name = quotename(@source_system_name) + '.' + quotename(@source_table_schema) + quotename(@source_table_name)
					select @source_table_key = [source_table_key] 
					from [dbo].[dv_source_system] s
					inner join [dbo].[dv_source_table] st
					on s.[source_system_key] = st.[system_key]
					where s.[source_system_name]	= @source_system_name
					  and st.[source_table_schema]	= @source_table_schema
					  and [source_table_name]		= @source_table_name
					set @rc = @@rowcount
					if @rc <> 1 
						RAISERROR('Source Table %s Does Not Exist', 16, 1, @source_table_qualified_name)
						else
							INSERT INTO [dv_scheduler].[dv_schedule_source_table] ([schedule_key] ,[source_table_key] ,[source_table_load_type] ,[priority] ,[queue] ,[release_key])
							 VALUES (@schedule_key ,@source_table_key,@source_table_load_type,@priority,@queue,@release_key)
					end
			end
	-- Begin Return Select <- do not remove

	SELECT [schedule_source_table_key]
		  ,[schedule_key]
		  ,[source_table_key]
		  ,[source_table_load_type]
		  ,[release_key]
		  ,[priority]
		  ,[queue]
		  ,[version_number]
		  ,[updated_by]
		  ,[updated_datetime]
	  FROM [dv_scheduler].[dv_schedule_source_table]
 	WHERE  [schedule_source_table_key] = SCOPE_IDENTITY()
	-- End Return Select <- do not remove
               
	COMMIT
       RETURN SCOPE_IDENTITY()
END
GO
PRINT N'Creating [dv_scheduler].[dv_schedule_source_table_delete]...';


GO
CREATE PROC [dv_scheduler].[dv_schedule_source_table_delete] 
    @schedule_source_table_key	int
   ,@force						int = 0
AS 
	declare @rn1 int
	       ,@rn2 int
	BEGIN TRAN
	select @rn1 = count(*)
	from [dv_scheduler].[dv_schedule_source_table]
	where  [schedule_source_table_key] = @schedule_source_table_key	
	if @rn1 > 0
	    begin
		select @rn2 = count(*)
		from [dv_scheduler].[dv_schedule_source_table]
		where  [schedule_source_table_key] = @schedule_source_table_key	
		  and (isnull(@force, 0) | isnull([is_cancelled], 0) = 1)
		if @rn2 <> @rn1
			raiserror('Only Cancelled Schedule Source Table Links may be deleted, unless the Force Parameter has been set', 16, 1)
		else
			DELETE
			FROM   [dv_scheduler].[dv_schedule_source_table]
			WHERE  [schedule_source_table_key] = @schedule_source_table_key	
			  and (isnull(@force, 0) | isnull([is_cancelled], 0) = 1)
		end
	COMMIT
GO
PRINT N'Creating [log4].[SessionInfoOutput]...';


GO
/*************************************************************************************************/
--</MaintenanceHeader>

CREATE PROCEDURE [log4].[SessionInfoOutput]
(
  @SessionId          int
, @HostName           nvarchar ( 128 ) = NULL  OUT
, @ProgramName        nvarchar ( 128 ) = NULL  OUT
, @NTDomain           nvarchar ( 128 ) = NULL  OUT
, @NTUsername         nvarchar ( 128 ) = NULL  OUT
, @LoginName          nvarchar ( 128 ) = NULL  OUT
, @OriginalLoginName  nvarchar ( 128 ) = NULL  OUT
, @SessionLoginTime   datetime         = NULL  OUT
)

AS

--<CommentHeader>
/**********************************************************************************************************************

Properties
=====================================================================================================================
PROCEDURE NAME:  SessionInfoOutput
DESCRIPTION:     Outputs session info from master.sys.dm_exec_sessions for the current @@SPID
DATE OF ORIGIN:  15-APR-2008
ORIGINAL AUTHOR: Greg M. Lucas (data-centric solutions ltd. http://www.data-centric.co.uk)
BUILD DATE:      13-MAR-2012
BUILD VERSION:   0.0.10
DEPENDANTS:      log4.ExceptionHandler
                 log4.JournalWriter
DEPENDENCIES:    Called functions

Returns
=====================================================================================================================
@@ERROR - always zero on success

Additional Notes
=====================================================================================================================


Revision history
=====================================================================================================================
ChangeDate		Author	Version		Narrative
============	======	=======		=================================================================================
15-APR-2008		GML		vX.Y.z		Created
------------	------	-------		---------------------------------------------------------------------------------


=====================================================================================================================
(C) Copyright 2006-12 data-centric solutions ltd. (http://log4tsql.sourceforge.net/)

This library is free software; you can redistribute it and/or modify it under the terms of the
GNU Lesser General Public License as published by the Free Software Foundation (www.fsf.org);
either version 3.0 of the License, or (at your option) any later version.

This library is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;
without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
See the GNU Lesser General Public License for more details.

You should have received a copy of the GNU Lesser General Public License along with this
library; if not, you can find it at http://www.opensource.org/licenses/lgpl-3.0.html
or http://www.gnu.org/licenses/lgpl.html

**********************************************************************************************************************/
--</CommentHeader>

BEGIN
	SET NOCOUNT ON

	BEGIN TRY
		SELECT
			  @HostName				= s.[host_name]
			, @ProgramName			= s.[program_name]
			, @NTDomain				= s.nt_domain
			, @NTUsername			= s.nt_user_name
			, @LoginName			= s.login_name
			, @OriginalLoginName	= s.original_login_name
			, @SessionLoginTime		= s.login_time
		FROM
			master.sys.dm_exec_sessions AS [s] WITH (NOLOCK)
		WHERE
			s.session_id = @SessionId
	END TRY
	BEGIN CATCH
		--! Make sure we return non-null values
		SET @SessionId			= 0
		SET @HostName			= ''
		SET @ProgramName		= 'log4.SessionInfoOutput Error!'
		SET @NTDomain			= ''
		SET @NTUsername			= ''
		SET @LoginName			= 'log4.SessionInfoOutput Error!'
		SET @OriginalLoginName	= ''

		DECLARE @context nvarchar(512); SET @context = 'log4.SessionInfoOutput failed to retrieve session info';

		--! Only rollback if we have an uncommitable transaction
		IF (XACT_STATE() = -1)
		OR (@@TRANCOUNT > 0 AND XACT_STATE() != 1)
			BEGIN
				ROLLBACK TRAN;
				SET @context = @context + ' (Forced rolled back of all changes due to uncommitable transaction)';
			END

		--! Log this error directly
		--! Don't call ExceptionHandler in case we get another
		--! SessionInfoOutput error and and up in a never-ending loop)
		INSERT [log4].[Exception]
		(
		  [ErrorContext]
		, [ErrorNumber]
		, [ErrorSeverity]
		, [ErrorState]
		, [ErrorProcedure]
		, [ErrorLine]
		, [ErrorMessage]
		, [SessionId]
		, [ServerName]
		, [DatabaseName]
		)
		SELECT
			  @context
			, ERROR_NUMBER()
			, ERROR_SEVERITY()
			, ERROR_STATE()
			, ERROR_PROCEDURE()
			, ERROR_LINE()
			, ERROR_MESSAGE()
			, @@SPID
			, @@SERVERNAME
			, DB_NAME()
	END CATCH

	SET NOCOUNT OFF
END
GO
PRINT N'Creating [log4].[PrintString]...';


GO
/*************************************************************************************************/
--</MaintenanceHeader>

CREATE PROCEDURE [log4].[PrintString]
(
  @InputString		nvarchar(max)	= NULL
, @MaxPrintLength	int				= 4000
)

AS

--<CommentHeader>
/**********************************************************************************************************************

Properties
=====================================================================================================================
PROCEDURE NAME:		[log4].[PrintString]
DESCRIPTION:		Prints the supplied string respecting all line feeds and/or carriage returns except where no
					line feeds are found, in which case the output is printed in user-specified lengths
DATE OF ORIGIN:		05-NOV-2011
ORIGINAL AUTHOR:	Greg M. Lucas (data-centric solutions ltd. http://www.data-centric.co.uk)
BUILD DATE:			13-MAR-2012
BUILD VERSION:		0.0.10
DEPENDANTS:			None
DEPENDENCIES:		None

Inputs
======
@InputString - optional, the string to print
@MaxPrintLength - Max length of string to print before inserting an unnatural break

Outputs
=======
None

Returns
=======
NULL

Additional Notes
================

Revision history
=====================================================================================================================
ChangeDate    Author   Version  Narrative
============  =======  =======  =====================================================================================
05-NOV-2011   GML      v0.0.8   Created
------------  -------  -------  -------------------------------------------------------------------------------------
13-MAR-2012   GML      v0.0.10  Fixed backwards-compatability issue with @LineFeedPos
------------  -------  -------  -------------------------------------------------------------------------------------


=====================================================================================================================
(C) Copyright 2006-12 data-centric solutions ltd. (http://log4tsql.sourceforge.net/)

This library is free software; you can redistribute it and/or modify it under the terms of the
GNU Lesser General Public License as published by the Free Software Foundation (www.fsf.org);
either version 3.0 of the License, or (at your option) any later version.

This library is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;
without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
See the GNU Lesser General Public License for more details.

You should have received a copy of the GNU Lesser General Public License along with this
library; if not, you can find it at http://www.opensource.org/licenses/lgpl-3.0.html
or http://www.gnu.org/licenses/lgpl.html

**********************************************************************************************************************/
--</CommentHeader>

BEGIN
	SET NOCOUNT ON

	--! CONSTANTS (keep it SQL2005 compatible)
	DECLARE @LF					char		(    1 ); SET @LF			= CHAR(10);
	DECLARE @CR					char		(    1 ); SET @CR			= CHAR(13);
	DECLARE @CRLF				char		(    2 ); SET @CRLF			= CHAR(13) + CHAR(10);
	DECLARE @LINE_BREAK			char		(    3 ); SET @LINE_BREAK	= '%' + @LF + '%';

	--! Working Values
	DECLARE @WorkingLength		bigint
	DECLARE @WorkingString		nvarchar		(  max )
	DECLARE @SubString			nvarchar		(  max )
	DECLARE @SubStringLength	bigint

	--! Validate/correct inputs
	SET @MaxPrintLength = COALESCE(NULLIF(@MaxPrintLength, 0), 4000)

	IF @MaxPrintLength > 4000
		BEGIN
			RAISERROR('The @MaxPrintLength value of %i is greater than the maximum length supported by PRINT for nvarchar strings (4000)', 17, 1, @MaxPrintLength);
			RETURN(60000);
		END

	IF @MaxPrintLength < 1
		BEGIN
			RAISERROR('The @MaxPrintLength must be greater than or equal to 1 but is %i', 17, 2, @MaxPrintLength);
			RETURN(60000);
		END

	--! Working variables
	DECLARE @InputLength bigint; SET @InputLength = LEN(@InputString);

	IF @InputLength = 0
		GOTO OnComplete;

	--!
	--! Our input string may contain either carriage returns, line feeds or both
	--! to separate printing lines so we need to standardise on one of these (LF)
	--!
	SET @WorkingString = REPLACE(REPLACE(@InputString, @CRLF, @LF), @CR, @LF);

	--!
	--! If there are line feeds we use those to break down the text
	--! into individual printed lines, otherwise we print it in
	--! bite-size chunks suitable for consumption by PRINT
	--!
	IF PATINDEX(@LINE_BREAK, @InputString) > 0

		BEGIN --[BREAK_BY_LINE_FEED]

			--! Add a line feed on the end so the final iteration works as expected
			SET @WorkingString	= @WorkingString + @LF;
			SET @WorkingLength	= LEN(@WorkingString);

			DECLARE @LineFeedPos bigint; SET @LineFeedPos = 0;

			WHILE @WorkingLength > 0
				BEGIN
					--!
					--! Get the position of the next line feed
					--!
					SET @LineFeedPos = PATINDEX(@LINE_BREAK, @WorkingString);

					IF @LineFeedPos > 0
						BEGIN
							SET @SubString			= SUBSTRING(@WorkingString, 1, @LineFeedPos - 1);
							SET @SubStringLength	= LEN(@SubString);

							--!
							--! If this string is too long for a single PRINT, we pass it back
							--! to PrintString which will process the string in suitably sized chunks
							--!
							IF LEN(@SubString) > @MaxPrintLength
								EXEC [log4].[PrintString] @InputString = @SubString
							ELSE
								PRINT @SubString;

							--! Remove the text we've just processed
							SET @WorkingLength	= @WorkingLength - @LineFeedPos;
							SET @WorkingString	= SUBSTRING(@WorkingString, @LineFeedPos + 1, @WorkingLength);
						END
				END

		END --[BREAK_BY_LINE_FEED]
	ELSE
		BEGIN --[BREAK_BY_LENGTH]
			--!
			--! If there are no line feeds we may have to break it down
			--! into smaller bit size chunks suitable for PRINT
			--!
			IF @InputLength > @MaxPrintLength
				BEGIN
					SET @WorkingString		= @InputString;
					SET @WorkingLength		= LEN(@WorkingString);
					SET @SubStringLength	= @MaxPrintLength;

					WHILE @WorkingLength > 0
						BEGIN
							SET @SubString			= SUBSTRING(@WorkingString, 1, @SubStringLength);
							SET @SubStringLength	= LEN(@SubString)

							--!
							--! If we still have text to process, set working values
							--!
							IF (@WorkingLength - @SubStringLength + 1) > 0
								BEGIN
									PRINT @SubString;
									--! Remove the text we've just processed
									SET @WorkingString	= SUBSTRING(@WorkingString, @SubStringLength + 1, @WorkingLength);
									SET @WorkingLength	= LEN(@WorkingString);
								END
						END
				END
			ELSE
				PRINT @InputString;

		END --[BREAK_BY_LENGTH]

--/////////////////////////////////////////////////////////////////////////////////////////////////
OnComplete:
--/////////////////////////////////////////////////////////////////////////////////////////////////

	SET NOCOUNT OFF

	RETURN

END
GO
PRINT N'Creating [log4].[JournalReader]...';


GO
/*************************************************************************************************/
--</MaintenanceHeader>

CREATE PROCEDURE [log4].[JournalReader]
(
  @StartDate			datetime				= NULL
, @EndDate				datetime				= NULL
, @TimeZoneOffset		smallint				= NULL
, @FunctionName			varchar		(  256 )	= NULL
, @FunctionSearchType	tinyint					= NULL
, @MessageText			varchar		(  512 )	= NULL
, @MessageSearchType	tinyint					= NULL
, @Task					varchar		(  128 )	= NULL
, @SeverityBitMask		smallint				= 8191 -- 8191 All Severities or 7167 to exclude debug
, @ResultSetSize		int						= NULL
)

AS

/**************************************************************************************************

Properties
==========
PROCEDURE NAME:		[log4].[JournalReader]
DESCRIPTION:		Returns all Journal entries matching the specified search criteria
DATE OF ORIGIN:		01-DEC-2006
ORIGINAL AUTHOR:	Greg M. Lucas (data-centric solutions ltd. http://www.data-centric.co.uk)
BUILD DATE:			13-MAR-2012
BUILD VERSION:		0.0.10
DEPENDANTS:			None
DEPENDENCIES:		None

Inputs
======
@DatabaseName
@FunctionName
@MessageText
@StepInFunction
@ExtraInfo
@Severity

Outputs
=======
None

Returns
=======
@@ERROR - always zero on success

Additional Notes
================
Severity Bits (for bitmask):

   1 -- Showstopper/Critical Failure
   2 -- Severe Failure
   4 -- Major Failure
   8 -- Moderate Failure
  16 -- Minor Failure
  32 -- Concurrency Violation
  64 -- Reserved for future Use
 128 -- Reserved for future Use
 256 -- Informational
 512 -- Success
1024 -- Debug
2048 -- Reserved for future Use
4096 -- Reserved for future Use

Function and Message Search Types:

0 = Exclude from Search
1 = Begins With
2 = Ends With
3 = Contains
4 = Exact Match

Revision history
==================================================================================================
ChangeDate		Author	Version		Narrative
============	======	=======		==============================================================
01-DEC-2006		GML		v0.0.1		Created
------------	------	-------		--------------------------------------------------------------
03-MAY-2011		GML		v0.0.4		Removed ExtraInfo from result set for performance
									Added @TimeZoneOffset for ease of use in other timezones
------------	------	-------		--------------------------------------------------------------
28-AUG-2011		GML		v0.0.6		Added support for ExceptionId and Task columns
------------	------	-------		--------------------------------------------------------------

=================================================================================================
(C) Copyright 2006-12 data-centric solutions ltd. (http://log4tsql.sourceforge.net/)

This library is free software; you can redistribute it and/or modify it under the terms of the
GNU Lesser General Public License as published by the Free Software Foundation (www.fsf.org);
either version 3.0 of the License, or (at your option) any later version.

This library is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;
without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
See the GNU Lesser General Public License for more details.

You should have received a copy of the GNU Lesser General Public License along with this
library; if not, you can find it at http://www.opensource.org/licenses/lgpl-3.0.html
or http://www.gnu.org/licenses/lgpl.html

**************************************************************************************************/

BEGIN
	SET TRANSACTION ISOLATION LEVEL READ UNCOMMITTED;
	SET NOCOUNT ON

	--! Working variables
	DECLARE	  @Error            int
			, @RowCount         int

	SET @Error 			= 0
	SET @TimeZoneOffset	= COALESCE(@TimeZoneOffset, 0)
	SET @Task			= COALESCE(@Task, '')

	--!
	--! Format the Function search string according to the required search criteria
	--!
	IF LEN(ISNULL(@FunctionName, '')) = 0 OR @FunctionSearchType = 0
		SET @FunctionName = '%'
	ELSE IF LEN(@FunctionName) < 256
		BEGIN
			IF @FunctionSearchType & 1 = 1 AND SUBSTRING(REVERSE(@FunctionName), 1, 1) != '%'
				SET @FunctionName = @FunctionName + '%'

			IF @FunctionSearchType & 2 = 2 AND SUBSTRING(@FunctionName, 1, 1) != '%'
				SET @FunctionName = '%' + @FunctionName

			--! If @FunctionSearchType = 4, do nothing as we want an exact match
		END

	--!
	--! Format the Message search string according to the required search criteria
	--!
	IF LEN(ISNULL(@MessageText, '')) = 0 OR @MessageSearchType = 0
		SET @MessageText = '%'
	ELSE IF LEN(@MessageText) < 512
		BEGIN
			IF @MessageSearchType & 1 = 1 AND SUBSTRING(REVERSE(@MessageText), 1, 1) != '%'
				SET @MessageText = @MessageText + '%'

			IF @MessageSearchType & 2 = 2 AND SUBSTRING(@MessageText, 1, 1) != '%'
				SET @MessageText = '%' + @MessageText

			--! If @MessageSearchType = 4, do nothing as we want an exact match
		END

	--!
	--! If @ResultSetSize is invalid, just return the last 100 rows
	--!
	IF ISNULL(@ResultSetSize, -1) < 1 SET @ResultSetSize = 100
	IF @StartDate IS NULL SET @StartDate = CONVERT(datetime, CONVERT(char(8), DATEADD(day, -7, GETDATE())) + ' 00:00:00', 112)
	IF @EndDate IS NULL SET @EndDate = CONVERT(datetime, CONVERT(char(8), GETDATE(), 112) + ' 23:59:59', 112)

	--! Reverse any time zone offset so we are searching on system time
	SET @StartDate	= DATEADD(hour, @TimeZoneOffset * -1, @StartDate)
	SET @EndDate	= DATEADD(hour, @TimeZoneOffset * -1, @EndDate)

	--!
	--! Return the required results
	--!
	SELECT TOP (@ResultSetSize)
		  j.JournalId
		, DATEADD(hour, @TimeZoneOffset, j.SystemDate)	AS [LocalTime]
		---------------------------------------------------------------------------------------------------
		, j.Task										AS [TaskOrJobName]
		, j.FunctionName								AS [FunctionName]
		, j.StepInFunction								AS [StepInFunction]
		, j.MessageText									AS [MessageText]
		, s.SeverityName								AS [Severity]
		, j.ExceptionId									AS [ExceptionId]
		---------------------------------------------------------------------------------------------------
		, j.SystemDate
	FROM
		[log4].[Journal] AS [j]
	INNER JOIN
		[log4].[Severity] AS [s]
	ON
		s.SeverityId = j.SeverityId
	WHERE
		j.SystemDate BETWEEN @StartDate AND @EndDate
	AND
		j.SeverityId & @SeverityBitMask = j.SeverityId
	AND
		j.Task = COALESCE(NULLIF(@Task, ''), j.Task)
	AND
		j.FunctionName LIKE @FunctionName
	AND
		j.MessageText LIKE @MessageText
	ORDER BY
		j.JournalId DESC

	SELECT @Error = @@ERROR, @RowCount = @@ROWCOUNT

--/////////////////////////////////////////////////////////////////////////////////////////////////
OnComplete:
--/////////////////////////////////////////////////////////////////////////////////////////////////

	SET NOCOUNT OFF

	RETURN(@Error)

END
GO
PRINT N'Creating [log4].[JournalPrinter]...';


GO
/*************************************************************************************************/
--</MaintenanceHeader>

CREATE PROCEDURE [log4].[JournalPrinter]
(
  @JournalId		int
)

AS

/**************************************************************************************************

Properties
==========
PROCEDURE NAME:		[log4].[JournalPrinter]
DESCRIPTION:		Prints the contents of JournalDetail for the specified Journal ID respecting all
					line feeds and/or carriage returns
DATE OF ORIGIN:		03-MAY-2011
ORIGINAL AUTHOR:	Greg M. Lucas (data-centric solutions ltd. http://www.data-centric.co.uk)
BUILD DATE:			13-MAR-2012
BUILD VERSION:		0.0.10
DEPENDANTS:			None
DEPENDENCIES:		None

Inputs
======
@JournalId - if -1, just processes any provided input string
@InputString - optional, the string to print

Outputs
=======
None

Returns
=======
NULL

Additional Notes
================

Revision history
==================================================================================================
ChangeDate		Author	Version		Narrative
============	======	=======		==============================================================
03-MAY-2011		GML		v0.0.4		Created
------------	------	-------		--------------------------------------------------------------
05-NOV-2011		GML		v0.0.8		Now calls log4.PrintString (which is SQL2005 compatible)
------------	------	-------		--------------------------------------------------------------

=================================================================================================
(C) Copyright 2006-12 data-centric solutions ltd. (http://log4tsql.sourceforge.net/)

This library is free software; you can redistribute it and/or modify it under the terms of the
GNU Lesser General Public License as published by the Free Software Foundation (www.fsf.org);
either version 3.0 of the License, or (at your option) any later version.

This library is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;
without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
See the GNU Lesser General Public License for more details.

You should have received a copy of the GNU Lesser General Public License along with this
library; if not, you can find it at http://www.opensource.org/licenses/lgpl-3.0.html
or http://www.gnu.org/licenses/lgpl.html

**************************************************************************************************/

BEGIN
	SET TRANSACTION ISOLATION LEVEL READ UNCOMMITTED;
	SET NOCOUNT ON;

	--! Working Values
	DECLARE @WorkingString		varchar		(  max )

	SELECT @WorkingString = ExtraInfo FROM [log4].[JournalDetail] WHERE JournalId = @JournalId

	IF COALESCE(@WorkingString, '') = ''
		BEGIN
			RAISERROR('No Extra Info for Journal ID: %d!', 0, 1, @JournalId);
		END
	ELSE
		BEGIN
			PRINT '';
			PRINT REPLICATE('=', 120);

			EXEC [log4].[PrintString] @WorkingString

			PRINT '';
			PRINT REPLICATE('=', 120);
			RAISERROR('Completed processing journal detail for Journal ID: %d', 0, 1, @JournalId) WITH NOWAIT;
		END

	SET NOCOUNT OFF;

	RETURN;
END
GO
PRINT N'Creating [log4].[ExceptionReader]...';


GO
/*************************************************************************************************/
--</MaintenanceHeader>

CREATE PROCEDURE [log4].[ExceptionReader]
(
  @StartDate			datetime				= NULL
, @EndDate				datetime				= NULL
, @TimeZoneOffset		smallint				= NULL
, @ErrorProcedure		varchar		(  256 )	= NULL
, @ProcedureSearchType	tinyint					= NULL
, @ErrorMessage			varchar		(  512 )	= NULL
, @MessageSearchType	tinyint					= NULL
, @ResultSetSize		int						= NULL
)

AS

/**************************************************************************************************

Properties
==========
PROCEDURE NAME:		[log4].[ExceptionReader]
DESCRIPTION:		Returns all Exceptions matching the specified search criteria
DATE OF ORIGIN:		01-DEC-2006
ORIGINAL AUTHOR:	Greg M. Lucas (data-centric solutions ltd. http://www.data-centric.co.uk)
BUILD DATE:			29-AUG-2011
BUILD VERSION:		0.0.6
DEPENDANTS:			None
DEPENDENCIES:		None

Returns
=======
@@ERROR - always zero on success

Additional Notes
================

Function and Message Search Types:

0 = Exclude from Search
1 = Begins With
2 = Ends With
3 = Contains
4 = Exact Match

Revision history
==================================================================================================
ChangeDate		Author	Version		Narrative
============	======	=======		==============================================================
01-DEC-2006		GML		v0.0.1		Created
------------	------	-------		--------------------------------------------------------------
03-MAY-2011		GML		v0.0.4		Added @TimeZoneOffset for ease of use in other timezones
------------	------	-------		--------------------------------------------------------------

=================================================================================================
(C) Copyright 2006-12 data-centric solutions ltd. (http://log4tsql.sourceforge.net/)

This library is free software; you can redistribute it and/or modify it under the terms of the
GNU Lesser General Public License as published by the Free Software Foundation (www.fsf.org);
either version 3.0 of the License, or (at your option) any later version.

This library is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;
without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
See the GNU Lesser General Public License for more details.

You should have received a copy of the GNU Lesser General Public License along with this
library; if not, you can find it at http://www.opensource.org/licenses/lgpl-3.0.html
or http://www.gnu.org/licenses/lgpl.html

**************************************************************************************************/

BEGIN
	SET TRANSACTION ISOLATION LEVEL READ UNCOMMITTED;
	SET NOCOUNT ON;

	--! Working variables
	DECLARE	  @Error            int
			, @RowCount         int

	SET @Error 			= 0
	SET @TimeZoneOffset	= COALESCE(@TimeZoneOffset, 0)

	--!
	--! Format the Function search string according to the required search criteria
	--!
	IF LEN(ISNULL(@ErrorProcedure, '')) = 0 OR @ProcedureSearchType = 0
		SET @ErrorProcedure = '%'
	ELSE IF LEN(@ErrorProcedure) < 256
		BEGIN
			IF @ProcedureSearchType & 1 = 1 AND SUBSTRING(REVERSE(@ErrorProcedure), 1, 1) != '%'
				SET @ErrorProcedure = @ErrorProcedure + '%'

			IF @ProcedureSearchType & 2 = 2 AND SUBSTRING(@ErrorProcedure, 1, 1) != '%'
				SET @ErrorProcedure = '%' + @ErrorProcedure

			--! If @ProcedureSearchType = 4, do nothing as we want an exact match
		END

	--!
	--! Format the Message search string according to the required search criteria
	--!
	IF LEN(ISNULL(@ErrorMessage, '')) = 0 OR @MessageSearchType = 0
		SET @ErrorMessage = '%'
	ELSE IF LEN(@ErrorMessage) < 512
		BEGIN
			IF @MessageSearchType & 1 = 1 AND SUBSTRING(REVERSE(@ErrorMessage), 1, 1) != '%'
				SET @ErrorMessage = @ErrorMessage + '%'

			IF @MessageSearchType & 2 = 2 AND SUBSTRING(@ErrorMessage, 1, 1) != '%'
				SET @ErrorMessage = '%' + @ErrorMessage

			--! If @MessageSearchType = 4, do nothing as we want an exact match
		END

	--!
	--! If @ResultSetSize is invalid, just return the last 100 rows
	--!
	IF ISNULL(@ResultSetSize, -1) < 1 SET @ResultSetSize = 100
	IF @StartDate IS NULL SET @StartDate = CONVERT(datetime, CONVERT(char(8), DATEADD(day, -10, GETDATE())) + ' 00:00:00', 112)
	IF @EndDate IS NULL SET @EndDate = CONVERT(datetime, CONVERT(char(8), GETDATE(), 112) + ' 23:59:59', 112)

	--! Reverse any time zone offset so we are searching on system time
	SET @StartDate	= DATEADD(hour, @TimeZoneOffset * -1, @StartDate)
	SET @EndDate	= DATEADD(hour, @TimeZoneOffset * -1, @EndDate)

	--!
	--! Return the required results
	--!
	SELECT TOP (@ResultSetSize)
		  ExceptionId
		, DATEADD(hour, @TimeZoneOffset, SystemDate)						AS [LocalTime]
		---------------------------------------------------------------------------------------------------
		, ErrorNumber
		, ErrorContext
		, REPLACE(REPLACE(ErrorMessage, CHAR(13), '  '), CHAR(10), '  ')	AS [ErrorMessage]
		, ErrorSeverity
		, ErrorState
		, ErrorProcedure
		, ErrorLine
		---------------------------------------------------------------------------------------------------
		, SystemDate
		, [SessionId]
		, [ProgramName]
		, [NTDomain]
		, [NTUsername]
		, [LoginName]
	FROM
		[log4].[Exception]
	WHERE
		SystemDate BETWEEN @StartDate AND @EndDate
	AND
		ErrorProcedure LIKE @ErrorProcedure
	AND
		ErrorMessage LIKE @ErrorMessage
	ORDER BY
		ExceptionId DESC

	SELECT @Error = @@ERROR, @RowCount = @@ROWCOUNT

--/////////////////////////////////////////////////////////////////////////////////////////////////
OnComplete:
--/////////////////////////////////////////////////////////////////////////////////////////////////

	SET NOCOUNT OFF

	RETURN(@Error)

END
GO
PRINT N'Creating [log4].[ExceptionHandler]...';


GO
/*************************************************************************************************/
--</MaintenanceHeader>

CREATE PROCEDURE [log4].[ExceptionHandler]
(
  @ErrorContext		nvarchar	(  512 )	= NULL
, @DatabaseName		nvarchar	(  128 )	= NULL	OUT
, @ErrorProcedure	nvarchar	(  128 )	= NULL	OUT
, @ErrorNumber		int						= NULL	OUT
, @ErrorSeverity	int						= NULL	OUT
, @ErrorState		int						= NULL	OUT
, @ErrorLine		int						= NULL	OUT
, @ErrorMessage		nvarchar	( 4000 )	= NULL	OUT
, @ReturnMessage	nvarchar	( 1000 )	= NULL	OUT
, @ExceptionId		int						= NULL	OUT
)
AS

--<CommentHeader>
/**********************************************************************************************************************

Properties
=====================================================================================================================
PROCEDURE NAME:		log4.ExceptionHandler
DESCRIPTION:		Returns error info as output parameters and writes info to Exception table
DATE OF ORIGIN:		01-DEC-2006
ORIGINAL AUTHOR:	Greg M. Lucas (data-centric solutions ltd. http://www.data-centric.co.uk)
BUILD DATE:			13-MAR-2012
BUILD VERSION:		0.0.10
DEPENDANTS:			Various
DEPENDENCIES:		log4.SessionInfoOutput

Outputs
=====================================================================================================================
Outputs all values collected within the CATCH block plus a formatted error message built from context and error msg

Returns
=====================================================================================================================
- @@ERROR - always zero on success


Additional Notes
=====================================================================================================================
-

Revision history
=====================================================================================================================
ChangeDate		Author	Version		Narrative
============	======	=======		=================================================================================
01-DEC-2006		GML		v0.0.1		Created
------------	------	-------		---------------------------------------------------------------------------------
15-APR-2008		GML		v0.0.3		Now utilises SessionInfoOutput sproc for session values
------------	------	-------		---------------------------------------------------------------------------------

=====================================================================================================================
(C) Copyright 2006-12 data-centric solutions ltd. (http://log4tsql.sourceforge.net/)

This library is free software; you can redistribute it and/or modify it under the terms of the
GNU Lesser General Public License as published by the Free Software Foundation (www.fsf.org);
either version 3.0 of the License, or (at your option) any later version.

This library is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;
without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
See the GNU Lesser General Public License for more details.

You should have received a copy of the GNU Lesser General Public License along with this
library; if not, you can find it at http://www.opensource.org/licenses/lgpl-3.0.html
or http://www.gnu.org/licenses/lgpl.html

**********************************************************************************************************************/
--</CommentHeader>

BEGIN
	SET NOCOUNT ON;

	SET @ErrorContext		= COALESCE(@ErrorContext, '');
	SET @DatabaseName		= COALESCE(@DatabaseName, DB_NAME());
	SET @ErrorProcedure		= COALESCE(NULLIF(@ErrorProcedure, ''), ERROR_PROCEDURE(), '');
	SET @ErrorNumber		= COALESCE(ERROR_NUMBER(), 0);
	SET @ErrorSeverity		= COALESCE(ERROR_SEVERITY(), 0);
	SET @ErrorState			= COALESCE(ERROR_STATE(), 0);
	SET @ErrorLine			= COALESCE(ERROR_LINE(), 0);
	SET @ErrorMessage		= COALESCE(ERROR_MESSAGE()
								, 'ERROR_MESSAGE() Not Found for @@ERROR: '
									+ COALESCE(CAST(ERROR_NUMBER() AS varchar(16)), 'NULL'));

	--!
	--! Generate a detailed, nicely formatted error message to return to the caller
	--!
	DECLARE @context nvarchar(512); SET @context = COALESCE(NULLIF(@ErrorContext, '') + ' due to ', 'ERROR! ');
	SET @ReturnMessage	= @context
						+ CASE
							WHEN LEN(ERROR_MESSAGE()) > (994 - LEN(@context))
								THEN '"' + SUBSTRING(@ErrorMessage, 1, (994 - LEN(@context))) + '..."'
							ELSE
								'"' + @ErrorMessage + '"'
						  END;

	--!
	--! Session variables (keep it SQL2005 compatible)
	--!
	DECLARE @SessionId	int					; SET @SessionId		= @@SPID;
	DECLARE @ServerName	nvarchar	( 128 )	; SET @ServerName		= @@SERVERNAME;

	--!
	--! log4.SessionInfoOutput variables
	--!
	DECLARE   @HostName				nvarchar	( 128 )
			, @ProgramName			nvarchar	( 128 )
			, @NTDomain				nvarchar	( 128 )
			, @NTUsername			nvarchar	( 128 )
			, @LoginName			nvarchar	( 128 )
			, @OriginalLoginName	nvarchar	( 128 )
			, @SessionLoginTime		datetime

	--! Working variables
	DECLARE @tblExceptionId         table	(ExceptionId int NOT NULL UNIQUE);

	--!
	--! Get the details for the current session
	--!
	EXEC log4.SessionInfoOutput
			  @SessionId			= @SessionId
			, @HostName				= @HostName				OUT
			, @ProgramName			= @ProgramName			OUT
			, @NTDomain				= @NTDomain				OUT
			, @NTUsername			= @NTUsername			OUT
			, @LoginName			= @LoginName			OUT
			, @OriginalLoginName	= @OriginalLoginName	OUT
			, @SessionLoginTime		= @SessionLoginTime		OUT

	--!
	--! Record what we have
	--!
	INSERT [log4].[Exception]
	(
	  [ErrorContext]
	, [ErrorNumber]
	, [ErrorSeverity]
	, [ErrorState]
	, [ErrorProcedure]
	, [ErrorLine]
	, [ErrorMessage]
	, [SessionId]
	, [ServerName]
	, [DatabaseName]
	, [HostName]
	, [ProgramName]
	, [NTDomain]
	, [NTUsername]
	, [LoginName]
	, [OriginalLoginName]
	, [SessionLoginTime]
	)
	OUTPUT inserted.ExceptionId INTO @tblExceptionId
	VALUES
	(
	  @ErrorContext
	, @ErrorNumber
	, @ErrorSeverity
	, @ErrorState
	, @ErrorProcedure
	, @ErrorLine
	, @ErrorMessage
	, @SessionId
	, @ServerName
	, @DatabaseName
	, @HostName
	, @ProgramName
	, @NTDomain
	, @NTUsername
	, @LoginName
	, @OriginalLoginName
	, @SessionLoginTime
	);

	SELECT @ExceptionId = ExceptionId FROM @tblExceptionId;

--/////////////////////////////////////////////////////////////////////////////////////////////////
OnComplete:
--/////////////////////////////////////////////////////////////////////////////////////////////////

	SET NOCOUNT OFF;

	RETURN;
END
GO
PRINT N'Creating [log4].[JournalWriter]...';


GO
/*************************************************************************************************/
--</MaintenanceHeader>

CREATE PROCEDURE [log4].[JournalWriter]
(
  @FunctionName			varchar		(  256 )
, @MessageText			varchar		(  512 )
, @ExtraInfo			varchar		(  max )	= NULL
, @DatabaseName			nvarchar	(  128 )	= NULL
, @Task					nvarchar	(  128 )	= NULL
, @StepInFunction		varchar		(  128 )	= NULL
, @Severity				smallint				= NULL
, @ExceptionId			int						= NULL
, @JournalId			int						= NULL OUT
)

AS

/**************************************************************************************************

Properties
==========
PROCEDURE NAME:		[log4].[JournalWriter]
DESCRIPTION:		Adds a journal entry summarising task progress, completion or failure msgs etc.
DATE OF ORIGIN:		01-DEC-2006
ORIGINAL AUTHOR:	Greg M. Lucas (data-centric solutions ltd. http://www.data-centric.co.uk)
BUILD DATE:			13-MAR-2012
BUILD VERSION:		0.0.10
DEPENDANTS:			Various
DEPENDENCIES:		[log4].[SessionInfoOutput]
					[log4].[ExceptionHandler]

Returns
=======
@@ERROR - always zero on success

Additional Notes
================
Possible options for @Severity

   1 -- Showstopper/Critical Failure
   2 -- Severe Failure
   4 -- Major Failure
   8 -- Moderate Failure
  16 -- Minor Failure
  32 -- Concurrency Violation
  64 -- Reserved for future Use
 128 -- Reserved for future Use
 256 -- Informational
 512 -- Success
1024 -- Debug
2048 -- Reserved for future Use
4096 -- Reserved for future Use



Revision history
==================================================================================================
ChangeDate		Author	Version		Narrative
============	======	=======		==============================================================
01-DEC-2006		GML		v0.0.1		Created
------------	------	-------		--------------------------------------------------------------
15-APR-2008		GML		v0.0.3		Now utilises [log4].[SessionInfoOutput] sproc for session values
------------	------	-------		--------------------------------------------------------------
03-MAY-2011		GML		v0.0.4		Added support for JournalDetail table
------------	------	-------		--------------------------------------------------------------
28-AUG-2011		GML		v0.0.6		Added support for ExceptionId and Task columns
------------	------	-------		--------------------------------------------------------------

=================================================================================================
(C) Copyright 2006-12 data-centric solutions ltd. (http://log4tsql.sourceforge.net/)

This library is free software; you can redistribute it and/or modify it under the terms of the
GNU Lesser General Public License as published by the Free Software Foundation (www.fsf.org);
either version 3.0 of the License, or (at your option) any later version.

This library is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;
without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
See the GNU Lesser General Public License for more details.

You should have received a copy of the GNU Lesser General Public License along with this
library; if not, you can find it at http://www.opensource.org/licenses/lgpl-3.0.html
or http://www.gnu.org/licenses/lgpl.html

**************************************************************************************************/

BEGIN
	SET NOCOUNT ON

	DECLARE @Error int; SET @Error = 0;

	--!
	--! Define input defaults
	--!
	SET @DatabaseName	= COALESCE(@DatabaseName, DB_NAME())
	SET @FunctionName	= COALESCE(@FunctionName, '')
	SET @StepInFunction	= COALESCE(@StepInFunction, '')
	SET @MessageText	= COALESCE(@MessageText, '')
	SET @ExtraInfo		= COALESCE(@ExtraInfo, '')
	SET @Task			= COALESCE(@Task, '')

	--! Make sure the supplied severity fits our bitmask model
	IF ISNULL(@Severity, 0) NOT IN (1, 2, 4, 8, 16, 32, 64, 128, 256, 512, 1024, 2048, 4096)
		BEGIN
			SET @ExtraInfo  = COALESCE(NULLIF(@ExtraInfo, '') + CHAR(13), '')
							+ '(Severity value: ' + COALESCE(CAST(@Severity AS varchar), 'NULL') + ' is invalid so using 256)'
			SET @Severity   = 256 -- Informational
		END

	--!
	--! Session variables (keep it SQL2005 compatible)
	--!
	DECLARE @SessionId	int					; SET @SessionId		= @@SPID;
	DECLARE @ServerName	nvarchar	( 128 )	; SET @ServerName		= @@SERVERNAME;

	--!
	--! log4.SessionInfoOutput variables
	--!
	DECLARE   @HostName				nvarchar	( 128 )
			, @ProgramName			nvarchar	( 128 )
			, @NTDomain				nvarchar	( 128 )
			, @NTUsername			nvarchar	( 128 )
			, @LoginName			nvarchar	( 128 )
			, @OriginalLoginName	nvarchar	( 128 )
			, @SessionLoginTime		datetime


	--!
	--! Get the details for the current session
	--!
	EXEC log4.SessionInfoOutput
			  @SessionId			= @SessionId
			, @HostName				= @HostName				OUT
			, @ProgramName			= @ProgramName			OUT
			, @NTDomain				= @NTDomain				OUT
			, @NTUsername			= @NTUsername			OUT
			, @LoginName			= @LoginName			OUT
			, @OriginalLoginName	= @OriginalLoginName	OUT
			, @SessionLoginTime		= @SessionLoginTime		OUT

	--! Working variables
	DECLARE @tblJournalId table	(JournalId int NOT NULL UNIQUE);

	BEGIN TRY
		INSERT [log4].[Journal]
		(
		  [Task]
		, [FunctionName]
		, [StepInFunction]
		, [MessageText]
		, [SeverityId]
		, [ExceptionId]
		------------------------
		, [SessionId]
		, [ServerName]
		, [DatabaseName]
		, [HostName]
		, [ProgramName]
		, [NTDomain]
		, [NTUsername]
		, [LoginName]
		, [OriginalLoginName]
		, [SessionLoginTime]
		)
	OUTPUT inserted.JournalId INTO @tblJournalId
	VALUES
		(
		  @Task
		, @FunctionName
		, @StepInFunction
		, @MessageText
		, @Severity
		, @ExceptionId
		------------------------
		, @SessionId
		, @ServerName
		, @DatabaseName
		, @HostName
		, @ProgramName
		, @NTDomain
		, @NTUsername
		, @LoginName
		, @OriginalLoginName
		, @SessionLoginTime
		)

		SELECT @JournalId = JournalId FROM @tblJournalId;

		INSERT [log4].[JournalDetail]
		(
		  JournalId
		, ExtraInfo
		)
		VALUES
		(
		  @JournalId
		, @ExtraInfo
		)

	END TRY
	BEGIN CATCH
		--!
		--! If we have an uncommitable transaction (XACT_STATE() = -1), if we hit a deadlock
		--! or if @@TRANCOUNT > 0 AND XACT_STATE() != 1, we HAVE to roll back.
		--! Otherwise, leaving it to the calling process
		--!
		IF (@@TRANCOUNT > 0 AND XACT_STATE() != 1) OR (XACT_STATE() = -1) OR (ERROR_NUMBER() = 1205)
			BEGIN
				ROLLBACK TRAN

				SET @MessageText    = 'Failed to write journal entry: '
									+ CASE
										WHEN LEN(@MessageText) > 440
											THEN '"' + SUBSTRING(@MessageText, 1, 440) + '..."'
										ELSE
											COALESCE('"' + @MessageText + '"', 'NULL')
										END
									+ ' (Forced roll back of all changes)'
			END
		ELSE
			BEGIN
				SET @MessageText    = 'Failed to write journal entry: '
									+ CASE
										WHEN LEN(@MessageText) > 475
											THEN '"' + SUBSTRING(@MessageText, 1, 475) + '..."'
										ELSE
											COALESCE('"' + @MessageText + '"', 'NULL')
										END
			END

		--! Record any failure info
		EXEC [log4].[ExceptionHandler]
				  @ErrorContext = @MessageText
				, @ErrorNumber  = @Error OUT
	END CATCH

--/////////////////////////////////////////////////////////////////////////////////////////////////
OnComplete:
--/////////////////////////////////////////////////////////////////////////////////////////////////

	SET NOCOUNT OFF

	RETURN(@Error)

END
GO
PRINT N'Creating [log4].[JournalCleanup]...';


GO
/*************************************************************************************************/
--</MaintenanceHeader>

CREATE PROCEDURE [log4].[JournalCleanup]
(
  @DaysToKeepJournal            int
, @DaysToKeepException			int
)

AS

/**************************************************************************************************

Properties
==========
PROCEDURE NAME:		[log4].[JournalCleanup]
DESCRIPTION:		Deletes all Journal and Exception entries older than the specified days
DATE OF ORIGIN:		16-FEB-2007
ORIGINAL AUTHOR:	Greg M. Lucas (data-centric solutions ltd. http://www.data-centric.co.uk)
BUILD DATE:			13-MAR-2012
BUILD VERSION:		0.0.10
DEPENDANTS:			None
DEPENDENCIES:		None

Inputs
======
@DatabaseName
@FunctionName
@MessageText
@StepInFunction
@ExtraInfo
@Severity

Outputs
=======
None

Returns
=======
@@ERROR - always zero on success

Additional Notes
================

Revision history
==================================================================================================
ChangeDate		Author	Version		Narrative
============	======	=======		==============================================================
16-FEB-2007		GML		v0.0.2		Created
------------	------	-------		--------------------------------------------------------------
29-AUG-2011		GML		v0.0.7		Added support for ExceptionId (now ensures that Exception
									deleted date is greater than Journa delete date)
------------	------	-------		--------------------------------------------------------------



=================================================================================================
(C) Copyright 2006-12 data-centric solutions ltd. (http://log4tsql.sourceforge.net/)

This library is free software; you can redistribute it and/or modify it under the terms of the
GNU Lesser General Public License as published by the Free Software Foundation (www.fsf.org);
either version 3.0 of the License, or (at your option) any later version.

This library is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;
without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
See the GNU Lesser General Public License for more details.

You should have received a copy of the GNU Lesser General Public License along with this
library; if not, you can find it at http://www.opensource.org/licenses/lgpl-3.0.html
or http://www.gnu.org/licenses/lgpl.html

**************************************************************************************************/

BEGIN
	SET NOCOUNT ON

	--! Standard/common variables
	DECLARE	  @_Error					int
			, @_RowCount				int
			, @_DatabaseName			nvarchar	(  128 )
			, @_DebugMessage			varchar		( 2000 )
			, @_SprocStartTime			datetime
			, @_StepStartTime			datetime

	--! WriteJournal variables
	DECLARE   @_FunctionName			varchar		(  256 )
			, @_Message					varchar		(  512 )
			, @_ProgressText			nvarchar	(  max )
			, @_Step					varchar		(  128 )
			, @_Severity				smallint

	--! ExceptionHandler variables
	DECLARE   @_CustomErrorText			varchar		(  512 )
			, @_ErrorMessage			varchar		( 4000 )
			, @_ExceptionId				int

	--! Common Debug variables
	DECLARE	  @_LoopStartTime			datetime
			, @_StepEndTime				datetime
			, @_CRLF					char		(    1 )

	--! Populate the common variables
	SET @_SprocStartTime	= GETDATE()
	SET @_FunctionName		= OBJECT_NAME(@@PROCID)
	SET @_DatabaseName		= DB_NAME()
	SET @_Error				= 0
	SET @_Severity			= 256 -- Informational
	SET @_CRLF				= CHAR(10)
	SET @_DebugMessage		= @_FunctionName + ' starting at ' + CONVERT(char(23), @_SprocStartTime, 121) + ' with inputs: '
							+ @_CRLF + '    @DaysToKeepJournal     : ' + COALESCE(CAST(@DaysToKeepJournal AS varchar), 'NULL')
							+ @_CRLF + '    @DaysToKeepException   : ' + COALESCE(CAST(@DaysToKeepException AS varchar), 'NULL')
	SET @_ProgressText		= @_DebugMessage

	--! Define our working values
	DECLARE @_DaysToKeepJournal		int;		SET @_DaysToKeepJournal = COALESCE(@DaysToKeepJournal, 30)
	DECLARE @_DaysToKeepException	int;		SET @_DaysToKeepException = COALESCE(@DaysToKeepException, @_DaysToKeepJournal + 1)
	DECLARE @_JournalArchiveDate	datetime;	SET @_JournalArchiveDate = CONVERT(char(11), DATEADD(day, - @_DaysToKeepJournal, GETDATE()), 113)
	DECLARE @_ExceptionArchiveDate	datetime;	SET @_ExceptionArchiveDate = CONVERT(char(11), DATEADD(day, - @_DaysToKeepException, GETDATE()), 113)

	SET @_ProgressText		= @_ProgressText
							+ @_CRLF + 'and working values...'
							+ @_CRLF + '    @_DaysToKeepJournal     : ' + COALESCE(CAST(@_DaysToKeepJournal AS varchar), 'NULL')
							+ @_CRLF + '    @_DaysToKeepException   : ' + COALESCE(CAST(@_DaysToKeepException AS varchar), 'NULL')
							+ @_CRLF + '    @_JournalArchiveDate   : ' + COALESCE(CONVERT(char(19), @_JournalArchiveDate, 120), 'NULL')
							+ @_CRLF + '    @_ExceptionArchiveDate : ' + COALESCE(CONVERT(char(19), @_ExceptionArchiveDate, 120), 'NULL')

	--!
	--!
	--!
	BEGIN TRY
		SET @_Step = 'Validate inputs';

		--!
		--! There is an FK between Journal and Exception so we can't delete more from Exception
		--! than we do from Journal
		--!
		IF @_JournalArchiveDate >= @_ExceptionArchiveDate
			BEGIN
				SET @_Message	= 'Failed to clean up Journal and Exception tables as Journal delete Date: '
								+ COALESCE(CONVERT(char(19), @_JournalArchiveDate, 120), 'NULL')
								+ ' must be less than Exception delete date: '
								+ COALESCE(CONVERT(char(19), @_ExceptionArchiveDate, 120), 'NULL')
				RAISERROR(@_Message, 16, 1);
			END

		SET @_Step = 'Delete old Journal entries';
		SET @_StepStartTime = GETDATE();

		BEGIN TRAN

		--! Don't need to DELETE JournalDetail as FK cascades
		DELETE
			[log4].[Journal]
		WHERE
			SystemDate < @_JournalArchiveDate

		SET @_RowCount		= @@ROWCOUNT;
		SET @_DebugMessage	= 'Completed step: "' +  COALESCE(@_Step, 'NULL') + '"'
							+ ' in ' + [log4].[FormatElapsedTime](@_StepStartTime, NULL, 3)
							+ ' ' + COALESCE(CAST(@_RowCount AS varchar), 'NULL') + ' row(s) affected'
		SET @_ProgressText	= @_ProgressText + @_CRLF + @_DebugMessage

		IF  @@TRANCOUNT > 0 COMMIT TRAN
	END TRY
	BEGIN CATCH
		IF ABS(XACT_STATE()) = 1 OR @@TRANCOUNT > 0 ROLLBACK TRAN;

		SET @_CustomErrorText	= 'Failed to cleanup Journal and Exception at step: ' + COALESCE(@_Step, 'NULL')

		EXEC [log4].[ExceptionHandler]
				  @DatabaseName    = @_DatabaseName
				, @ErrorContext    = @_CustomErrorText
				, @ErrorProcedure  = @_FunctionName
				, @ErrorNumber     = @_Error OUT
				, @ReturnMessage   = @_Message OUT
				, @ExceptionId     = @_ExceptionId OUT

		GOTO OnComplete;
	END CATCH

	--!
	--!
	--!
	BEGIN TRY
		SET @_Step = 'Delete old Exception entries';
		SET @_StepStartTime = GETDATE();

		BEGIN TRAN

		DELETE
			[log4].[Exception]
		WHERE
			SystemDate < @_ExceptionArchiveDate

		SET @_RowCount		= @@ROWCOUNT;
		SET @_DebugMessage	= 'Completed step: "' +  COALESCE(@_Step, 'NULL') + '"'
							+ ' in ' + [log4].[FormatElapsedTime](@_StepStartTime, NULL, 3)
							+ ' ' + COALESCE(CAST(@_RowCount AS varchar), 'NULL') + ' row(s) affected'
		SET @_ProgressText	= @_ProgressText + @_CRLF + @_DebugMessage

		IF  @@TRANCOUNT > 0 COMMIT TRAN

		SET @_Message		= 'Completed all Journal and Exception cleanup activities;'
							+ ' retaining ' + COALESCE(CAST(@DaysToKeepJournal AS varchar), 'NULL') + ' days'' Journal entries'
							+ ' and ' + COALESCE(CAST(@DaysToKeepException AS varchar), 'NULL') + ' days'' Exception entries'
	END TRY
	BEGIN CATCH
		IF ABS(XACT_STATE()) = 1 OR @@TRANCOUNT > 0 ROLLBACK TRAN;

		SET @_CustomErrorText	= 'Failed to cleanup Journal and Exception at step: ' + COALESCE(@_Step, 'NULL')

		EXEC [log4].[ExceptionHandler]
				  @DatabaseName    = @_DatabaseName
				, @ErrorContext    = @_CustomErrorText
				, @ErrorProcedure  = @_FunctionName
				, @ErrorNumber     = @_Error OUT
				, @ReturnMessage   = @_Message OUT
				, @ExceptionId     = @_ExceptionId OUT

		GOTO OnComplete;
	END CATCH


--/////////////////////////////////////////////////////////////////////////////////////////////////
OnComplete:
--/////////////////////////////////////////////////////////////////////////////////////////////////

	IF @_Error = 0
		BEGIN
			SET @_Step			= 'OnComplete'
			SET @_Severity		= 512 -- Success
			SET @_Message		= COALESCE(@_Message, @_Step) + ' in a total run time of ' + [log4].[FormatElapsedTime](@_SprocStartTime, NULL, 3)
		END
	ELSE
		BEGIN
			SET @_Step			= COALESCE(@_Step, 'OnError')
			SET @_Severity		= 2 -- Severe Failure
			SET @_Message		= COALESCE(@_Message, @_Step) + ' after a total run time of ' + [log4].[FormatElapsedTime](@_SprocStartTime, NULL, 3)
		END

	--! Always log completion of this call
	EXEC [log4].[JournalWriter]
			  @FunctionName		= @_FunctionName
			, @StepInFunction	= @_Step
			, @MessageText		= @_Message
			, @ExtraInfo		= @_ProgressText
			, @DatabaseName		= @_DatabaseName
			, @Severity			= @_Severity
			, @ExceptionId		= @_ExceptionId

	--! Finaly, throw an exception that will be detected by SQL Agent
	IF @_Error > 0 RAISERROR(@_Message, 16, 1);

	SET NOCOUNT OFF;

	RETURN (@_Error);
END
GO
PRINT N'Creating [dbo].[dv_load_source_table_key_lookup]...';


GO
CREATE PROCEDURE [dbo].[dv_load_source_table_key_lookup]
(
  @vault_source_system_name             varchar(128) = NULL
, @vault_source_table_schema			varchar(128) = NULL
, @vault_source_table_name              varchar(128) = NULL
, @link_load_only						char(1) = 'N'  -- "Y" Indicates that this temp table is being used for a link load key lookup, not a Sat key Lookup.
, @vault_temp_table_name				varchar(116) OUTPUT
, @vault_sql_statement					nvarchar(max) OUTPUT
, @dogenerateerror                      bit		= 0
, @dothrowerror                         bit		= 1

)
AS
BEGIN
SET NOCOUNT ON

-- To Do - add Logging for the Payload Parameter
--         validate Parameters properly
--declare @sat_name varchar(100) =  'AdventureWorks2014_production_productinventory'

-- System Wide Defaults
-- Local Defaults Values
DECLARE @crlf											char(2) = CHAR(13) + CHAR(10)
-- Global Defaults
DECLARE
                 @def_global_lowdate                    datetime
				,@def_global_highdate                   datetime
				,@def_global_default_load_date_time     varchar(128)
                ,@def_global_failed_lookup_key          int
-- Hub Defaults
				,@def_hub_prefix                        varchar(128)
                ,@def_hub_schema                        varchar(128)
                ,@def_hub_filegroup                     varchar(128)
--Link Defaults
                ,@def_link_prefix                       varchar(128)
                ,@def_link_schema                       varchar(128)
                ,@def_link_filegroup                    varchar(128)
--Sat Defaults
                ,@def_sat_prefix                        varchar(128)
                ,@def_sat_schema                        varchar(128)
                ,@def_sat_filegroup                     varchar(128)
                ,@sat_start_date_col                    varchar(128)
                ,@sat_end_date_col                      varchar(128)

-- Object Specific Settings
-- Source Table
                ,@source_system                         varchar(128)
				,@source_database                       varchar(128)
                ,@source_schema                         varchar(128)
                ,@source_table                          varchar(128)
                ,@source_table_config_key               int
                ,@source_qualified_name                 varchar(512)
                ,@source_load_date_time                 varchar(128)
                ,@source_payload                        nvarchar(max)
-- Hub Table
                ,@hub_database                          varchar(128)
                ,@hub_schema                            varchar(128)
                ,@hub_table                             varchar(128)
                ,@hub_surrogate_keyname                 varchar(128)
                ,@hub_config_key                        int
                ,@hub_qualified_name                    varchar(512)
                ,@hubt_technical_columns                nvarchar(max)
-- Link Table
                ,@link_database                         varchar(128)
                ,@link_schema                           varchar(128)
                ,@link_table                            varchar(128)
                ,@link_surrogate_keyname                varchar(128)
                ,@link_config_key                       int
                ,@link_qualified_name                   varchar(512)
                ,@link_technical_columns                nvarchar(max)
                ,@link_lookup_joins                     nvarchar(max)
                ,@link_hub_keys                         nvarchar(max)
-- Sat Table
                ,@sat_database                          varchar(128)
                ,@sat_schema                            varchar(128)
                ,@sat_table                             varchar(128)
                ,@sat_surrogate_keyname                 varchar(128)
                ,@sat_config_key                        int
                ,@sat_link_hub_flag                     char(1)
				,@sat_duplicate_removal_threshold		int			
                ,@sat_qualified_name                    varchar(512)
                ,@sat_technical_columns                 nvarchar(max)
                ,@sat_payload                           nvarchar(max)





--  Working Storage
DECLARE @sat_insert_count								int
       ,@temp_table_name_001							varchar(116)
       ,@sql											nvarchar(max)
       ,@sql1											nvarchar(max)
       ,@sql2											nvarchar(max)
       ,@surrogate_key_match							nvarchar(max)
DECLARE @declare										nvarchar(512)   = ''
DECLARE @count_rows										nvarchar(256)   = ''
DECLARE @match_list										nvarchar(max)   = ''
DECLARE @value_list										nvarchar(max)   = ''
DECLARE @sat_column_list								nvarchar(max)   = ''
DECLARE @hub_column_list								nvarchar(max)   = ''

DECLARE @ParmDefinition									nvarchar(500);


DECLARE @wrk_link_joins									nvarchar(max)
DECLARE @wrk_hub_joins									nvarchar(max)
DECLARE @wrk_link_keys									nvarchar(max)

-- Log4TSQL Journal Constants
DECLARE @SEVERITY_CRITICAL								smallint = 1;
DECLARE @SEVERITY_SEVERE								smallint = 2;
DECLARE @SEVERITY_MAJOR									smallint = 4;
DECLARE @SEVERITY_MODERATE								smallint = 8;
DECLARE @SEVERITY_MINOR									smallint = 16;
DECLARE @SEVERITY_CONCURRENCY							smallint = 32;
DECLARE @SEVERITY_INFORMATION							smallint = 256;
DECLARE @SEVERITY_SUCCESS								smallint = 512;
DECLARE @SEVERITY_DEBUG									smallint = 1024;
DECLARE @NEW_LINE										char(1)  = CHAR(10);

-- Log4TSQL Standard/ExceptionHandler variables
DECLARE	@_Error											int
      , @_RowCount										int
      , @_Step											varchar(128)
      , @_Message										nvarchar(512)
      , @_ErrorContext									nvarchar(512)

-- Log4TSQL JournalWriter variables
DECLARE			  @_FunctionName                        varchar(255)
                , @_SprocStartTime                      datetime
                , @_JournalOnOff                        varchar(3)
                , @_Severity                            smallint
                , @_ExceptionId                         int
                , @_StepStartTime                       datetime
                , @_ProgressText                        nvarchar(max)

SET @_Error             = 0;
SET @_FunctionName      = OBJECT_NAME(@@PROCID);
SET @_Severity          = @SEVERITY_INFORMATION;
SET @_SprocStartTime    = sysdatetimeoffset();
SET @_ProgressText      = ''
SET @_JournalOnOff      = log4.GetJournalControl(@_FunctionName, 'HOWTO');  -- left Group Name as HOWTO for now.

-- set Log4TSQL Parameters for Logging:
SET @_ProgressText              = @_FunctionName + ' starting at ' + CONVERT(char(23), @_SprocStartTime, 121) + ' with inputs: '
                                                 + @NEW_LINE + '    @vault_source_system_name  : ' + COALESCE(@vault_source_system_name, 'NULL')
                                                 + @NEW_LINE + '    @vault_source_table_schema : ' + COALESCE(@vault_source_table_schema, 'NULL')
                                                 + @NEW_LINE + '    @vault_source_table_name   : ' + COALESCE(@vault_source_table_name, 'NULL')
                                                 + @NEW_LINE + '    @link_load_only            : ' + COALESCE(@link_load_only, 'NULL')
                                                 + @NEW_LINE + '    @DoGenerateError           : ' + COALESCE(CAST(@DoGenerateError AS varchar), 'NULL')
                                                 + @NEW_LINE + '    @DoThrowError              : ' + COALESCE(CAST(@DoThrowError AS varchar), 'NULL')
                                                 + @NEW_LINE

BEGIN TRY
SET @_Step = 'Generate any required error';
IF @DoGenerateError = 1
   select 1 / 0
SET @_Step = 'Validate inputs';

--IF (select count(*) from [dbo].[dv_sat] where sat_name = @sat_name) <> 1
--                      RAISERROR('Invalid sat Name: %s', 16, 1, @sat_name);
--IF isnull(@recreate_flag, '') not in ('Y', 'N')
--                      RAISERROR('Valid values for recreate_flag are Y or N : %s', 16, 1, @recreate_flag);
/*--------------------------------------------------------------------------------------------------------------*/
SET @_Step = 'Get Defaults'
-- System Wide Defaults
select
-- Global Defaults
 @def_global_lowdate                            = cast([dbo].[fn_get_default_value] ('LowDate','Global')              as datetime)
,@def_global_highdate                           = cast([dbo].[fn_get_default_value] ('HighDate','Global')             as datetime)
,@def_global_default_load_date_time				= cast([dbo].[fn_get_default_value] ('DefaultLoadDateTime','Global')  as varchar(128))
,@def_global_failed_lookup_key					= cast([dbo].[fn_get_default_value] ('FailedLookupKey', 'Global')     as integer)
-- Hub Defaults
,@def_hub_prefix                                = cast([dbo].[fn_get_default_value] ('prefix','hub')                  as varchar(128))
,@def_hub_schema                                = cast([dbo].[fn_get_default_value] ('schema','hub')                  as varchar(128))
,@def_hub_filegroup                             = cast([dbo].[fn_get_default_value] ('filegroup','hub')               as varchar(128))
-- Link Defaults
,@def_link_prefix                               = cast([dbo].[fn_get_default_value] ('prefix','lnk')                  as varchar(128))
,@def_link_schema                               = cast([dbo].[fn_get_default_value] ('schema','lnk')                  as varchar(128))
,@def_link_filegroup                            = cast([dbo].[fn_get_default_value] ('filegroup','lnk')               as varchar(128))
-- Sat Defaults
,@def_sat_prefix                                = cast([dbo].[fn_get_default_value] ('prefix','sat')                  as varchar(128))
,@def_sat_schema                                = cast([dbo].[fn_get_default_value] ('schema','sat')                  as varchar(128))
,@def_sat_filegroup                             = cast([dbo].[fn_get_default_value] ('filegroup','sat')               as varchar(128))

select @sat_start_date_col = quotename(column_name)
from [dbo].[dv_default_column]
where 1=1
and object_type = 'sat'
and object_column_type = 'Version_Start_Date'
select @sat_end_date_col = quotename(column_name)
from [dbo].[dv_default_column]
where 1=1
and object_type = 'sat'
and object_column_type = 'Version_End_Date'

-- Object Specific Settings
-- Source Table
select   @source_system                         = s.[source_system_name]
        ,@source_database                       = s.[timevault_name]
        ,@source_schema                         = t.[source_table_schema]
        ,@source_table                          = t.[source_table_name]
        ,@source_table_config_key				= t.[source_table_key]
        ,@source_qualified_name					= quotename(s.[timevault_name]) + '.' + quotename(t.[source_table_schema]) + '.' + quotename(t.[source_table_name])
from [dbo].[dv_source_system] s
inner join [dbo].[dv_source_table] t
on t.system_key = s.[source_system_key]
where 1=1
and s.[source_system_name]						= @vault_source_system_name
and t.[source_table_schema]						= @vault_source_table_schema
and t.[source_table_name]						= @vault_source_table_name

-- Satellite
select	   @sat_config_key						= sat.[satellite_key]
          ,@sat_link_hub_flag					= sat.[link_hub_satellite_flag]
		  ,@sat_duplicate_removal_threshold		= sat.[duplicate_removal_threshold]
from [dbo].[dv_source_table] t
inner join [dbo].[dv_column] c
on c.table_key = t.[source_table_key]
inner join [dbo].[dv_satellite_column] sc
on sc.column_key = c.column_key
inner join [dbo].[dv_satellite] sat
on sat.satellite_key = sc.satellite_key
where 1=1
and t.[source_table_key] = @source_table_config_key

-- Owner Hub Table
if @sat_link_hub_flag = 'H'
        select   @hub_database                  = h.[hub_database]
                ,@hub_schema                    = coalesce([hub_schema], @def_hub_schema, 'dbo')
                ,@hub_table                     = h.[hub_name]
                --,@hub_surrogate_keyname			= [dbo].[fn_get_object_name] ([dbo].[fn_get_object_name] ([hub_name], 'hub'),'HubSurrogate')
				,@hub_surrogate_keyname			= (select replace(replace(column_name, '[', ''), ']', '') from [dbo].[fn_get_key_definition](h.[hub_name], 'hub'))
                ,@hub_config_key                = h.[hub_key]
                ,@hub_qualified_name			= quotename([hub_database]) + '.' + quotename(coalesce([hub_schema], @def_hub_schema, 'dbo')) + '.' + quotename((select [dbo].[fn_get_object_name] ([hub_name], 'hub')))
        from [dbo].[dv_satellite] s
        inner join [dbo].[dv_hub] h
        on s.hub_key = h.hub_key
where 1=1
and s.[satellite_key] = @sat_config_key

-- Owner Link Table
if @sat_link_hub_flag = 'L'
begin
        select   @link_database                 = l.[link_database]
                ,@link_schema                   = coalesce(l.[link_schema], @def_link_schema, 'dbo')
                ,@link_table                    = l.[link_name]
                --,@link_surrogate_keyname		= [dbo].[fn_get_object_name] ([dbo].[fn_get_object_name] ([link_name], 'lnk'),'LnkSurrogate')
				,@link_surrogate_keyname		= (select replace(replace(column_name, '[', ''), ']', '') from [dbo].[fn_get_key_definition](l.[link_name], 'lnk'))
                ,@link_config_key               = l.[link_key]
                ,@link_qualified_name			= quotename([link_database]) + '.' + quotename(coalesce(l.[link_schema], @def_link_schema, 'dbo')) + '.' + quotename((select [dbo].[fn_get_object_name] ([link_name], 'lnk')))
        from [dbo].[dv_satellite] s
        inner join [dbo].[dv_link] l
        on s.link_key = l.link_key
    where 1=1
    and s.[satellite_key] = @sat_config_key

        set @link_lookup_joins = ''
        set @link_hub_keys = ''


declare @c_hub_key                      int
    ,@c_hub_name                        varchar(128)
    ,@c_hub_schema						varchar(128)
    ,@c_hub_database					varchar(128)
    ,@c_hub_abbreviation				varchar(4)


set @link_hub_keys		= ''
set @wrk_link_keys		= ''
set @link_lookup_joins	= ''
set @wrk_hub_joins		= ''

DECLARE c_hub_key CURSOR FOR
select h.[hub_key]
      ,h.[hub_name]
      ,h.[hub_schema]
      ,h.[hub_database]
      ,h.[hub_abbreviation]

  FROM [dbo].[dv_link] l
  inner join [dbo].[dv_hub_link] hl
  on hl.[link_key] = l.[link_key]
  inner join [dbo].[dv_hub] h
  on h.[hub_key] = hl.[hub_key]
  where 1=1
  and l.[link_key] = @link_config_key
  order by hl.hub_link_key
OPEN c_hub_key
FETCH NEXT FROM c_hub_key
INTO @c_hub_key
    ,@c_hub_name
    ,@c_hub_schema
    ,@c_hub_database
    ,@c_hub_abbreviation


WHILE @@FETCH_STATUS = 0
BEGIN
	    select @wrk_link_joins  = 'LEFT JOIN ' + quotename(@c_hub_database) + '.' + quotename(coalesce(@c_hub_schema, @def_hub_schema, 'dbo')) + '.' + quotename((select [dbo].[fn_get_object_name] (@c_hub_name, 'hub'))) + ' ' + @c_hub_abbreviation + @crlf + ' ON  '
        select @wrk_link_keys  += ' tmp.' + (select column_name from [dbo].[fn_get_key_definition](h.[hub_name], 'hub')) + 
				     		      ' = link.' + (select column_name from [dbo].[fn_get_key_definition](h.[hub_name], 'hub')) + @crlf + ' AND '
              ,@wrk_link_joins += @c_hub_abbreviation + '.' + quotename(hkc.[hub_key_column_name]) + ' = CAST(src.' + quotename(c.[column_name]) + ' as ' + [hub_key_column_type] + ')' + @crlf + ' AND '

        from [dbo].[dv_hub] h
        inner join [dbo].[dv_hub_key_column] hkc
        on h.hub_key = hkc.hub_key
        inner join [dbo].[dv_hub_column] hc
        on hc.hub_key_column_key = hkc.hub_key_column_key
        inner join [dbo].[dv_column] c
        on c.column_key = hc.column_key
        inner join [dbo].[dv_source_table] st
        on c.[table_key] = st.[source_table_key]
        where 1=1
        and h.hub_key = @c_hub_key
        and st.[source_table_key] = @source_table_config_key
        and c.discard_flag <> 1
        ORDER BY hkc.hub_key_ordinal_position

		select  @wrk_hub_joins += ', ' + @c_hub_abbreviation + '.' + (select column_name from [dbo].[fn_get_key_definition]([hub_name], 'hub'))  + @crlf
        from(
        select distinct hub_name--, hub_key_ordinal_position
        from [dbo].[dv_hub] h
        inner join [dbo].[dv_hub_key_column] hkc
        on h.hub_key = hkc.hub_key
        inner join [dbo].[dv_hub_column] hc
        on hc.hub_key_column_key = hkc.hub_key_column_key
        inner join [dbo].[dv_column] c
        on c.column_key = hc.column_key
        inner join [dbo].[dv_source_table] st
        on c.[table_key] = st.[source_table_key]
        where 1=1
        and h.hub_key = @c_hub_key
        and st.[source_table_key] = @source_table_config_key
        and c.discard_flag <> 1) hkc
        --ORDER BY hkc.hub_key_ordinal_position

        set @link_hub_keys = @link_hub_keys + @wrk_link_keys

		-------------------

        set @link_lookup_joins = @link_lookup_joins + left(@wrk_link_joins, len(@wrk_link_joins) - 4)
        FETCH NEXT FROM c_hub_key
        INTO @c_hub_key
                ,@c_hub_name
                ,@c_hub_schema
                ,@c_hub_database
                ,@c_hub_abbreviation
END

CLOSE c_hub_key
DEALLOCATE c_hub_key
select @wrk_link_keys = left(@wrk_link_keys, len(@wrk_link_keys) - 4)
end


---- Use either a date time from the source or the default
select @source_load_date_time = [column_name]
from [dbo].[dv_source_table] st
inner join [dbo].[dv_column] c
on st.[source_table_key] = c.table_key
where 1=1
and st.[source_table_key] = @source_table_config_key
and c.[is_source_date] = 1
--NB do not check Discard Flag here as the Date Column may not be included in the Sat.
if @@rowcount > 1 RAISERROR ('Source Table has Multiple Source Dates Defined',16,1);
select @source_load_date_time = isnull(@source_load_date_time, @def_global_default_load_date_time)

-- Build the Source Payload NB - needs to join to the Sat Table to get each satellite related to the source.
set @sql = ''
select @sql += 'src.' +quotename([column_name]) + @crlf +', '
from [dbo].[dv_column]
where 1=1
and [discard_flag] <> 1
and [table_key] = @source_table_config_key
order by source_ordinal_position
select @source_payload = left(@sql, len(@sql) -1)

---- Build the Sat Payload
set @sql = ''
select @sql += 'sat.' +quotename([column_name]) + @crlf +', '
from [dbo].[dv_default_column]
where 1=1
and object_column_type <> 'Object_Key'
and [object_type] = 'Sat'
order by [ordinal_position]
set @sat_technical_columns = @sql

---- Temp Tables

select @temp_table_name_001 = '##temp_001_' + replace(cast(newid() as varchar(50)), '-', '')

-- Build the SQL to obtain Surrogate Keys, before Merging the Sat.
-- HUB based

-- Get the Key Match
if @sat_link_hub_flag = 'H'
begin
        select @sql = ''
        select @sql += 'hub.' + quotename(hkc.[hub_key_column_name]) + ' = CAST(src.' + quotename(c.[column_name]) + ' as ' + [hub_key_column_type] + ')' + @crlf + ' AND '
        from [dbo].[dv_hub] h
        inner join [dbo].[dv_hub_key_column] hkc
        on h.hub_key = hkc.hub_key
        inner join [dbo].[dv_hub_column] hc
        on hc.hub_key_column_key = hkc.hub_key_column_key
        inner join [dbo].[dv_column] c
        on c.column_key = hc.column_key
        inner join [dbo].[dv_source_table] st
        on c.[table_key] = st.[source_table_key]
        where 1=1
        and h.hub_key = @hub_config_key
        and st.[source_table_key] = @source_table_config_key
        and c.discard_flag <> 1
        ORDER BY hkc.hub_key_ordinal_position
        select @surrogate_key_match =  left(@sql, len(@sql) - 4)
end

-- Compile the SQL
-- If it is a link, create the temp table with all Hub keys plus a dummy for the Link Keys.

set @sql1 = ''
if @sat_link_hub_flag = 'H'
        set @sql1 = 'SELECT ' + quotename(@hub_surrogate_keyname) + ' = isnull(hub.' + quotename(@hub_surrogate_keyname) + ', ' + cast(@def_global_failed_lookup_key as varchar(50)) + ')' + @crlf

if @sat_link_hub_flag = 'L'
    begin
        set @sql1 = 'SELECT ' + quotename(@link_surrogate_keyname) + ' = cast(0 as integer) ' + @crlf
        set @sql1 = @sql1 + @wrk_hub_joins
        end

if not (@link_load_only = 'Y' and @sat_link_hub_flag = 'L')
        set @sql1 = @sql1 + ', ' + @source_payload
set @sql1 = @sql1 + ', [vault_load_time] = ' + @source_load_date_time + @crlf
set @sql1 = @sql1 + ' INTO ' + @temp_table_name_001 + @crlf
set @sql1 = @sql1 + 'FROM ' + @source_qualified_name + ' src' + @crlf


if @sat_link_hub_flag = 'H'
        set @sql1 = @sql1 + 'LEFT JOIN ' + @hub_qualified_name + ' hub' + ' ON ' + @surrogate_key_match + @crlf

if @sat_link_hub_flag = 'L'
        set @sql1 = @sql1 + @link_lookup_joins
set @sql1 = @sql1 + ';' + @crlf

if (@sat_link_hub_flag = 'L' and @link_load_only <> 'Y')
        begin
        set @sql1 = @sql1 + @crlf + 'UPDATE tmp ' + @crlf
        set @sql1 = @sql1 + 'SET tmp.' + quotename(@link_surrogate_keyname) + ' = isnull(link.' + quotename(@link_surrogate_keyname) + ', ' + cast(@def_global_failed_lookup_key as varchar(50)) + ')' + @crlf
        set @sql1 = @sql1 + 'FROM ' + @temp_table_name_001 + ' tmp' + @crlf
        set @sql1 = @sql1 + 'LEFT JOIN ' + @link_qualified_name + ' link ' + @crlf + ' ON ' + @wrk_link_keys + ';'
        end

/****************************************************************************************************************************************/
-- Duplicate Checking
set @sql1 = @sql1 + @crlf

if (@sat_link_hub_flag = 'H' or (@sat_link_hub_flag = 'L' and @link_load_only <> 'Y'))
        begin
        if @sat_duplicate_removal_threshold > 0
        begin
        set @sql1 = @sql1 + 'select ''' + @temp_table_name_001 + ''' as global_temp_table_name, * into #t1 from ' + @temp_table_name_001 + ' where ' + case when @sat_link_hub_flag = 'H' then quotename(@hub_surrogate_keyname) else @link_surrogate_keyname end  + ' in( ' + @crlf
        set @sql1 = @sql1 + '        select top ' + cast(@sat_duplicate_removal_threshold + 1 as varchar) + case when @sat_link_hub_flag = 'H' then quotename(@hub_surrogate_keyname) else @link_surrogate_keyname end  + ' from '
                          + @temp_table_name_001 + ' group by ' + case when @sat_link_hub_flag = 'H' then quotename(@hub_surrogate_keyname) else @link_surrogate_keyname end  + ' having count(*) > 1)'  + @crlf
        set @sql1 = @sql1 + 'IF (select count(*) from #t1) > 0 ' + @crlf
        set @sql1 = @sql1 + '    begin' + @crlf
        set @sql1 = @sql1 + '    declare @xml1 varchar(max);' + @crlf
        set @sql1 = @sql1 + '    select  @xml1 = (select * from #t1 order by 2 for xml auto);' + @crlf
        set @sql1 = @sql1 + '    EXECUTE [log4].[JournalWriter]  @FunctionName = ''' + @_FunctionName + ''''
                                                            + ', @MessageText = ''Duplicate Keys Removed while Loading - ' + @source_qualified_name + ' - See [log4].[JournalDetail] for details'''
                                                            + ', @ExtraInfo = @xml1'
                                                            + ', @DatabaseName = ''' + @source_database + ''''
                                                            + ', @Task = ''Key Lookup before Loading Source Table'''
                                                            + ', @StepInFunction = ''Remove Duplicates before Loading Source Table'''
                                                            + ', @Severity = 256'
                                                            + ', @ExceptionId = 3601;' + @crlf

        set @sql1 = @sql1 + '    IF (select count(*) from #t1) >  ' + cast(@sat_duplicate_removal_threshold as varchar) + @crlf
        set @sql1 = @sql1 + '        raiserror (''Duplicate Keys Detected while Loading ' + @source_qualified_name + '''' + ', 16, 1)' + @crlf
        set @sql1 = @sql1 + '    else' + @crlf
        set @sql1 = @sql1 + '    DELETE FROM ' + @temp_table_name_001 + ' WHERE ' + case when @sat_link_hub_flag = 'H' then quotename(@hub_surrogate_keyname) else @link_surrogate_keyname end  + ' IN(' + @crlf
        set @sql1 = @sql1 + '           select distinct ' +  case when @sat_link_hub_flag = 'H' then quotename(@hub_surrogate_keyname) else @link_surrogate_keyname end  + ' FROM #t1); ' + @crlf
        set @sql1 = @sql1 + '    end' + @crlf

        end
        else
                set @sql1 = @sql1 + 'if exists (select 1 from ' + @temp_table_name_001 + ' group by ' + case when @sat_link_hub_flag = 'H' then quotename(@hub_surrogate_keyname) else @link_surrogate_keyname end  + ' having count(*) > 1)' + @crlf + '    raiserror (''Duplicate Keys Detected while Loading ' + @source_qualified_name + '''' + ', 16, 1)' + @crlf + @crlf
        end
/****************************************************************************************************************************************/

set @vault_sql_statement        = @sql1
select @vault_temp_table_name   = @temp_table_name_001
IF @_JournalOnOff = 'ON' SET @_ProgressText = @crlf + @vault_sql_statement + @crlf
/*--------------------------------------------------------------------------------------------------------------*/
--SET @_Step = 'Load The ' + case when @sat_link_hub_flag = 'H' then 'Hub' else 'Link' end
--IF @_JournalOnOff = 'ON'
--      SET @_ProgressText += @sql
--print @vault_sql_statement
--EXECUTE sp_executesql @SQL;
/*--------------------------------------------------------------------------------------------------------------*/

SET @_ProgressText  = @_ProgressText + @NEW_LINE
                                + 'Step: [' + @_Step + '] completed '

IF @@TRANCOUNT > 0 COMMIT TRAN;

SET @_Message   = 'Successfully Loaded Keys For: ' + @source_qualified_name

END TRY
BEGIN CATCH
SET @_ErrorContext      = 'Failed to Load Keys For: ' + @source_qualified_name
IF (XACT_STATE() = -1) -- uncommitable transaction
OR (@@TRANCOUNT > 0 AND XACT_STATE() != 1) -- undocumented uncommitable transaction
        BEGIN
                ROLLBACK TRAN;
                SET @_ErrorContext = @_ErrorContext + ' (Forced rolled back of all changes)';
        END

EXEC log4.ExceptionHandler
                  @ErrorContext  = @_ErrorContext
                , @ErrorNumber   = @_Error OUT
                , @ReturnMessage = @_Message OUT
                , @ExceptionId   = @_ExceptionId OUT
;
END CATCH

--/////////////////////////////////////////////////////////////////////////////////////////////////
OnComplete:
--/////////////////////////////////////////////////////////////////////////////////////////////////

        --! Clean up

        --!
        --! Use dbo.udf_FormatElapsedTime() to get a nicely formatted run time string e.g.
        --! "0 hr(s) 1 min(s) and 22 sec(s)" or "1345 milliseconds"
        --!
        IF @_Error = 0
                BEGIN
                        SET @_Step                      = 'OnComplete'
                        SET @_Severity          = @SEVERITY_SUCCESS
                        SET @_Message           = COALESCE(@_Message, @_Step)
                                                                + ' in a total run time of ' + log4.FormatElapsedTime(@_SprocStartTime, NULL, 3)
                        SET @_ProgressText  = @_ProgressText + @NEW_LINE + @_Message;
                END
        ELSE
                BEGIN
                        SET @_Step                      = COALESCE(@_Step, 'OnError')
                        SET @_Severity          = @SEVERITY_SEVERE
                        SET @_Message           = COALESCE(@_Message, @_Step)
                                                                + ' after a total run time of ' + log4.FormatElapsedTime(@_SprocStartTime, NULL, 3)
                        SET @_ProgressText  = @_ProgressText + @NEW_LINE + @_Message;
                END

        IF @_JournalOnOff = 'ON'
                EXEC log4.JournalWriter
                                  @Task                         = @_FunctionName
                                , @FunctionName         = @_FunctionName
                                , @StepInFunction       = @_Step
                                , @MessageText          = @_Message
                                , @Severity                     = @_Severity
                                , @ExceptionId          = @_ExceptionId
                                --! Supply all the progress info after we've gone to such trouble to collect it
                                , @ExtraInfo        = @_ProgressText

        --! Finally, throw an exception that will be detected by the caller
        IF @DoThrowError = 1 AND @_Error > 0
                RAISERROR(@_Message, 16, 99);

        SET NOCOUNT OFF;

        --! Return the value of @@ERROR (which will be zero on success)
        RETURN (@_Error);
END
GO
PRINT N'Creating [dbo].[dv_load_hub_table]...';


GO
CREATE PROCEDURE [dbo].[dv_load_hub_table]
(
  @vault_source_system		varchar(128)	= NULL
, @vault_source_schema		varchar(128)	= NULL
, @vault_source_table		varchar(128)	= NULL
, @vault_database			varchar(128)	= NULL
, @vault_hub_name			varchar(128)	= NULL
, @dogenerateerror			bit				= 0
, @dothrowerror				bit				= 1
)
AS
BEGIN
SET NOCOUNT ON

-- To Do - add Logging for the Payload Parameter
--         validate Parameters properly
--declare @hub_name varchar(100) =  'AdventureWorks2014_production_productinventory'

DECLARE @dv_load_date_time_column	varchar(128)
DECLARE @dv_load_date_time			varchar(128) 
DECLARE @dv_data_source_column		varchar(128)
DECLARE @dv_data_source_key			int
DECLARE @dv_timevault_name			varchar(128)
DECLARE @hub_name					varchar(128) 
DECLARE @hub_table_name				varchar(128) 
DECLARE @default_load_date_time		varchar(128)
DECLARE @hub_load_date_time			varchar(128)
DECLARE @hub_insert_count			int

DECLARE @crlf char(2) = CHAR(13) + CHAR(10)

DECLARE @declare			nvarchar(512) = ''
DECLARE @count_rows			nvarchar(256) = ''
DECLARE @match_list			nvarchar(4000) = ''
DECLARE @value_list			nvarchar(4000) = ''
DECLARE @hub_column_list	nvarchar(4000) = ''
DECLARE @source_column_list nvarchar(4000) = ''
DECLARE @SQL1				nvarchar(4000) = ''
DECLARE @SQL2				nvarchar(4000) = '' 
DECLARE @SQL3				nvarchar(4000) = ''
DECLARE @SQL4				nvarchar(4000) = ''
DECLARE @SQL				nvarchar(4000) = ''
DECLARE @ParmDefinition		nvarchar(500);

-- Log4TSQL Journal Constants 
DECLARE @SEVERITY_CRITICAL      smallint = 1;
DECLARE @SEVERITY_SEVERE        smallint = 2;
DECLARE @SEVERITY_MAJOR         smallint = 4;
DECLARE @SEVERITY_MODERATE      smallint = 8;
DECLARE @SEVERITY_MINOR         smallint = 16;
DECLARE @SEVERITY_CONCURRENCY   smallint = 32;
DECLARE @SEVERITY_INFORMATION   smallint = 256;
DECLARE @SEVERITY_SUCCESS       smallint = 512;
DECLARE @SEVERITY_DEBUG         smallint = 1024;
DECLARE @NEW_LINE               char(1)  = CHAR(10);

-- Log4TSQL Standard/ExceptionHandler variables
DECLARE	  @_Error         int
		, @_RowCount      int
		, @_Step          varchar(128)
		, @_Message       nvarchar(512)
		, @_ErrorContext  nvarchar(512)

-- Log4TSQL JournalWriter variables
DECLARE   @_FunctionName			varchar(255)
		, @_SprocStartTime			datetime
		, @_JournalOnOff			varchar(3)
		, @_Severity				smallint
		, @_ExceptionId				int
		, @_StepStartTime			datetime
		, @_ProgressText			nvarchar(max)

SET @_Error             = 0;
SET @_FunctionName      = OBJECT_NAME(@@PROCID);
SET @_Severity          = @SEVERITY_INFORMATION;
SET @_SprocStartTime    = sysdatetimeoffset();
SET @_ProgressText      = '' 
SET @_JournalOnOff      = log4.GetJournalControl(@_FunctionName, 'HOWTO');  -- left Group Name as HOWTO for now.


-- set the Parameters for logging:
SET @_ProgressText		= @_FunctionName + ' starting at ' + CONVERT(char(23), @_SprocStartTime, 121) + ' with inputs: '
						+ @NEW_LINE + '    @vault_source_system          : ' + COALESCE(@vault_source_system, '<NULL>')
						+ @NEW_LINE + '    @vault_source_schema          : ' + COALESCE(@vault_source_schema, '<NULL>')
						+ @NEW_LINE + '    @vault_source_table           : ' + COALESCE(@vault_source_table, '<NULL>')
						+ @NEW_LINE + '    @vault_database               : ' + COALESCE(@vault_database, '<NULL>')
						+ @NEW_LINE + '    @vault_hub_name               : ' + COALESCE(@vault_hub_name, '<NULL>')
						+ @NEW_LINE + '    @DoGenerateError              : ' + COALESCE(CAST(@DoGenerateError AS varchar), '<NULL>')
						+ @NEW_LINE + '    @DoThrowError                 : ' + COALESCE(CAST(@DoThrowError AS varchar), '<NULL>')
						+ @NEW_LINE

BEGIN TRY
SET @_Step = 'Generate any required error';
IF @DoGenerateError = 1
   select 1 / 0
SET @_Step = 'Validate inputs';

IF (select count(*) from [dbo].[dv_source_system] where @vault_source_system = [source_system_name] ) <> 1
			RAISERROR('Invalid @vault_source_system: %s', 16, 1, @vault_source_system);

/*--------------------------------------------------------------------------------------------------------------*/
SET @_Step = 'Get Defaults'

select @declare = 'DECLARE @rowcounts TABLE(merge_action nvarchar(10));' + @crlf
select @count_rows = 'OUTPUT $action into @rowcounts;' + @crlf + 'select @insertcount = count(*) from @rowcounts;'

select @hub_table_name				= [dbo].[fn_get_object_name](@vault_hub_name, 'hub') --from [dbo].[dv_hub] where hub_name = 'AdventureWorks2014_production_productinventory'
select @default_load_date_time		= [default_varchar] from [dbo].[dv_defaults]		where default_type = 'Global'	and default_subtype = 'DefaultLoadDateTime'
select @dv_load_date_time_column	= [column_name]		from [dbo].[dv_default_column]	where [object_type] = 'hub'		and object_column_type = 'Load_Date_Time'
select @dv_data_source_column		= [column_name]		from [dbo].[dv_default_column]	where [object_type] = 'hub'		and object_column_type = 'Data_Source'
select @dv_load_date_time			= c.column_name 
      ,@dv_data_source_key			= st.[source_table_key]
	  ,@dv_timevault_name			= s.timevault_name
from [dbo].[dv_source_system] s
inner join [dbo].[dv_source_table] st
on st.system_key = s.[source_system_key]
left join [dbo].[dv_column] c
on c.table_key = st.[source_table_key]
and c.[is_source_date] = 1
where 1=1
and s.source_system_name	= @vault_source_system
and st.source_table_schema	= @vault_source_schema
and st.source_table_name	= @vault_source_table
--and isnull(c.discard_flag, 0) <> 1
/*--------------------------------------------------------------------------------------------------------------*/
SET @_Step = 'Build SQL Components'

select @SQL1 = 'WITH wBaseSet AS (SELECT DISTINCT ' 
	  ,@source_column_list += quotename(c.[column_name]) +','
	  ,@SQL2 = 'FROM ' + quotename(s.[timevault_name]) + '.'+quotename([source_table_schema])+ '.'+quotename([source_table_name]) + ')' + @crlf 
			 + 'MERGE ' + quotename(h.[hub_database]) +'.'+quotename(h.[hub_schema])+'.'+ quotename(@hub_table_name) + ' WITH (HOLDLOCK) AS TARGET ' + @crlf
             + 'USING wBaseSet AS SOURCE' + @crlf + '  ON '
      ,@match_list += 'TARGET.' + quotename(hkc.[hub_key_column_name]) + ' = CAST(SOURCE.' + quotename(c.[column_name]) + ' as ' + [hub_key_column_type] + ')' + ' AND '
	  ,@SQL3 = @crlf + '  WHEN NOT MATCHED BY TARGET THEN ' + @crlf + 'INSERT(' + @dv_load_date_time_column + ',' + @dv_data_source_column + ',' 
	  ,@hub_column_list += hkc.hub_key_column_name + ','
	  ,@SQL4 = @crlf + 'VALUES(sysdatetimeoffset(),''' + cast(@dv_data_source_key as varchar(50)) + ''','
	  ,@value_list += 'CAST(SOURCE.' + quotename(c.[column_name]) + ' as ' + [hub_key_column_type] + ')'  + ',' 

from [dbo].[dv_hub] h
inner join [dbo].[dv_hub_key_column] hkc
on h.hub_key = hkc.hub_key
inner join [dbo].[dv_hub_column] hc
on hc.hub_key_column_key = hkc.hub_key_column_key
inner join [dbo].[dv_column] c
on c.column_key = hc.column_key
inner join [dbo].[dv_source_table] st
on c.[table_key] = st.[source_table_key]
inner join [dbo].[dv_source_system] s
on s.[source_system_key] = st.system_key
where 1=1
and h.hub_name				= @vault_hub_name
and h.hub_database			= @vault_database
and s.source_system_name	= @vault_source_system
and st.source_table_schema	= @vault_source_schema
and st.source_table_name	= @vault_source_table
and isnull(c.discard_flag, 0) <> 1
ORDER BY hkc.hub_key_ordinal_position 

/*--------------------------------------------------------------------------------------------------------------*/
SET @_Step = 'Combine the SQL Components'

select @SQL = replace(
          @declare
        + @SQL1
		+ left(@source_column_list, len(@source_column_list) -1) 
		+ @SQL2
		+ left(@match_list, len(@match_list) -4)
		+ @SQL3
		+ @hub_column_list + ')'
		+ @SQL4
		+ @value_list + ')'
		+ @count_rows
		, ',)', ')')



/*--------------------------------------------------------------------------------------------------------------*/
SET @_Step = 'Load The Hub'
IF @_JournalOnOff = 'ON' SET @_ProgressText  = @_ProgressText + @crlf + @SQL + @crlf
SET @ParmDefinition = N'@insertcount int OUTPUT';

 --print 'hub'
 --print @sql 

EXECUTE sp_executesql @SQL, @ParmDefinition, @insertcount = @hub_insert_count OUTPUT;
--select @hub_insert_count

/*--------------------------------------------------------------------------------------------------------------*/

SET @_ProgressText  = @_ProgressText + @NEW_LINE
				+ 'Step: [' + @_Step + '] completed ' 

IF @@TRANCOUNT > 0 COMMIT TRAN;

SET @_Message   = 'Successfully Loaded Object: ' + @hub_table_name + ' (' + cast(@hub_insert_count as varchar(50)) + ' New Keys Added)'

END TRY
BEGIN CATCH
SET @_ErrorContext	= 'Failed to Load Object: ' + @hub_table_name
IF (XACT_STATE() = -1) -- uncommitable transaction
OR (@@TRANCOUNT > 0 AND XACT_STATE() != 1) -- undocumented uncommitable transaction
	BEGIN
		ROLLBACK TRAN;
		SET @_ErrorContext = @_ErrorContext + ' (Forced rolled back of all changes)';
	END
	
EXEC log4.ExceptionHandler
		  @ErrorContext  = @_ErrorContext
		, @ErrorNumber   = @_Error OUT
		, @ReturnMessage = @_Message OUT
		, @ExceptionId   = @_ExceptionId OUT
;
END CATCH

--/////////////////////////////////////////////////////////////////////////////////////////////////
OnComplete:
--/////////////////////////////////////////////////////////////////////////////////////////////////

	--! Clean up

	--!
	--! Use dbo.udf_FormatElapsedTime() to get a nicely formatted run time string e.g.
	--! "0 hr(s) 1 min(s) and 22 sec(s)" or "1345 milliseconds"
	--!
	IF @_Error = 0
		BEGIN
			SET @_Step			= 'OnComplete'
			SET @_Severity		= @SEVERITY_SUCCESS
			SET @_Message		= COALESCE(@_Message, @_Step)
								+ ' in a total run time of ' + log4.FormatElapsedTime(@_SprocStartTime, NULL, 3)
			SET @_ProgressText  = @_ProgressText + @NEW_LINE + @_Message;
		END
	ELSE
		BEGIN
			SET @_Step			= COALESCE(@_Step, 'OnError')
			SET @_Severity		= @SEVERITY_SEVERE
			SET @_Message		= COALESCE(@_Message, @_Step)
								+ ' after a total run time of ' + log4.FormatElapsedTime(@_SprocStartTime, NULL, 3)
			SET @_ProgressText  = @_ProgressText + @NEW_LINE + @_Message;
		END

	IF @_JournalOnOff = 'ON'
		EXEC log4.JournalWriter
				  @Task				= @_FunctionName
				, @FunctionName		= @_FunctionName
				, @StepInFunction	= @_Step
				, @MessageText		= @_Message
				, @Severity			= @_Severity
				, @ExceptionId		= @_ExceptionId
				--! Supply all the progress info after we've gone to such trouble to collect it
				, @ExtraInfo        = @_ProgressText

	--! Finally, throw an exception that will be detected by the caller
	IF @DoThrowError = 1 AND @_Error > 0
		RAISERROR(@_Message, 16, 99);

	SET NOCOUNT OFF;

	--! Return the value of @@ERROR (which will be zero on success)
	RETURN (@_Error);
END
GO
PRINT N'Creating [dbo].[dv_load_link_table]...';


GO
CREATE PROCEDURE [dbo].[dv_load_link_table]
(
  @vault_source_system_name             varchar(256)    = NULL
, @vault_source_table_schema			varchar(256)    = NULL
, @vault_source_table_name              varchar(256)    = NULL
, @vault_database                       varchar(256)    = NULL
, @vault_link_name                      varchar(256)    = NULL
, @dogenerateerror                      bit             = 0
, @dothrowerror                         bit             = 1

)
AS
BEGIN
SET NOCOUNT ON

-- To Do - add Logging for the Payload Parameter
--         validate Parameters properly
--declare @sat_name varchar(100) =  'AdventureWorks2014_production_productinventory'

-- System Wide Defaults
-- Local Defaults Values
DECLARE @crlf	char(2)	= CHAR(13) + CHAR(10)
-- Global Defaults
DECLARE
         @def_global_lowdate									datetime
		,@def_global_highdate									datetime
        ,@def_global_default_load_date_time						varchar(128)
        ,@dv_load_date_time_column								varchar(128)
        ,@def_global_failed_lookup_key							int
-- Hub Defaults
        ,@def_hub_prefix                                        varchar(128)
        ,@def_hub_schema                                        varchar(128)
        ,@def_hub_filegroup                                     varchar(128)
--Link Defaults
        ,@def_link_prefix                                       varchar(128)
        ,@def_link_schema                                       varchar(128)
        ,@def_link_filegroup									varchar(128)
--Sat Defaults
        ,@def_sat_prefix                                        varchar(128)
        ,@def_sat_schema                                        varchar(128)
        ,@def_sat_filegroup                                     varchar(128)
        ,@sat_start_date_col									varchar(128)
        ,@sat_end_date_col                                      varchar(128)

-- Object Specific Settings
-- Source Table
        ,@source_system                                         varchar(128)
        ,@source_database                                       varchar(128)
        ,@source_schema                                         varchar(128)
        ,@source_table                                          varchar(128)
        ,@source_table_config_key								int
        ,@source_qualified_name									varchar(512)
        ,@source_load_date_time									varchar(128)
        ,@source_payload                                        varchar(max)
-- Hub Table
        ,@hub_database                                          varchar(128)
        ,@hub_schema                                            varchar(128)
        ,@hub_table                                              varchar(128)
        ,@hub_surrogate_keyname									varchar(128)
        ,@hub_config_key                                        int
        ,@hub_qualified_name									varchar(512)
        ,@hub_technical_columns									varchar(max)
-- Link Table
        ,@link_database                                         varchar(128)
        ,@link_schema                                           varchar(128)
        ,@link_table                                            varchar(128)
        ,@link_surrogate_keyname								varchar(128)
        ,@link_config_key                                       int
        ,@link_qualified_name									varchar(512)
        ,@link_technical_columns								nvarchar(max)
        --,@link_lookup_joins                                   nvarchar(max)
        ,@link_hub_keys                                         nvarchar(max)
-- Sat Table
        ,@sat_database                                          varchar(128)
        ,@sat_schema                                            varchar(128)
        ,@sat_table                                             varchar(128)
        ,@sat_surrogate_keyname									varchar(128)
        ,@sat_config_key                                        int
        ,@sat_link_hub_flag                                     char(1)
        ,@sat_qualified_name									varchar(512)
        ,@sat_technical_columns									nvarchar(max)
        ,@sat_payload                                           nvarchar(max)





--  Working Storage
DECLARE @sat_insert_count									int
       ,@temp_table_name									varchar(116)
       ,@sql                                                nvarchar(max)
       ,@sql1                                               nvarchar(max)
       ,@sql2                                               nvarchar(max)
       ,@surrogate_key_match								nvarchar(max)
DECLARE @declare											nvarchar(512)   = ''
DECLARE @count_rows											nvarchar(256)   = ''
DECLARE @match_list											nvarchar(max)   = ''
DECLARE @value_list											nvarchar(max)   = ''
DECLARE @sat_column_list									nvarchar(max)   = ''
DECLARE @hub_column_list									nvarchar(max)   = ''

DECLARE @ParmDefinition										nvarchar(500);
DECLARE @insert_count										int;

DECLARE @wrk_hub_joins										varchar(max)
DECLARE @wrk_link_keys										varchar(max)
DECLARE @wrk_link_match										varchar(max)
-- Log4TSQL Journal Constants
DECLARE @SEVERITY_CRITICAL									smallint = 1;
DECLARE @SEVERITY_SEVERE									smallint = 2;
DECLARE @SEVERITY_MAJOR										smallint = 4;
DECLARE @SEVERITY_MODERATE									smallint = 8;
DECLARE @SEVERITY_MINOR										smallint = 16;
DECLARE @SEVERITY_CONCURRENCY								smallint = 32;
DECLARE @SEVERITY_INFORMATION								smallint = 256;
DECLARE @SEVERITY_SUCCESS									smallint = 512;
DECLARE @SEVERITY_DEBUG										smallint = 1024;
DECLARE @NEW_LINE											char(1)  = CHAR(10);

-- Log4TSQL Standard/ExceptionHandler variables
DECLARE   @_Error											int
        , @_RowCount										int
        , @_Step											varchar(128)
        , @_Message											nvarchar(512)
        , @_ErrorContext									nvarchar(512)

-- Log4TSQL JournalWriter variables
DECLARE   @_FunctionName									varchar(255)
        , @_SprocStartTime									datetime
        , @_JournalOnOff									varchar(3)
        , @_Severity										smallint
        , @_ExceptionId										int
        , @_StepStartTime									datetime
        , @_ProgressText									nvarchar(max)

SET @_Error             = 0;
SET @_FunctionName      = OBJECT_NAME(@@PROCID);
SET @_Severity          = @SEVERITY_INFORMATION;
SET @_SprocStartTime    = sysdatetimeoffset();
SET @_ProgressText      = ''
SET @_JournalOnOff      = log4.GetJournalControl(@_FunctionName, 'HOWTO');  -- left Group Name as HOWTO for now.


-- set Log4TSQL Parameters for Logging:
SET @_ProgressText              = @_FunctionName + ' starting at ' + CONVERT(char(23), @_SprocStartTime, 121) + ' with inputs: '
                                                + @NEW_LINE + '    @vault_source_system          : ' + COALESCE(@source_system, 'NULL')
                                                + @NEW_LINE + '    @vault_source_table           : ' + COALESCE(@source_schema, 'NULL')
                                                + @NEW_LINE + '    @DoGenerateError              : ' + COALESCE(CAST(@DoGenerateError AS varchar), 'NULL')
                                                + @NEW_LINE + '    @DoThrowError                 : ' + COALESCE(CAST(@DoThrowError AS varchar), 'NULL')
                                                + @NEW_LINE

BEGIN TRY
SET @_Step = 'Generate any required error';
IF @DoGenerateError = 1
   select 1 / 0
SET @_Step = 'Validate inputs';

--IF (select count(*) from [dbo].[dv_sat] where sat_name = @sat_name) <> 1
--                      RAISERROR('Invalid sat Name: %s', 16, 1, @sat_name);
--IF isnull(@recreate_flag, '') not in ('Y', 'N')
--                      RAISERROR('Valid values for recreate_flag are Y or N : %s', 16, 1, @recreate_flag);
/*--------------------------------------------------------------------------------------------------------------*/
SET @_Step = 'Get Defaults'

--select @declare = 'DECLARE @rowcounts TABLE(merge_action nvarchar(10));' + @crlf
--select @count_rows = 'OUTPUT $action into @rowcounts;' + @crlf + 'select @insertcount = count(*) from @rowcounts;'

-- System Wide Defaults
select
-- Global Defaults
 @def_global_lowdate                            = cast([dbo].[fn_get_default_value] ('LowDate','Global')							as datetime)
,@def_global_highdate                           = cast([dbo].[fn_get_default_value] ('HighDate','Global')							as datetime)
,@def_global_default_load_date_time				= cast([dbo].[fn_get_default_value] ('DefaultLoadDateTime','Global')				as varchar(128))
,@def_global_failed_lookup_key					= cast([dbo].[fn_get_default_value] ('FailedLookupKey', 'Global')					as integer)

-- Hub Defaults
,@def_hub_prefix                                = cast([dbo].[fn_get_default_value] ('prefix','hub')                                as varchar(128))
,@def_hub_schema                                = cast([dbo].[fn_get_default_value] ('schema','hub')                                as varchar(128))
,@def_hub_filegroup                             = cast([dbo].[fn_get_default_value] ('filegroup','hub')								as varchar(128))
-- Link Defaults
,@def_link_prefix                               = cast([dbo].[fn_get_default_value] ('prefix','lnk')                                as varchar(128))
,@def_link_schema                               = cast([dbo].[fn_get_default_value] ('schema','lnk')                                as varchar(128))
,@def_link_filegroup							= cast([dbo].[fn_get_default_value] ('filegroup','lnk')								as varchar(128))
-- Sat Defaults
,@def_sat_prefix                                = cast([dbo].[fn_get_default_value] ('prefix','sat')                                as varchar(128))
,@def_sat_schema                                = cast([dbo].[fn_get_default_value] ('schema','sat')                                as varchar(128))
,@def_sat_filegroup                             = cast([dbo].[fn_get_default_value] ('filegroup','sat')								as varchar(128))

select @sat_start_date_col = quotename(column_name)
from [dbo].[dv_default_column]
where 1=1
and object_type = 'sat'
and object_column_type = 'Version_Start_Date'
select @sat_end_date_col = quotename(column_name)
from [dbo].[dv_default_column]
where 1=1
and object_type = 'sat'
and object_column_type = 'Version_End_Date'

-- Object Specific Settings
-- Source Table
select   @source_system                         = s.[source_system_name]
        ,@source_database                       = s.[timevault_name]
        ,@source_schema                         = t.[source_table_schema]
        ,@source_table                          = t.[source_table_name]
        ,@source_table_config_key				= t.[source_table_key]
        ,@source_qualified_name					= quotename(s.[timevault_name]) + '.' + quotename(t.[source_table_schema]) + '.' + quotename(t.[source_table_name])
from [dbo].[dv_source_system] s
inner join [dbo].[dv_source_table] t
on t.system_key = s.[source_system_key]
where 1=1
and s.[source_system_name]						= @vault_source_system_name
and t.[source_table_schema]						= @vault_source_table_schema
and t.[source_table_name]						= @vault_source_table_name

-- Get the Type Of Load - Hub or Link, together with Any Related Sat Key, for identifying the Surrogate Key Manager (Hub or Link).
-- The join goes via Column. Should be a direct relationship between source table and Sat - For RI Purposes, Plus for direct navigation , rather than inferring by Column.
select
           @sat_config_key = sat.[satellite_key]
          ,@sat_link_hub_flag = sat.[link_hub_satellite_flag]
from [dbo].[dv_source_table] t
inner join [dbo].[dv_column] c
on c.table_key = t.[source_table_key]
inner join [dbo].[dv_satellite_column] sc
on sc.column_key = c.column_key
inner join [dbo].[dv_satellite] sat
on sat.satellite_key = sc.satellite_key
where 1=1
and t.[source_table_key] = @source_table_config_key

-- Owner Hub Table
if @sat_link_hub_flag = 'H'
        select   @hub_database                  = h.[hub_database]
                ,@hub_schema                    = coalesce([hub_schema], @def_hub_schema, 'dbo')
                ,@hub_table                     = h.[hub_name]
 --               ,@hub_surrogate_keyname			= [dbo].[fn_get_object_name] ([dbo].[fn_get_object_name] ([hub_name], 'hub'),'HubSurrogate')
				,@hub_surrogate_keyname			= (select column_name from [dbo].[fn_get_key_definition]([hub_name], 'hub'))
                ,@hub_config_key                = h.[hub_key]
                ,@hub_qualified_name			= quotename([hub_database]) + '.' + quotename(coalesce([hub_schema], @def_hub_schema, 'dbo')) + '.' + quotename((select [dbo].[fn_get_object_name] ([hub_name], 'hub')))
        from [dbo].[dv_satellite] s
        inner join [dbo].[dv_hub] h
        on s.hub_key = h.hub_key
where 1=1
and s.[satellite_key] = @sat_config_key

-- Owner Link Table
if @sat_link_hub_flag = 'L'
begin
        select   @link_database                 = l.[link_database]
                ,@link_schema                   = coalesce(l.[link_schema], @def_link_schema, 'dbo')
                ,@link_table                    = l.[link_name]
                --,@link_surrogate_keyname		= [dbo].[fn_get_object_name] ([dbo].[fn_get_object_name] ([link_name], 'lnk'),'LnkSurrogate')
				,@link_surrogate_keyname		= (select column_name from [dbo].[fn_get_key_definition]([link_name], 'lnk'))
                ,@link_config_key               = l.[link_key]
                ,@link_qualified_name			= quotename([link_database]) + '.' + quotename(coalesce(l.[link_schema], @def_link_schema, 'dbo')) + '.' + quotename((select [dbo].[fn_get_object_name] ([link_name], 'lnk')))
        from [dbo].[dv_satellite] s
        inner join [dbo].[dv_link] l
        on s.link_key = l.link_key
    where 1=1
    and s.[satellite_key] = @sat_config_key
--set @link_hub_keys = ''

declare @c_hub_key							int
		,@c_hub_name                        varchar(128)
        ,@c_hub_schema						varchar(128)
        ,@c_hub_database					varchar(128)
        ,@c_hub_abbreviation				varchar(4)


set @link_hub_keys	= ''
set @wrk_link_keys	= ''
set @wrk_link_match = '' 
set @wrk_hub_joins	= ''

DECLARE c_hub_key CURSOR FOR
select h.[hub_key]
      ,h.[hub_name]
      ,h.[hub_schema]
      ,h.[hub_database]
      ,h.[hub_abbreviation]

  FROM [dbo].[dv_link] l
  inner join [dbo].[dv_hub_link] hl
  on hl.[link_key] = l.[link_key]
  inner join [dbo].[dv_hub] h
  on h.[hub_key] = hl.[hub_key]
  where 1=1
  and l.[link_key] = @link_config_key
  order by hl.hub_link_key
OPEN c_hub_key
FETCH NEXT FROM c_hub_key
INTO @c_hub_key
    ,@c_hub_name
    ,@c_hub_schema
    ,@c_hub_database
    ,@c_hub_abbreviation


WHILE @@FETCH_STATUS = 0
BEGIN
 
      --  select  @wrk_hub_joins   += quotename([dbo].[fn_get_object_name] ([dbo].[fn_get_object_name] ([hub_name], 'hub'),'HubSurrogate')) + ', '
      --         ,@wrk_link_keys   += ' tmp.' + quotename([dbo].[fn_get_object_name] ([dbo].[fn_get_object_name] ([hub_name], 'hub'),'HubSurrogate')) + ' = link.' + quotename([dbo].[fn_get_object_name] ([dbo].[fn_get_object_name] ([hub_name], 'hub'),'HubSurrogate')) + @crlf + ' AND '
			   --,@wrk_link_match  += quotename([dbo].[fn_get_object_name] ([dbo].[fn_get_object_name] ([hub_name], 'hub'),'HubSurrogate'))  + ' , '
        select  @wrk_hub_joins   += (select column_name from [dbo].[fn_get_key_definition]([hub_name], 'hub')) + ', '
               ,@wrk_link_keys   += ' tmp.' + (select column_name from [dbo].[fn_get_key_definition]([hub_name], 'hub')) + ' = link.' + (select column_name from [dbo].[fn_get_key_definition]([hub_name], 'hub')) + @crlf + ' AND '
			   ,@wrk_link_match  += (select column_name from [dbo].[fn_get_key_definition]([hub_name], 'hub'))  + ' , '


         from (
        select distinct
            h.hub_name
           --,hkc.hub_key_ordinal_position
        from [dbo].[dv_hub] h
        inner join [dbo].[dv_hub_key_column] hkc
        on h.hub_key = hkc.hub_key
        inner join [dbo].[dv_hub_column] hc
        on hc.hub_key_column_key = hkc.hub_key_column_key
        inner join [dbo].[dv_column] c
        on c.column_key = hc.column_key
        inner join [dbo].[dv_source_table] st
        on c.[table_key] = st.[source_table_key]
        where 1=1
        and h.hub_key = @c_hub_key
        and st.[source_table_key] = @source_table_config_key
        and c.discard_flag <> 1) hkc
       -- ORDER BY hkc.hub_key_ordinal_position
        set @link_hub_keys = @link_hub_keys + @wrk_link_keys
        FETCH NEXT FROM c_hub_key
        INTO @c_hub_key
                ,@c_hub_name
                ,@c_hub_schema
                ,@c_hub_database
                ,@c_hub_abbreviation
END

CLOSE c_hub_key
DEALLOCATE c_hub_key
select @wrk_link_keys	= left(@wrk_link_keys, len(@wrk_link_keys) - 4)
select @wrk_hub_joins	= left(@wrk_hub_joins, len(@wrk_hub_joins) - 1)
select @wrk_link_match	= left(@wrk_link_match, len(@wrk_link_match) -2)
end


---- Use either a date time from the source or the default
select @source_load_date_time = [column_name]
from [dbo].[dv_source_table] st
inner join [dbo].[dv_column] c
on st.[source_table_key] = c.table_key
where 1=1
and st.[source_table_key] = @source_table_config_key
and c.[is_source_date] = 1
--NB do not check Discard Flag here as the Date Column may not be included in the Sat.
if @@rowcount > 1 RAISERROR ('Source Table has Multiple Source Dates Defined',16,1);
select @source_load_date_time = isnull(@source_load_date_time, @def_global_default_load_date_time)

-- Build the Source Payload NB - needs to join to the Sat Table to get each satellite related to the source.
set @sql = ''
select @sql += 'src.' +quotename([column_name]) + @crlf +', '
from [dbo].[dv_column]
where 1=1
and [discard_flag] <> 1
and [table_key] = @source_table_config_key
order by source_ordinal_position
select @source_payload = left(@sql, len(@sql) -1)

---- Build the Link Payload
set @sql = ''
select @sql += quotename([column_name]) +', '
from [dbo].[dv_default_column]
where 1=1
and object_column_type <> 'Object_Key'
and [object_type] = 'Lnk'
order by [ordinal_position]
set @link_technical_columns = @sql
-- Build the SQL to obtain Surrogate Keys, before Merging the Sat.
-- HUB based

-- Get the Key Match
if @sat_link_hub_flag = 'H'
begin
        select @sql = ''
        select @sql += 'hub.' + quotename(hkc.[hub_key_column_name]) + ' = CAST(src.' + quotename(c.[column_name]) + ' as ' + [hub_key_column_type] + ')' + @crlf + ' AND '
        from [dbo].[dv_hub] h
        inner join [dbo].[dv_hub_key_column] hkc
        on h.hub_key = hkc.hub_key
        inner join [dbo].[dv_hub_column] hc
        on hc.hub_key_column_key = hkc.hub_key_column_key
        inner join [dbo].[dv_column] c
        on c.column_key = hc.column_key
        inner join [dbo].[dv_source_table] st
        on c.[table_key] = st.[source_table_key]
        where 1=1
        and h.hub_key = @hub_config_key
        and st.[source_table_key] = @source_table_config_key
        and c.discard_flag <> 1
        ORDER BY hkc.hub_key_ordinal_position
        select @surrogate_key_match =  left(@sql, len(@sql) - 4)
        --select '@surrogate_key_match', @surrogate_key_match
end
-- Compile the SQL
--SQL to do the look up the hub keys that make up the link
EXECUTE [dbo].[dv_load_source_table_key_lookup] @source_system , @source_schema, @source_table, 'Y', @temp_table_name OUTPUT, @sql OUTPUT

set @sql1 = @sql
set @sql1 = @sql1 + 'DECLARE @rowcounts TABLE(merge_action nvarchar(10));' + @crlf
set @sql1 = @sql1 + 'WITH wBaseSet AS (SELECT DISTINCT ' + @wrk_link_match + ' FROM ' + quotename(@temp_table_name) + ')' + @crlf
set @sql1 = @sql1 + 'MERGE ' + @link_qualified_name + ' WITH (HOLDLOCK) AS link' + @crlf
--set @sql1 = @sql1 + 'USING ' + @temp_table_name + ' AS tmp' + @crlf
set @sql1 = @sql1 + 'USING wBaseSet AS tmp' + @crlf
set @sql1 = @sql1 + 'ON' + @wrk_link_keys
set @sql1 = @sql1 + 'WHEN NOT MATCHED BY TARGET THEN ' + @crlf
set @sql1 = @sql1 + 'INSERT(' + @link_technical_columns + @wrk_hub_joins +  ')' + @crlf
set @sql1 = @sql1 + 'VALUES(sysdatetimeoffset(), ''' + cast(@source_table_config_key as varchar(20)) + ''',' + @wrk_hub_joins + ')OUTPUT $action into @rowcounts;' + @crlf
set @sql1 = @sql1 + 'select @insertcount = count(*) from @rowcounts;' + @crlf
set @sql = @sql1

/*--------------------------------------------------------------------------------------------------------------*/
SET @_Step = 'Load The Hub'
IF @_JournalOnOff = 'ON'
        SET @_ProgressText += @SQL
SET @ParmDefinition = N'@insertcount int OUTPUT';

--print 'link'
--print @SQL  
EXECUTE sp_executesql @SQL, @ParmDefinition, @insertcount = @insert_count OUTPUT;

/*--------------------------------------------------------------------------------------------------------------*/

SET @_ProgressText  = @_ProgressText + @NEW_LINE
                                + 'Step: [' + @_Step + '] completed '

IF @@TRANCOUNT > 0 COMMIT TRAN;

SET @_Message   = 'Successfully Loaded Object: ' + @link_qualified_name

END TRY
BEGIN CATCH
SET @_ErrorContext      = 'Failed to Load Object: ' + @link_qualified_name


IF (XACT_STATE() = -1) -- uncommitable transaction
OR (@@TRANCOUNT > 0 AND XACT_STATE() != 1) -- undocumented uncommitable transaction
        BEGIN
                ROLLBACK TRAN;
                SET @_ErrorContext = @_ErrorContext + ' (Forced rolled back of all changes)';
        END

EXEC log4.ExceptionHandler
                  @ErrorContext  = @_ErrorContext
                , @ErrorNumber   = @_Error OUT
                , @ReturnMessage = @_Message OUT
                , @ExceptionId   = @_ExceptionId OUT
;
END CATCH

--/////////////////////////////////////////////////////////////////////////////////////////////////
OnComplete:
--/////////////////////////////////////////////////////////////////////////////////////////////////

        --! Clean up

        --!
        --! Use dbo.udf_FormatElapsedTime() to get a nicely formatted run time string e.g.
        --! "0 hr(s) 1 min(s) and 22 sec(s)" or "1345 milliseconds"
        --!
        IF @_Error = 0
                BEGIN
                        SET @_Step                      = 'OnComplete'
                        SET @_Severity          = @SEVERITY_SUCCESS
                        SET @_Message           = COALESCE(@_Message, @_Step)
                                                                + ' in a total run time of ' + log4.FormatElapsedTime(@_SprocStartTime, NULL, 3)
                        SET @_ProgressText  = @_ProgressText + @NEW_LINE + @_Message;
                END
        ELSE
                BEGIN
                        SET @_Step                      = COALESCE(@_Step, 'OnError')
                        SET @_Severity          = @SEVERITY_SEVERE
                        SET @_Message           = COALESCE(@_Message, @_Step)
                                                                + ' after a total run time of ' + log4.FormatElapsedTime(@_SprocStartTime, NULL, 3)
                        SET @_ProgressText  = @_ProgressText + @NEW_LINE + @_Message;
                END

        IF @_JournalOnOff = 'ON'
                EXEC log4.JournalWriter
                                  @Task                         = @_FunctionName
                                , @FunctionName         = @_FunctionName
                                , @StepInFunction       = @_Step
                                , @MessageText          = @_Message
                                , @Severity                     = @_Severity
                                , @ExceptionId          = @_ExceptionId
                                --! Supply all the progress info after we've gone to such trouble to collect it
                                , @ExtraInfo        = @_ProgressText

        --! Finally, throw an exception that will be detected by the caller
        IF @DoThrowError = 1 AND @_Error > 0
                RAISERROR(@_Message, 16, 99);

        SET NOCOUNT OFF;

        --! Return the value of @@ERROR (which will be zero on success)
        RETURN (@_Error);
END
GO
PRINT N'Creating [dbo].[dv_load_sat_table]...';


GO
CREATE PROCEDURE [dbo].[dv_load_sat_table]
(
  @vault_source_system_name		varchar(128) = NULL
, @vault_source_table_schema	varchar(128) = NULL
, @vault_source_table_name		varchar(128) = NULL
, @vault_sat_name				varchar(128) = NULL
, @vault_temp_table_name        varchar(116) = NULL 
, @vault_source_load_type		varchar(50)  = NULL 
, @vault_sql_statement          nvarchar(max) OUTPUT
, @dogenerateerror				bit				= 0
, @dothrowerror					bit				= 1
)
AS
BEGIN
SET NOCOUNT ON

-- To Do - add Logging for the Payload Parameter
--         validate Parameters properly
-- System Wide Defaults
-- Local Defaults Values
DECLARE @crlf								char(2)			= CHAR(13) + CHAR(10)
-- Global Defaults
DECLARE  
		 @def_global_lowdate				datetime
        ,@def_global_highdate				datetime
        ,@def_global_default_load_date_time	varchar(128)
		,@def_global_failed_lookup_key		int
-- Hub Defaults									
        ,@def_hub_prefix					varchar(128)
		,@def_hub_schema					varchar(128)
		,@def_hub_filegroup					varchar(128)
--Link Defaults									
		,@def_link_prefix					varchar(128)
		,@def_link_schema					varchar(128)
		,@def_link_filegroup				varchar(128)
--Sat Defaults									
		,@def_sat_prefix					varchar(128)
		,@def_sat_schema					varchar(128)
		,@def_sat_filegroup					varchar(128)
		,@sat_start_date_col				varchar(128)
		,@sat_end_date_col					varchar(128)
		,@sat_current_row_col				varchar(128)				

-- Object Specific Settings
-- Source Table
		,@source_system						varchar(128)
		,@source_database					varchar(128)
		,@source_schema						varchar(128)
		,@source_table						varchar(128)
		,@source_table_config_key			int
		,@source_qualified_name				varchar(512)
		,@source_load_date_time				varchar(128)
		,@source_load_type					varchar(50)
		,@source_payload					nvarchar(max)
-- Hub Table
		,@hub_database						varchar(128)
		,@hub_schema						varchar(128)
		,@hub_table							varchar(128)
		,@hub_surrogate_keyname				varchar(128)
		,@hub_config_key					int
		,@hub_qualified_name				varchar(512)
		,@hubt_technical_columns			nvarchar(max)
-- Link Table
		,@link_database						varchar(128)
		,@link_schema						varchar(128)
		,@link_table						varchar(128)
		,@link_surrogate_keyname			varchar(128)
		,@link_config_key					int
		,@link_qualified_name				varchar(512)
		,@link_technical_columns			nvarchar(max)
		,@link_lookup_joins					nvarchar(max)
		,@link_hub_keys						nvarchar(max)
-- Sat Table
		,@sat_database						varchar(128)
		,@sat_schema						varchar(128)
		,@sat_table							varchar(128)
		,@sat_surrogate_keyname				varchar(128)
		,@sat_config_key					int
		,@sat_link_hub_flag					char(1)
		,@sat_qualified_name				varchar(512)
		,@sat_source_date_time				varchar(50)
		,@sat_technical_columns				nvarchar(max)
		,@sat_payload						nvarchar(max)

--  Working Storage
DECLARE @execution_id				int
       ,@rows_inserted				int
	   ,@rows_updated				int
	   ,@rows_deleted				int
	   ,@load_duration				int
	   ,@load_start_time            datetimeoffset(7)
	   ,@load_finish_time			datetimeoffset(7)
	   ,@load_high_water			datetimeoffset(7)
DECLARE @sat_insert_count			int
	   ,@sql						nvarchar(max)
	   ,@sql1						nvarchar(max)
	   ,@sql2						nvarchar(max)
	   ,@surrogate_key_match        nvarchar(max)
DECLARE @declare					nvarchar(512)	= ''
DECLARE @count_rows					nvarchar(256)	= ''
DECLARE @match_list					nvarchar(max)	= ''
DECLARE @value_list					nvarchar(max)	= ''
DECLARE @sat_column_list			nvarchar(max)	= ''
DECLARE @hub_column_list			nvarchar(max)	= ''

DECLARE @ParmDefinition				nvarchar(500);

DECLARE @wrk_link_joins			varchar(4000)
DECLARE @wrk_link__keys			varchar(4000)
-- Log4TSQL Journal Constants 										
DECLARE @SEVERITY_CRITICAL      smallint = 1;
DECLARE @SEVERITY_SEVERE        smallint = 2;
DECLARE @SEVERITY_MAJOR         smallint = 4;
DECLARE @SEVERITY_MODERATE      smallint = 8;
DECLARE @SEVERITY_MINOR         smallint = 16;
DECLARE @SEVERITY_CONCURRENCY   smallint = 32;
DECLARE @SEVERITY_INFORMATION   smallint = 256;
DECLARE @SEVERITY_SUCCESS       smallint = 512;
DECLARE @SEVERITY_DEBUG         smallint = 1024;
DECLARE @NEW_LINE               char(1)  = CHAR(10);

-- Log4TSQL Standard/ExceptionHandler variables
DECLARE	  @_Error         int
		, @_RowCount      int
		, @_Step          varchar(128)
		, @_Message       nvarchar(512)
		, @_ErrorContext  nvarchar(512)

-- Log4TSQL JournalWriter variables
DECLARE   @_FunctionName			varchar(255)
		, @_SprocStartTime			datetime
		, @_JournalOnOff			varchar(3)
		, @_Severity				smallint
		, @_ExceptionId				int
		, @_StepStartTime			datetime
		, @_ProgressText			nvarchar(max)

SET @_Error             = 0;
SET @_FunctionName      = OBJECT_NAME(@@PROCID);
SET @_Severity          = @SEVERITY_INFORMATION;
SET @_SprocStartTime    = sysdatetimeoffset();
SET @_ProgressText      = '' 
SET @_JournalOnOff      = log4.GetJournalControl(@_FunctionName, 'HOWTO');  -- left Group Name as HOWTO for now.


-- set Log4TSQL Parameters for Logging:
SET @_ProgressText		= @_FunctionName + ' starting at ' + CONVERT(char(23), @_SprocStartTime, 121) + ' with inputs: '
						+ @NEW_LINE + '    @vault_source_system_name	 : ' + COALESCE(@vault_source_system_name, 'NULL')
						+ @NEW_LINE + '    @vault_source_table_schema    : ' + COALESCE(@vault_source_table_schema, 'NULL')
						+ @NEW_LINE + '    @vault_source_table_name      : ' + COALESCE(@vault_source_table_name, 'NULL')
						+ @NEW_LINE + '    @vault_sat_name               : ' + COALESCE(@vault_sat_name, 'NULL')
						+ @NEW_LINE + '    @vault_temp_table_name        : ' + COALESCE(@vault_temp_table_name, 'NULL')
						+ @NEW_LINE + '    @vault_source_load_type       : ' + COALESCE(@vault_source_load_type, 'NULL')
						+ @NEW_LINE + '    @DoGenerateError              : ' + COALESCE(CAST(@DoGenerateError AS varchar), 'NULL')
						+ @NEW_LINE + '    @DoThrowError                 : ' + COALESCE(CAST(@DoThrowError AS varchar), 'NULL')
						+ @NEW_LINE

BEGIN TRY
SET @_Step = 'Generate any required error';
IF @DoGenerateError = 1
   select 1 / 0
SET @_Step = 'Validate inputs';

IF isnull(@vault_source_load_type, 'Full') not in ('Full', 'Delta')
			RAISERROR('Invalid Load Type: %s', 16, 1, @vault_source_load_type);
--IF isnull(@recreate_flag, '') not in ('Y', 'N') 
--			RAISERROR('Valid values for recreate_flag are Y or N : %s', 16, 1, @recreate_flag);
/*--------------------------------------------------------------------------------------------------------------*/
SET @_Step = 'Get Defaults'
select
-- Global Defaults
 @def_global_lowdate				= cast([dbo].[fn_get_default_value] ('LowDate','Global')				as datetime)			
,@def_global_highdate				= cast([dbo].[fn_get_default_value] ('HighDate','Global')				as datetime)	
,@def_global_default_load_date_time	= cast([dbo].[fn_get_default_value] ('DefaultLoadDateTime','Global')	as varchar(128))
,@def_global_failed_lookup_key		= cast([dbo].[fn_get_default_value] ('FailedLookupKey', 'Global')     as integer)
-- Hub Defaults								
,@def_hub_prefix					= cast([dbo].[fn_get_default_value] ('prefix','hub')					as varchar(128))	
,@def_hub_schema					= cast([dbo].[fn_get_default_value] ('schema','hub')					as varchar(128))	
,@def_hub_filegroup					= cast([dbo].[fn_get_default_value] ('filegroup','hub')				as varchar(128))	
-- Link Defaults																						
,@def_link_prefix					= cast([dbo].[fn_get_default_value] ('prefix','lnk')					as varchar(128))	
,@def_link_schema					= cast([dbo].[fn_get_default_value] ('schema','lnk')					as varchar(128))	
,@def_link_filegroup				= cast([dbo].[fn_get_default_value] ('filegroup','lnk')				as varchar(128))	
-- Sat Defaults																							
,@def_sat_prefix					= cast([dbo].[fn_get_default_value] ('prefix','sat')					as varchar(128))	
,@def_sat_schema					= cast([dbo].[fn_get_default_value] ('schema','sat')					as varchar(128))	
,@def_sat_filegroup					= cast([dbo].[fn_get_default_value] ('filegroup','sat')				as varchar(128))

select @sat_start_date_col = quotename(column_name)
from [dbo].[dv_default_column]
where 1=1
and object_type	= 'sat'
and object_column_type = 'Version_Start_Date'
select @sat_end_date_col = quotename(column_name)
from [dbo].[dv_default_column]
where 1=1
and object_type	= 'sat'
and object_column_type = 'Version_End_Date'
select @sat_current_row_col = quotename(column_name)
from [dbo].[dv_default_column]
where 1=1
and object_type	= 'sat'
and object_column_type = 'Current_Row'

select @sat_source_date_time = quotename(column_name)
from [dbo].[dv_default_column]
where 1=1
and object_type	= 'sat'
and object_column_type = 'Source_Date_Time'

-- Object Specific Settings
-- Source Table

select 	 @source_system				= s.[source_system_name]	
        ,@source_database			= s.[timevault_name]
		,@source_schema				= t.[source_table_schema]
		,@source_table				= t.[source_table_name]
		,@source_table_config_key	= t.[source_table_key]
		,@source_qualified_name		= quotename(s.[timevault_name]) + '.' + quotename(t.[source_table_schema]) + '.' + quotename(t.[source_table_name])
		,@source_load_type			= coalesce(@vault_source_load_type, t.[source_table_load_type]) --The Run Time Load Type, If provided, overides the Default for the Source Table
from [dbo].[dv_source_system] s
inner join [dbo].[dv_source_table] t
on t.system_key = s.[source_system_key]
where 1=1
and s.[source_system_name]		= @vault_source_system_name
and t.[source_table_schema]		= @vault_source_table_schema
and t.[source_table_name]		= @vault_source_table_name

-- Get Satellite Details
select 	 @sat_database			= sat.[satellite_database]						
		,@sat_schema			= coalesce(sat.[satellite_schema], @def_sat_schema, 'dbo')		
		,@sat_table				= sat.[satellite_name]		
		,@sat_surrogate_keyname	= [dbo].[fn_get_object_name] (sat.[satellite_name],'SatSurrogate')		
		,@sat_config_key		= sat.[satellite_key]		
		,@sat_link_hub_flag		= sat.[link_hub_satellite_flag]		
		,@sat_qualified_name	= quotename(sat.[satellite_database]) + '.' + quotename(coalesce(sat.[satellite_schema], @def_sat_schema, 'dbo')) + '.' + quotename((select [dbo].[fn_get_object_name] (sat.[satellite_name], 'sat')))       
from [dbo].[dv_source_table] t
inner join [dbo].[dv_column] c
on c.table_key = t.[source_table_key]
inner join [dbo].[dv_satellite_column] sc
on sc.column_key = c.column_key
inner join [dbo].[dv_satellite] sat
on sat.satellite_key = sc.satellite_key
where 1=1
and t.[source_table_key] = @source_table_config_key
and sat.[satellite_name] = @vault_sat_name

-- Owner Hub Table

if @sat_link_hub_flag = 'H' 
	select   @hub_database			= h.[hub_database]
	        ,@hub_schema			= coalesce([hub_schema], @def_hub_schema, 'dbo')				
			,@hub_table				= h.[hub_name]
--			,@hub_surrogate_keyname = [dbo].[fn_get_object_name] ([dbo].[fn_get_object_name] ([hub_name], 'hub'),'HubSurrogate')
			,@hub_surrogate_keyname = (select replace(replace(column_name, '[', ''), ']', '') from [dbo].[fn_get_key_definition](h.[hub_name], 'hub'))
			,@hub_config_key		= h.[hub_key]
			,@hub_qualified_name	= quotename([hub_database]) + '.' + quotename(coalesce([hub_schema], @def_hub_schema, 'dbo')) + '.' + quotename((select [dbo].[fn_get_object_name] ([hub_name], 'hub')))	
	from [dbo].[dv_satellite] s
	inner join [dbo].[dv_hub] h
	on s.hub_key = h.hub_key
where 1=1
and s.[satellite_key] = @sat_config_key	
		
-- Owner Link Table
if @sat_link_hub_flag = 'L' 
begin
	select   @link_database			= l.[link_database]
	        ,@link_schema			= coalesce(l.[link_schema], @def_link_schema, 'dbo')				
			,@link_table			= l.[link_name]
			--,@link_surrogate_keyname = [dbo].[fn_get_object_name] ([dbo].[fn_get_object_name] ([link_name], 'lnk'),'LnkSurrogate')
			,@link_surrogate_keyname= (select replace(replace(column_name, '[', ''), ']', '') from [dbo].[fn_get_key_definition](l.[link_name], 'lnk'))
			,@link_config_key		= l.[link_key]
			,@link_qualified_name	= quotename([link_database]) + '.' + quotename(coalesce(l.[link_schema], @def_link_schema, 'dbo')) + '.' + quotename((select [dbo].[fn_get_object_name] ([link_name], 'lnk')))
	from [dbo].[dv_satellite] s
	inner join [dbo].[dv_link] l
	on s.link_key = l.link_key
    where 1=1
    and s.[satellite_key] = @sat_config_key
    
	set @link_lookup_joins = ''	
	set @link_hub_keys = ''	
end

select @source_load_date_time = 'vault_load_time'	

-- Build the Source Payload NB - needs to join to the Sat Table to get each satellite related to the source.
set @sql = ''
select @sql += 'src.' +quotename([column_name]) + @crlf +', '      
from [dbo].[dv_column] c
inner join dv_Satellite_Column sc
on c.column_key = sc.column_key
where 1=1
and [discard_flag] <> 1
and [table_key] = @source_table_config_key
and sc.[satellite_key] = @sat_config_key
order by c.satellite_ordinal_position

select @source_payload = left(@sql, len(@sql) -1)

---- Build the Sat Payload 
set @sql = ''
select @sql += 'sat.' +quotename([column_name]) + @crlf +', ' 
from [dbo].[dv_default_column] 
where 1=1
and object_column_type <> 'Object_Key'
and [object_type] = 'Sat'
order by [ordinal_position]
set @sat_technical_columns = @sql

set @sql = ''
select @sql += 'sat.' +quotename([column_name]) + @crlf +', '
from [dbo].[dv_satellite] s
inner join [dbo].[dv_satellite_column] sc
on s.[satellite_key] = sc.[satellite_key]
inner join [dbo].[dv_column] c
on c.column_key = sc.column_key
where 1=1
and [discard_flag] <> 1
and s.[satellite_key] = @sat_config_key
order by c.satellite_ordinal_position
select @sat_payload = left(@sql, len(@sql) -1)	


-- Compile the SQL

set @sql2 = ''

-- Insert New Rows for Updates
set @sql2 = 'BEGIN TRANSACTION' + @crlf
set @sql2 += 'INSERT INTO '	+ @sat_qualified_name + @crlf 
set @sql2 += ' (' + case when @sat_link_hub_flag = 'H' then  quotename(@hub_surrogate_keyname) else quotename(@link_surrogate_keyname) end + @crlf
set @sql2 += ',   ' + replace(@sat_technical_columns, 'sat.', '')
set @sql2 += replace(@sat_payload, 'sat.', '')
set @sql2 += ')' + @crlf
--set @sql2 += 'SELECT ' + @crlf + '  ' + case when @sat_link_hub_flag = 'H' then  quotename(@hub_surrogate_keyname) else quotename(@link_surrogate_keyname) end + @crlf   
set @sql2 += 'SELECT ' + @crlf + '  hl_driver_key' + @crlf											-- Driving Hub / Link Surrogate Key
--set @sql2 += ', '	+ @source_load_date_time + @crlf												-- Source Load Date Time
--set @sql2 += ', '	+ @sat_load_date_time + @crlf													-- Source Load Date Time
set @sql2 += ', case when MergeOutput.' + 
			case when @sat_link_hub_flag = 'H' then  quotename(@hub_surrogate_keyname) 
			else quotename(@link_surrogate_keyname) end + 
			' is null then ' + @sat_end_date_col +  ' else ' + @source_load_date_time + ' end'+@crlf-- Source Load Date Time. Deletes detected by the fact that they have no source Key
set @sql2 += ', '	+ '''' + cast(@source_table_config_key as varchar(128)) + '''' + @crlf			-- Source Table Reference Key
--set @sql2 += ', '	+ '1' + @crlf																	-- make the row Current
set @sql2 += ', case when MergeOutput.' + 
			case when @sat_link_hub_flag = 'H' then  quotename(@hub_surrogate_keyname) 
			else quotename(@link_surrogate_keyname) end + 
			' is null then 0 else 1 end' + @crlf													-- make the row Current if it's an update. Not Current if a Delete.
set @sql2 += ', case when MergeOutput.' + 
			case when @sat_link_hub_flag = 'H' then  quotename(@hub_surrogate_keyname) 
			else quotename(@link_surrogate_keyname) end + 
			' is null then 1 else 0 end' + @crlf													-- If it is a delete tombstone, set the deleted row flag. Deletes detected by the fact that they have no source Key
set @sql2 += ', MergeOutput.' + @sat_end_date_col + @crlf											-- Row Start Date						
--set @sql2 += ', '''	+ cast(@def_global_highdate as varchar(50)) + '''' + @crlf						-- Row End Date
set @sql2 += ', case when MergeOutput.' + 
			case when @sat_link_hub_flag = 'H' then  quotename(@hub_surrogate_keyname) 
			else quotename(@link_surrogate_keyname) end + 
			' is null then MergeOutput.' + @sat_end_date_col + ' else '''	+ cast(@def_global_highdate as varchar(50)) + ''' end' + @crlf -- Row End Date

set @sql2 += ', '	+ replace(@sat_payload, 'sat.', '')												-- Payload
set @sql2 += 'FROM ' + @crlf + ' (MERGE '  + @sat_qualified_name + ' WITH (HOLDLOCK) AS [sat]' + @crlf 
set @sql2 += ' USING ' + @vault_temp_table_name + ' AS [src]' + @crlf
set @sql2 += ' ON sat.' + case when @sat_link_hub_flag = 'H' then  @hub_surrogate_keyname else @link_surrogate_keyname end + ' = src.' +  case when @sat_link_hub_flag = 'H' then  @hub_surrogate_keyname else @link_surrogate_keyname end + @crlf
set @sql2 += ' AND sat.' + @sat_current_row_col + ' = 1' + @crlf

-- End Date Rows for Updates
set @sql2 += ' WHEN MATCHED AND EXISTS ' + @crlf
set @sql2 += '  (SELECT ' + @crlf
set @sql2 += '  src.' + case when @sat_link_hub_flag = 'H' then  @hub_surrogate_keyname else @link_surrogate_keyname end + @crlf + ', '
set @sql2 += @source_payload 
set @sql2 += ' EXCEPT ' + @crlf + ' SELECT ' + @crlf
set @sql2 += '  sat.' + case when @sat_link_hub_flag = 'H' then  @hub_surrogate_keyname else @link_surrogate_keyname end + @crlf + ', '
set @sql2 += @sat_payload
set @sql2 += ')' + @crlf + 'THEN UPDATE SET' + @crlf
set @sql2 += @sat_current_row_col + '  = 0' + @crlf
--set @sql2 = @sql2 + ',  ' + @sat_end_date_col + ' = iif([vault_load_time] > sat.' + @sat_start_date_col + ', [vault_load_time], dateadd(ms,1, sat.' + @sat_end_date_col + '))' + @crlf
set @sql2 += ',  ' + @sat_end_date_col + ' = iif(@version_date > sat.' + @sat_start_date_col + ', @version_date, dateadd(ms,1, sat.' + @sat_start_date_col + '))' + @crlf
--Insert New Rows
set @sql2 += 'WHEN NOT MATCHED BY TARGET ' + @crlf
set @sql2 += '  THEN INSERT ( ' + @crlf
set @sql2 += '  ' + case when @sat_link_hub_flag = 'H' then  quotename(@hub_surrogate_keyname) else quotename(@link_surrogate_keyname) end + @crlf
set @sql2 += ', ' + replace(@sat_technical_columns, 'sat.', '')
set @sql2 += replace(@sat_payload, 'sat.', '') + ')' + @crlf
set @sql2 += 'VALUES(' + @crlf + '  src.' + case when @sat_link_hub_flag = 'H' then  quotename(@hub_surrogate_keyname) else quotename(@link_surrogate_keyname) end + @crlf  + ', ' 
set @sql2 += '[vault_load_time]' + @crlf
set @sql2 += ', ' + cast(@source_table_config_key as varchar(50)) + @crlf
set @sql2 += ', 1' + @crlf
set @sql2 += ', 0' + @crlf
set @sql2 += ', @version_date ' + @crlf
set @sql2 += ', ''' + cast(@def_global_highdate as varchar(50)) + '''' + @crlf
set @sql2 += ', ' +@source_payload + ')' + @crlf
-- End Date Deleted Rows
if @source_load_type = 'Full'
begin
	set @sql2 += 'WHEN NOT MATCHED BY SOURCE AND sat.' + @sat_current_row_col + ' = 1' +@crlf
	set @sql2 += 'THEN UPDATE SET ' + @crlf
	set @sql2 += '  ' + @sat_current_row_col + ' = 0' + @crlf
	set @sql2 += ', ' + @sat_end_date_col + ' = iif(@version_date > sat.' + @sat_start_date_col + ', @version_date, dateadd(ms,1, sat.' + @sat_end_date_col + ')'+ @crlf
	set @sql2 += ')' + @crlf 
end
-- Output End Dated Rows for Insert by the Outer Query. 
-- Also output the End Date, for use as the next start date.
set @sql2 += '  OUTPUT $action AS Action' + @crlf
set @sql2 += '        ,inserted.' + @sat_end_date_col + @crlf
set @sql2 += '        ,inserted.' + @sat_current_row_col + @crlf  --------------------------------
set @sql2 += '        ,inserted.' + case when @sat_link_hub_flag = 'H' then  quotename(@hub_surrogate_keyname) else quotename(@link_surrogate_keyname) end + ' as hl_driver_key' + @crlf
set @sql2 += '        ,inserted.' + @sat_source_date_time + @crlf
set @sql2 += '        ,[src].*' + @crlf
set @sql2 += ') AS MergeOutput' + @crlf
set @sql2 += '  WHERE 1=1' + @crlf
set @sql2 += '  AND MergeOutput.Action = ''UPDATE''' + @crlf
--set @sql2 += '    AND ' + case when @sat_link_hub_flag = 'H' then  quotename(@hub_surrogate_keyname) else quotename(@link_surrogate_keyname) end + ' is not null' + @crlf
set @sql2 += ';' + @crlf-- Merge Statement Must end with ';'

-- Log Completion
set @sql2 += 'EXECUTE [dv_log].[dv_log_progress] ''sat'',''' + @sat_table + ''',''' + @sat_schema + ''',''' +  @sat_database + ''',' --+ @crlf
set @sql2 += '''' + @source_table + ''',''' +  @source_schema + ''',''' + @source_system + ''',' --+ @crlf 
set @sql2 += cast(isnull(@execution_id, 0) as varchar(50)) + ', @version_date, '  
          + cast(isnull(@rows_inserted, 0) as varchar(50)) + ',' + cast(isnull(@rows_updated, 0) as varchar(50)) + ',' + cast(isnull(@rows_deleted, 0) as varchar(50)) + @crlf
set @sql2 += 'COMMIT;' + @crlf
select @vault_sql_statement = @sql2
IF @_JournalOnOff = 'ON' SET @_ProgressText = @crlf + @vault_sql_statement + @crlf
/*--------------------------------------------------------------------------------------------------------------*/
--SET @_Step = 'Load The ' + case when @sat_link_hub_flag = 'H' then 'Hub' else 'Link' end
--IF @_JournalOnOff = 'ON'
--	SET @_ProgressText += @sql
--print @vault_sql_statement
--select @vault_sql_statement
--EXECUTE sp_executesql @SQL;
/*--------------------------------------------------------------------------------------------------------------*/

SET @_ProgressText  = @_ProgressText + @NEW_LINE
				+ 'Step: [' + @_Step + '] completed ' 

IF @@TRANCOUNT > 0 COMMIT TRAN;

SET @_Message   = 'Successfully Loaded Object: ' + @sat_qualified_name

END TRY
BEGIN CATCH
SET @_ErrorContext	= 'Failed to Load Object: ' + @sat_qualified_name
IF (XACT_STATE() = -1) -- uncommitable transaction
OR (@@TRANCOUNT > 0 AND XACT_STATE() != 1) -- undocumented uncommitable transaction
	BEGIN
		ROLLBACK TRAN;
		SET @_ErrorContext = @_ErrorContext + ' (Forced rolled back of all changes)';
	END
	
EXEC log4.ExceptionHandler
		  @ErrorContext  = @_ErrorContext
		, @ErrorNumber   = @_Error OUT
		, @ReturnMessage = @_Message OUT
		, @ExceptionId   = @_ExceptionId OUT
;
END CATCH

--/////////////////////////////////////////////////////////////////////////////////////////////////
OnComplete:
--/////////////////////////////////////////////////////////////////////////////////////////////////

	--! Clean up

	--!
	--! Use dbo.udf_FormatElapsedTime() to get a nicely formatted run time string e.g.
	--! "0 hr(s) 1 min(s) and 22 sec(s)" or "1345 milliseconds"
	--!
	IF @_Error = 0
		BEGIN
			SET @_Step			= 'OnComplete'
			SET @_Severity		= @SEVERITY_SUCCESS
			SET @_Message		= COALESCE(@_Message, @_Step)
								+ ' in a total run time of ' + log4.FormatElapsedTime(@_SprocStartTime, NULL, 3)
			SET @_ProgressText  = @_ProgressText + @NEW_LINE + @_Message;
		END
	ELSE
		BEGIN
			SET @_Step			= COALESCE(@_Step, 'OnError')
			SET @_Severity		= @SEVERITY_SEVERE
			SET @_Message		= COALESCE(@_Message, @_Step)
								+ ' after a total run time of ' + log4.FormatElapsedTime(@_SprocStartTime, NULL, 3)
			SET @_ProgressText  = @_ProgressText + @NEW_LINE + @_Message;
		END

	IF @_JournalOnOff = 'ON'
		EXEC log4.JournalWriter
				  @Task				= @_FunctionName
				, @FunctionName		= @_FunctionName
				, @StepInFunction	= @_Step
				, @MessageText		= @_Message
				, @Severity			= @_Severity
				, @ExceptionId		= @_ExceptionId
				--! Supply all the progress info after we've gone to such trouble to collect it
				, @ExtraInfo        = @_ProgressText

	--! Finally, throw an exception that will be detected by the caller
	IF @DoThrowError = 1 AND @_Error > 0
		RAISERROR(@_Message, 16, 99);

	SET NOCOUNT OFF;

	--! Return the value of @@ERROR (which will be zero on success)
	RETURN (@_Error);
END
GO
PRINT N'Creating [dbo].[dv_load_sats_for_source_table]...';


GO

CREATE PROCEDURE [dbo].[dv_load_sats_for_source_table]
(
  @vault_source_system_name		varchar(128) = NULL
, @vault_source_table_schema	varchar(128) = NULL
, @vault_source_table_name		varchar(128) = NULL
, @vault_source_load_type		varchar(50)  = NULL
, @dogenerateerror				bit				= 0
, @dothrowerror					bit				= 1
)
AS
BEGIN
SET NOCOUNT ON

-- To Do - add Logging for the Payload Parameter
--         validate Parameters properly
--         Add Transactionality for Multi Sat Loads
--         Pick a single sat to load (from a multi sat)
-- System Wide Defaults
-- Local Defaults Values
DECLARE @crlf								char(2)			= CHAR(13) + CHAR(10)
-- Global Defaults
DECLARE  
		 @def_global_lowdate				datetime
        ,@def_global_highdate				datetime
        ,@def_global_default_load_date_time	varchar(128)
		,@def_global_failed_lookup_key		int
-- Hub Defaults									
        ,@def_hub_prefix					varchar(128)
		,@def_hub_schema					varchar(128)
		,@def_hub_filegroup					varchar(128)
--Link Defaults									
		,@def_link_prefix					varchar(128)
		,@def_link_schema					varchar(128)
		,@def_link_filegroup				varchar(128)
--Sat Defaults									
		,@def_sat_prefix					varchar(128)
		,@def_sat_schema					varchar(128)
		,@def_sat_filegroup					varchar(128)
		,@sat_start_date_col				varchar(128)
		,@sat_end_date_col					varchar(128)				

-- Object Specific Settings
-- Source Table
		,@source_system						varchar(128)
        ,@source_database					varchar(128)
		,@source_schema						varchar(128)
		,@source_table						varchar(128)
		,@source_table_config_key			int
		,@source_qualified_name				varchar(512)
		,@source_load_date_time				varchar(128)
		,@source_payload					nvarchar(max)
-- Hub Table
		,@hub_database						varchar(128)
		,@hub_schema						varchar(128)
		,@hub_table							varchar(128)
		,@hub_surrogate_keyname				varchar(128)
		,@hub_config_key					int
		,@hub_qualified_name				varchar(512)
		,@hubt_technical_columns			nvarchar(max)
-- Link Table
		,@link_database						varchar(128)
		,@link_schema						varchar(128)
		,@link_table						varchar(128)
		,@link_surrogate_keyname			varchar(128)
		,@link_config_key					int
		,@link_qualified_name				varchar(512)
		,@link_technical_columns			nvarchar(max)
		,@link_lookup_joins					nvarchar(max)
		,@link_hub_keys						nvarchar(max)
-- Sat Table
		,@sat_database						varchar(128)
		,@sat_schema						varchar(128)
		,@sat_table							varchar(128)
		,@sat_surrogate_keyname				varchar(128)
		,@sat_config_key					int
		,@sat_link_hub_flag					char(1)
		,@sat_qualified_name				varchar(512)
		,@sat_technical_columns				nvarchar(max)
		,@sat_payload						nvarchar(max)

--  Working Storage
DECLARE @sat_insert_count			int
       ,@temp_table_name			varchar(116)
	   ,@sql						nvarchar(max)
	   ,@sql1						nvarchar(max)
	   ,@sql2						nvarchar(max)
	   ,@surrogate_key_match        varchar(1000)
DECLARE @declare					nvarchar(512)	= ''
DECLARE @count_rows					nvarchar(256)	= ''
DECLARE @match_list					nvarchar(max)	= ''
DECLARE @value_list					nvarchar(max)	= ''
DECLARE @sat_column_list			nvarchar(max)	= ''
DECLARE @hub_column_list			nvarchar(max)	= ''

DECLARE @ParmDefinition				nvarchar(500);

DECLARE @satellite_list				table (sat_database				varchar(128)				
										  ,sat_schema				varchar(128)			
										  ,sat_table				varchar(128)
										  ,sat_surrogate_keyname    varchar(128)
										  ,sat_config_key			int
										  ,sat_link_hub_flag		char(1)
										  ,sat_qualified_name		varchar(512)
										  )

DECLARE @wrk_link_joins			nvarchar(max)
DECLARE @wrk_link__keys			nvarchar(max)
-- Log4TSQL Journal Constants 										
DECLARE @SEVERITY_CRITICAL      smallint = 1;
DECLARE @SEVERITY_SEVERE        smallint = 2;
DECLARE @SEVERITY_MAJOR         smallint = 4;
DECLARE @SEVERITY_MODERATE      smallint = 8;
DECLARE @SEVERITY_MINOR         smallint = 16;
DECLARE @SEVERITY_CONCURRENCY   smallint = 32;
DECLARE @SEVERITY_INFORMATION   smallint = 256;
DECLARE @SEVERITY_SUCCESS       smallint = 512;
DECLARE @SEVERITY_DEBUG         smallint = 1024;
DECLARE @NEW_LINE               char(1)  = CHAR(10);

-- Log4TSQL Standard/ExceptionHandler variables
DECLARE	  @_Error         int
		, @_RowCount      int
		, @_Step          varchar(128)
		, @_Message       nvarchar(512)
		, @_ErrorContext  nvarchar(512)

-- Log4TSQL JournalWriter variables
DECLARE   @_FunctionName			varchar(255)
		, @_SprocStartTime			datetime
		, @_JournalOnOff			varchar(3)
		, @_Severity				smallint
		, @_ExceptionId				int
		, @_StepStartTime			datetime
		, @_ProgressText			nvarchar(max)

SET @_Error             = 0;
SET @_FunctionName      = OBJECT_NAME(@@PROCID);
SET @_Severity          = @SEVERITY_INFORMATION;
SET @_SprocStartTime    = sysdatetimeoffset();
SET @_ProgressText      = '' 
SET @_JournalOnOff      = log4.GetJournalControl(@_FunctionName, 'HOWTO');  -- left Group Name as HOWTO for now.


-- set Log4TSQL Parameters for Logging:
SET @_ProgressText		= @_FunctionName + ' starting at ' + CONVERT(char(23), @_SprocStartTime, 121) + ' with inputs: '
						+ @NEW_LINE + '    @vault_source_system_name     : ' + COALESCE(@vault_source_system_name, 'NULL')
						+ @NEW_LINE + '    @vault_source_table_schema    : ' + COALESCE(@vault_source_table_schema, 'NULL')
						+ @NEW_LINE + '    @vault_source_table_name      : ' + COALESCE(@vault_source_table_name, 'NULL')
						+ @NEW_LINE + '    @vault_source_load_type       : ' + COALESCE(@vault_source_load_type, 'NULL')
						+ @NEW_LINE + '    @DoGenerateError              : ' + COALESCE(CAST(@DoGenerateError AS varchar), 'NULL')
						+ @NEW_LINE + '    @DoThrowError                 : ' + COALESCE(CAST(@DoThrowError AS varchar), 'NULL')
						+ @NEW_LINE

BEGIN TRY

SET @_Step = 'Generate any required error';
IF @DoGenerateError = 1
   select 1 / 0
SET @_Step = 'Validate inputs';

IF isnull(@vault_source_load_type, 'Full') not in ('Full', 'Delta')
			RAISERROR('Invalid Load Type: %s', 16, 1, @vault_source_load_type);
--IF isnull(@recreate_flag, '') not in ('Y', 'N') 
--			RAISERROR('Valid values for recreate_flag are Y or N : %s', 16, 1, @recreate_flag);
/*--------------------------------------------------------------------------------------------------------------*/
SET @_Step = 'Get Defaults'
-- System Wide Defaults
select
-- Global Defaults
 @def_global_lowdate				= cast([dbo].[fn_get_default_value] ('LowDate','Global')				as datetime)			
,@def_global_highdate				= cast([dbo].[fn_get_default_value] ('HighDate','Global')				as datetime)	
,@def_global_default_load_date_time	= cast([dbo].[fn_get_default_value] ('DefaultLoadDateTime','Global')	as varchar(128))
,@def_global_failed_lookup_key		= cast([dbo].[fn_get_default_value] ('FailedLookupKey', 'Global')     as integer)
-- Hub Defaults								
,@def_hub_prefix					= cast([dbo].[fn_get_default_value] ('prefix','hub')					as varchar(128))	
,@def_hub_schema					= cast([dbo].[fn_get_default_value] ('schema','hub')					as varchar(128))	
,@def_hub_filegroup					= cast([dbo].[fn_get_default_value] ('filegroup','hub')				as varchar(128))	
-- Link Defaults																						
,@def_link_prefix					= cast([dbo].[fn_get_default_value] ('prefix','lnk')					as varchar(128))	
,@def_link_schema					= cast([dbo].[fn_get_default_value] ('schema','lnk')					as varchar(128))	
,@def_link_filegroup				= cast([dbo].[fn_get_default_value] ('filegroup','lnk')				as varchar(128))	
-- Sat Defaults																							
,@def_sat_prefix					= cast([dbo].[fn_get_default_value] ('prefix','sat')					as varchar(128))	
,@def_sat_schema					= cast([dbo].[fn_get_default_value] ('schema','sat')					as varchar(128))	
,@def_sat_filegroup					= cast([dbo].[fn_get_default_value] ('filegroup','sat')				as varchar(128))

select @sat_start_date_col = quotename(column_name)
from [dbo].[dv_default_column]
where 1=1
and object_type	= 'sat'
and object_column_type = 'Version_Start_Date'
select @sat_end_date_col = quotename(column_name)
from [dbo].[dv_default_column]
where 1=1
and object_type	= 'sat'
and object_column_type = 'Version_End_Date'

-- Object Specific Settings
-- Source Table
select 	 @source_system				= s.[source_system_name]	
        ,@source_database			= s.[timevault_name]
		,@source_schema				= t.[source_table_schema]
		,@source_table				= t.[source_table_name]
		,@source_table_config_key	= t.[source_table_key]
		,@source_qualified_name		= quotename(s.[timevault_name]) + '.' + quotename(t.[source_table_schema]) + '.' + quotename(t.[source_table_name])
from [dbo].[dv_source_system] s
inner join [dbo].[dv_source_table] t
on t.system_key = s.[source_system_key]
where 1=1
and s.[source_system_name]		= @vault_source_system_name
and t.[source_table_schema]		= @vault_source_table_schema
and t.[source_table_name]		= @vault_source_table_name

-- Get a list of Satellites
insert @satellite_list
select distinct 
       sat.[satellite_database]
      ,coalesce(sat.[satellite_schema], @def_sat_schema, 'dbo')
	  ,sat.[satellite_name]
	  ,[dbo].[fn_get_object_name] (sat.[satellite_name],'SatSurrogate') 
	  ,sat.[satellite_key] 
	  ,sat.[link_hub_satellite_flag]
	  ,quotename(sat.[satellite_database]) + '.' + quotename(coalesce(sat.[satellite_schema], @def_sat_schema, 'dbo')) + '.' + quotename((select [dbo].[fn_get_object_name] (sat.[satellite_name], 'sat')))       
from [dbo].[dv_source_table] t
inner join [dbo].[dv_column] c
on c.table_key = t.[source_table_key]
inner join [dbo].[dv_satellite_column] sc
on sc.column_key = c.column_key
inner join [dbo].[dv_satellite] sat
on sat.satellite_key = sc.satellite_key
where 1=1
and t.[source_table_key] = @source_table_config_key

-- Note that split satellites can only be of 1 type - Link or Hub
select @sat_link_hub_flag = [sat_link_hub_flag] from @satellite_list 

-- Owner Hub Table

if @sat_link_hub_flag = 'H' 
	select   @hub_database			= h.[hub_database]
	        ,@hub_schema			= coalesce([hub_schema], @def_hub_schema, 'dbo')				
			,@hub_table				= h.[hub_name]
			,@hub_surrogate_keyname = [dbo].[fn_get_object_name] ([dbo].[fn_get_object_name] ([hub_name], 'hub'),'HubSurrogate')
			,@hub_config_key		= h.[hub_key]
			,@hub_qualified_name	= quotename([hub_database]) + '.' + quotename(coalesce([hub_schema], @def_hub_schema, 'dbo')) + '.' + quotename((select [dbo].[fn_get_object_name] ([hub_name], 'hub')))	
	from [dbo].[dv_satellite] s
	inner join [dbo].[dv_hub] h
	on s.hub_key = h.hub_key
where 1=1
and s.[satellite_key] = (select top 1 sat_config_key from @satellite_list) 	
		
-- Owner Link Table
if @sat_link_hub_flag = 'L' 
	select   @link_database			= l.[link_database]
	        ,@link_schema			= coalesce(l.[link_schema], @def_link_schema, 'dbo')				
			,@link_table			= l.[link_name]
			,@link_surrogate_keyname = [dbo].[fn_get_object_name] ([dbo].[fn_get_object_name] ([link_name], 'lnk'),'LnkSurrogate')
			,@link_config_key		= l.[link_key]
			,@link_qualified_name	= quotename([link_database]) + '.' + quotename(coalesce(l.[link_schema], @def_link_schema, 'dbo')) + '.' + quotename((select [dbo].[fn_get_object_name] ([link_name], 'lnk')))
	from [dbo].[dv_satellite] s
	inner join [dbo].[dv_link] l
	on s.link_key = l.link_key
    where 1=1
    and s.[satellite_key] = (select top 1 sat_config_key from @satellite_list)
 
 -- Get the SQL for the Key Lookup   

EXECUTE [dbo].[dv_load_source_table_key_lookup] @source_system,@source_schema,@source_table, 'N', @temp_table_name OUTPUT, @sql1 OUTPUT

-- Now Get the Satellite Update SQL

set @sql2 =			'DECLARE @version_date_char VARCHAR(20)' + @crlf
set @sql2 = @sql2 + 'DECLARE @version_date datetimeoffset(7)' + @crlf
set @sql2 = @sql2 + 'select @version_date = sysdatetimeoffset()'  + @crlf 
set @sql2 = @sql2 + 'select @version_date_char = CONVERT(varchar(50), @version_date) '  + @crlf 
DECLARE c_sat_list CURSOR FOR 
select sat_table
  FROM @satellite_list

OPEN c_sat_list   
FETCH NEXT FROM c_sat_list 
INTO @sat_table		 

WHILE @@FETCH_STATUS = 0   
BEGIN   
EXECUTE [dbo].[dv_load_sat_table] @source_system,@source_schema,@source_table, @sat_table, @temp_table_name, @vault_source_load_type, @sql OUTPUT
set @sql2 += @sql
FETCH NEXT FROM c_sat_list 
INTO @sat_table	
END   

CLOSE c_sat_list   
DEALLOCATE c_sat_list
	
set @sql = @sql1 + @sql2

--/*--------------------------------------------------------------------------------------------------------------*/
SET @_Step = 'Load The Source into Sat(s)'
IF @_JournalOnOff = 'ON' SET @_ProgressText += @SQL
--select @SQL2
EXECUTE(@SQL);
/*--------------------------------------------------------------------------------------------------------------*/

SET @_ProgressText  = @_ProgressText + @NEW_LINE
				+ 'Step: [' + @_Step + '] completed ' 

IF @@TRANCOUNT > 0 COMMIT TRAN;

SET @_Message   = 'Successfully Loaded Object: ' + @sat_qualified_name

END TRY
BEGIN CATCH
SET @_ErrorContext	= 'Failed to Load Object: ' + @sat_qualified_name
IF (XACT_STATE() = -1) -- uncommitable transaction
OR (@@TRANCOUNT > 0 AND XACT_STATE() != 1) -- undocumented uncommitable transaction
	BEGIN
		ROLLBACK TRAN;
		SET @_ErrorContext = @_ErrorContext + ' (Forced rolled back of all changes)';
	END
	
EXEC log4.ExceptionHandler
		  @ErrorContext  = @_ErrorContext
		, @ErrorNumber   = @_Error OUT
		, @ReturnMessage = @_Message OUT
		, @ExceptionId   = @_ExceptionId OUT
;
END CATCH

--/////////////////////////////////////////////////////////////////////////////////////////////////
OnComplete:
--/////////////////////////////////////////////////////////////////////////////////////////////////

	--! Clean up

	--!
	--! Use dbo.udf_FormatElapsedTime() to get a nicely formatted run time string e.g.
	--! "0 hr(s) 1 min(s) and 22 sec(s)" or "1345 milliseconds"
	--!
	IF @_Error = 0
		BEGIN
			SET @_Step			= 'OnComplete'
			SET @_Severity		= @SEVERITY_SUCCESS
			SET @_Message		= COALESCE(@_Message, @_Step)
								+ ' in a total run time of ' + log4.FormatElapsedTime(@_SprocStartTime, NULL, 3)
			SET @_ProgressText  = @_ProgressText + @NEW_LINE + @_Message;
		END
	ELSE
		BEGIN
			SET @_Step			= COALESCE(@_Step, 'OnError')
			SET @_Severity		= @SEVERITY_SEVERE
			SET @_Message		= COALESCE(@_Message, @_Step)
								+ ' after a total run time of ' + log4.FormatElapsedTime(@_SprocStartTime, NULL, 3)
			SET @_ProgressText  = @_ProgressText + @NEW_LINE + @_Message;
		END

	IF @_JournalOnOff = 'ON'
		EXEC log4.JournalWriter
				  @Task				= @_FunctionName
				, @FunctionName		= @_FunctionName
				, @StepInFunction	= @_Step
				, @MessageText		= @_Message
				, @Severity			= @_Severity
				, @ExceptionId		= @_ExceptionId
				--! Supply all the progress info after we've gone to such trouble to collect it
				, @ExtraInfo        = @_ProgressText

	--! Finally, throw an exception that will be detected by the caller
	IF @DoThrowError = 1 AND @_Error > 0
		RAISERROR(@_Message, 16, 99);

	SET NOCOUNT OFF;

	--! Return the value of @@ERROR (which will be zero on success)
	RETURN (@_Error);
END
GO
PRINT N'Creating [dbo].[dv_load_source_table]...';


GO
CREATE PROCEDURE [dbo].[dv_load_source_table]
(
  @vault_source_system_name		varchar(128) = NULL
, @vault_source_table_schema	varchar(128) = NULL
, @vault_source_table_name		varchar(128) = NULL
, @vault_source_load_type		varchar(50)  = NULL
, @dogenerateerror				bit				= 0
, @dothrowerror					bit				= 1
)
AS
BEGIN
SET NOCOUNT ON

-- To Do - add Logging for the Payload Parameter
--         validate Parameters properly
--         Add Transactionality for Multi Sat Loads
--         Pick a single sat to load (from a multi sat)
-- System Wide Defaults
-- Local Defaults Values

set nocount on

-- Object Specific Settings
-- Source Table
declare  @source_system						varchar(128)
        ,@source_database					varchar(128)
		,@source_schema						varchar(128)
		,@source_table						varchar(128)
		,@source_table_config_key			int
		,@source_qualified_name				varchar(512)
		,@source_load_date_time				varchar(128)
		,@source_payload					nvarchar(max)
--  Working Storage
declare @load_details table 
       (source_database_name		varchar(128)
       ,source_table_key		int
	   ,source_table_schema     varchar(128)
	   ,source_table_name		varchar(128)
	   ,source_table_load_type  varchar(50)
	   ,satellite_database      varchar(128)
	   ,satellite_name			varchar(128)
	   ,link_key				int
	   ,link_name				varchar(128)
	   ,link_database			varchar(128)
	   ,hub_key					int
	   ,hub_name				varchar(128)
	   ,hub_database			varchar(128))
	   
	   
-- Log4TSQL Journal Constants 										
DECLARE @SEVERITY_CRITICAL      smallint = 1;
DECLARE @SEVERITY_SEVERE        smallint = 2;
DECLARE @SEVERITY_MAJOR         smallint = 4;
DECLARE @SEVERITY_MODERATE      smallint = 8;
DECLARE @SEVERITY_MINOR         smallint = 16;
DECLARE @SEVERITY_CONCURRENCY   smallint = 32;
DECLARE @SEVERITY_INFORMATION   smallint = 256;
DECLARE @SEVERITY_SUCCESS       smallint = 512;
DECLARE @SEVERITY_DEBUG         smallint = 1024;
DECLARE @NEW_LINE               char(1)  = CHAR(10);

-- Log4TSQL Standard/ExceptionHandler variables
DECLARE	  @_Error         int
		, @_RowCount      int
		, @_Step          varchar(128)
		, @_Message       nvarchar(512)
		, @_ErrorContext  nvarchar(512)

-- Log4TSQL JournalWriter variables
DECLARE   @_FunctionName			varchar(255)
		, @_SprocStartTime			datetime
		, @_JournalOnOff			varchar(3)
		, @_Severity				smallint
		, @_ExceptionId				int
		, @_StepStartTime			datetime
		, @_ProgressText			nvarchar(max)

SET @_Error             = 0;
SET @_FunctionName      = OBJECT_NAME(@@PROCID);
SET @_Severity          = @SEVERITY_INFORMATION;
SET @_SprocStartTime    = sysdatetimeoffset();
SET @_ProgressText      = '' 
SET @_JournalOnOff      = log4.GetJournalControl(@_FunctionName, 'HOWTO');  -- left Group Name as HOWTO for now.

-- set Log4TSQL Parameters for Logging:
SET @_ProgressText		= @_FunctionName + ' starting at ' + CONVERT(char(23), @_SprocStartTime, 121) + ' with inputs: '
						+ @NEW_LINE + '    @vault_source_system_name     : ' + COALESCE(@vault_source_system_name, 'NULL')
						+ @NEW_LINE + '    @vault_source_table_schema    : ' + COALESCE(@vault_source_table_schema, 'NULL')
						+ @NEW_LINE + '    @vault_source_table_name      : ' + COALESCE(@vault_source_table_name, 'NULL')
						+ @NEW_LINE + '    @vault_source_load_type       : ' + COALESCE(@vault_source_load_type, 'NULL')
						+ @NEW_LINE + '    @DoGenerateError              : ' + COALESCE(CAST(@DoGenerateError AS varchar), 'NULL')
						+ @NEW_LINE + '    @DoThrowError                 : ' + COALESCE(CAST(@DoThrowError AS varchar), 'NULL')
						+ @NEW_LINE

BEGIN TRY

SET @_Step = 'Generate any required error';
IF @DoGenerateError = 1
   select 1 / 0
SET @_Step = 'Validate inputs';

IF isnull(@vault_source_load_type, 'Full') not in ('Full', 'Delta')
			RAISERROR('Invalid Load Type: %s', 16, 1, @vault_source_load_type);
--IF isnull(@recreate_flag, '') not in ('Y', 'N') 
--			RAISERROR('Valid values for recreate_flag are Y or N : %s', 16, 1, @recreate_flag);
/*--------------------------------------------------------------------------------------------------------------*/	   
SET @_Step = 'Get Defaults'
-- Object Specific Settings
-- Source Table
select 	 @source_system				= s.[source_system_name]	
        ,@source_database			= s.[timevault_name]
		,@source_schema				= t.[source_table_schema]
		,@source_table				= t.[source_table_name]
		,@source_table_config_key	= t.[source_table_key]
		,@source_qualified_name		= quotename(s.[timevault_name]) + '.' + quotename(t.[source_table_schema]) + '.' + quotename(t.[source_table_name])
from [dbo].[dv_source_system] s
inner join [dbo].[dv_source_table] t
on t.system_key = s.[source_system_key]
where 1=1
and s.[source_system_name]		= @vault_source_system_name
and t.[source_table_schema]		= @vault_source_table_schema
and t.[source_table_name]		= @vault_source_table_name

SET @_Step = 'Get All Components related to the Source Table'	    
insert @load_details            
select  distinct
        ss.timevault_name
       ,st.[source_table_key] as source_table_key
       ,st.source_table_schema	
	   ,st.source_table_name	
	   ,st.source_table_load_type
	   ,s.satellite_database
	   ,s.satellite_name
	   ,l.link_key
	   ,l.link_name
	   ,l.link_database
	   ,case when s.link_hub_satellite_flag = 'H' then h.hub_key		else linkhub.hub_key		end as hub_key
	   ,case when s.link_hub_satellite_flag = 'H' then h.hub_name		else linkhub.hub_name		end as hub_name
	   ,case when s.link_hub_satellite_flag = 'H' then h.hub_database	else linkhub.hub_database	end as hub_database 
from
[dbo].[dv_source_system] ss
inner join [dbo].[dv_source_table] st
on st.system_key = ss.[source_system_key]
inner join [dbo].[dv_column] c
on c.table_key = st.[source_table_key]
inner join [dbo].[dv_satellite_column] sc
on sc.column_key = c.column_key
inner join [dbo].[dv_satellite] s
on s.satellite_key = sc.satellite_key
left join [dbo].[dv_link] l
on s.link_key = l.link_key
and l.link_key > 0
left join [dbo].[dv_hub] h 
on h.hub_key = s.hub_key
and h.hub_key > 0
left join [dbo].[dv_hub_link] hl
on hl.link_key = l.link_key
left join [dbo].[dv_hub] linkhub
on linkhub.hub_key = hl.hub_key
where ss.source_system_name		= @vault_source_system_name
  and st.source_table_schema	= @vault_source_table_schema
  and st.source_table_name		= @vault_source_table_name

/*****************************************************************************************************************/
--Load the Source Table in stages:
--declare @source_database		varchar(128)
--       ,@source_table_schema	varchar(128)
--	   ,@source_table_name		varchar(128)

--select @source_database		= source_database_name
--      ,@source_table_schema = source_table_schema
--	  ,@source_table_name	= source_table_name
--from @load_details
/*****************************************************************************************************************/
SET @_Step = 'Load Hub Tables'
--print ''
--print 'Load Hub Tables'
--print '----------------'
declare @hub_database			varchar(128)
       ,@hub_name				varchar(128)

DECLARE hub_cursor CURSOR FOR  
select distinct 
       hub_database
	  ,hub_name
from @load_details
where hub_name is not null

OPEN hub_cursor   
FETCH NEXT FROM hub_cursor INTO @hub_database, @hub_name  

WHILE @@FETCH_STATUS = 0   
BEGIN   
       SET @_Step = 'Load Hub: ' + @hub_name
	   --print @hub_name
	   --print '/*********\'
	   
	   EXECUTE [dbo].[dv_load_hub_table] @source_system, @source_schema, @source_table, @hub_database, @hub_name
	   FETCH NEXT FROM hub_cursor INTO @hub_database, @hub_name  
END   

CLOSE hub_cursor   
DEALLOCATE hub_cursor


/*****************************************************************************************************************/
SET @_Step = 'Load Link Tables'
--print ''
--print 'Load Link Tables'
--print '----------------'
declare @link_database			varchar(128)
       ,@link_name				varchar(128)

DECLARE link_cursor CURSOR FOR  
select distinct 
       link_database
	  ,link_name
from @load_details
where link_name is not null

OPEN link_cursor   
FETCH NEXT FROM link_cursor INTO @link_database, @link_name  

WHILE @@FETCH_STATUS = 0   
BEGIN   
       SET @_Step = 'Load Link: ' + @link_name
	   --print @link_name
	   --print '/*********\'
	   EXECUTE [dbo].[dv_load_link_table] @source_system, @source_schema, @source_table, @link_database, @link_name 
	   FETCH NEXT FROM link_cursor INTO @link_database, @link_name  
END   

CLOSE link_cursor   
DEALLOCATE link_cursor


/*****************************************************************************************************************/
SET @_Step = 'Load Sat Tables for: ' + @source_database + ' ' + @source_schema + ' ' + @source_table
--print ''
--print 'Load Sat Tables'
--print '----------------'
--print '/*********\'
EXECUTE [dv_load_sats_for_source_table] @source_system, @source_schema, @source_table, @vault_source_load_type
/*--------------------------------------------------------------------------------------------------------------*/

SET @_ProgressText  = @_ProgressText + @NEW_LINE
				+ 'Step: [' + @_Step + '] completed ' 

IF @@TRANCOUNT > 0 COMMIT TRAN;

SET @_Message   = 'Successfully Loaded Object: ' + @source_qualified_name

END TRY
BEGIN CATCH
SET @_ErrorContext	= 'Failed to Load Object: ' + @source_qualified_name
IF (XACT_STATE() = -1) -- uncommitable transaction
OR (@@TRANCOUNT > 0 AND XACT_STATE() != 1) -- undocumented uncommitable transaction
	BEGIN
		ROLLBACK TRAN;
		SET @_ErrorContext = @_ErrorContext + ' (Forced rolled back of all changes)';
	END
	
EXEC log4.ExceptionHandler
		  @ErrorContext  = @_ErrorContext
		, @ErrorNumber   = @_Error OUT
		, @ReturnMessage = @_Message OUT
		, @ExceptionId   = @_ExceptionId OUT
;
END CATCH

--/////////////////////////////////////////////////////////////////////////////////////////////////
OnComplete:
--/////////////////////////////////////////////////////////////////////////////////////////////////

	--! Clean up

	--!
	--! Use dbo.udf_FormatElapsedTime() to get a nicely formatted run time string e.g.
	--! "0 hr(s) 1 min(s) and 22 sec(s)" or "1345 milliseconds"
	--!
	IF @_Error = 0
		BEGIN
			SET @_Step			= 'OnComplete'
			SET @_Severity		= @SEVERITY_SUCCESS
			SET @_Message		= COALESCE(@_Message, @_Step)
								+ ' in a total run time of ' + log4.FormatElapsedTime(@_SprocStartTime, NULL, 3)
			SET @_ProgressText  = @_ProgressText + @NEW_LINE + @_Message;
		END
	ELSE
		BEGIN
			SET @_Step			= COALESCE(@_Step, 'OnError')
			SET @_Severity		= @SEVERITY_SEVERE
			SET @_Message		= COALESCE(@_Message, @_Step)
								+ ' after a total run time of ' + log4.FormatElapsedTime(@_SprocStartTime, NULL, 3)
			SET @_ProgressText  = @_ProgressText + @NEW_LINE + @_Message;
		END

	IF @_JournalOnOff = 'ON'
		EXEC log4.JournalWriter
				  @Task				= @_FunctionName
				, @FunctionName		= @_FunctionName
				, @StepInFunction	= @_Step
				, @MessageText		= @_Message
				, @Severity			= @_Severity
				, @ExceptionId		= @_ExceptionId
				--! Supply all the progress info after we've gone to such trouble to collect it
				, @ExtraInfo        = @_ProgressText

	--! Finally, throw an exception that will be detected by the caller
	IF @DoThrowError = 1 AND @_Error > 0
		RAISERROR(@_Message, 16, 99);

	SET NOCOUNT OFF;

	--! Return the value of @@ERROR (which will be zero on success)
	RETURN (@_Error);
END
GO
PRINT N'Creating [dbo].[dv_create_DV_table]...';


GO
CREATE PROCEDURE [dbo].[dv_create_DV_table]
(
  @object_name                   varchar(128)   = NULL
, @object_schema				 varchar(128)   = NULL
, @object_database				 varchar(128)   = NULL
, @object_filegroup              varchar(128)   = NULL
, @object_type					 varchar(30)    = NULL
, @payload_columns			     [dbo].[dv_column_type] READONLY
, @sat_is_columnstore			 bit			= 0
, @recreate_flag                 char(1)		= 'N'
, @dogenerateerror               bit            = 0
, @dothrowerror                  bit			= 1
)
AS
BEGIN
SET NOCOUNT ON

-- To Do - add Logging for the Payload Parameter
--         validate Parameters properly
--declare @hub_name varchar(100) =  'AdventureWorks2014_production_productinventory'

declare @varobject_name			varchar(128)
--declare @filegroup				varchar(128)
declare @schema					varchar(128)
declare @database				varchar(128)
declare @default_columns		dv_column_type
declare @table_name				varchar(128)
declare @pk_name				varchar(128)
declare @payload_columns_string nvarchar(max)
declare @crlf					char(2) = CHAR(13) + CHAR(10)
declare @SQL					nvarchar(max) = ''

-- Log4TSQL Journal Constants 
DECLARE @SEVERITY_CRITICAL      smallint = 1;
DECLARE @SEVERITY_SEVERE        smallint = 2;
DECLARE @SEVERITY_MAJOR         smallint = 4;
DECLARE @SEVERITY_MODERATE      smallint = 8;
DECLARE @SEVERITY_MINOR         smallint = 16;
DECLARE @SEVERITY_CONCURRENCY   smallint = 32;
DECLARE @SEVERITY_INFORMATION   smallint = 256;
DECLARE @SEVERITY_SUCCESS       smallint = 512;
DECLARE @SEVERITY_DEBUG         smallint = 1024;
DECLARE @NEW_LINE               char(1)  = CHAR(10);

-- Log4TSQL Standard/ExceptionHandler variables
DECLARE	  @_Error         int
		, @_RowCount      int
		, @_Step          varchar(128)
		, @_Message       nvarchar(512)
		, @_ErrorContext  nvarchar(512)

-- Log4TSQL JournalWriter variables
DECLARE   @_FunctionName			varchar(255)
		, @_SprocStartTime			datetime
		, @_JournalOnOff			varchar(3)
		, @_Severity				smallint
		, @_ExceptionId				int
		, @_StepStartTime			datetime
		, @_ProgressText			nvarchar(max)

SET @_Error             = 0;
SET @_FunctionName      = OBJECT_NAME(@@PROCID);
SET @_Severity          = @SEVERITY_INFORMATION;
SET @_SprocStartTime    = sysdatetimeoffset();
SET @_ProgressText      = '' 
SET @_JournalOnOff      = log4.GetJournalControl(@_FunctionName, 'HOWTO');  -- left Group Name as HOWTO for now.

select @payload_columns_string =''
select @payload_columns_string +=  [column_name] + ',' + 'column_type: ' +[column_type] + ', column_length:' + isnull(cast([column_length] as varchar(128)), '<NULL>') + ', column_precision:' + isnull(cast([column_precision] as varchar(128)),'<NULL>') + ', column_scale;' + isnull(cast([column_scale] as varchar(128)), '<NULL>') + ', Collation_Name:' + isnull([Collation_Name], '<NULL>') + @crlf
      from @payload_columns
-- set the Parameters for logging:

SET @_ProgressText		= @_FunctionName + ' starting at ' + CONVERT(char(23), @_SprocStartTime, 121) + ' with inputs: '
						+ @NEW_LINE + '    @object_name                  : ' + COALESCE(@object_name, '<NULL>')
						+ @NEW_LINE + '    @object_schema                : ' + COALESCE(@object_schema, '<NULL>')
						+ @NEW_LINE + '    @object_database              : ' + COALESCE(@object_database, '<NULL>')
						+ @NEW_LINE + '    @object_filegroup             : ' + COALESCE(@object_filegroup, '<NULL>')
						+ @NEW_LINE + '    @object_type                  : ' + COALESCE(@object_type, '<NULL>')
						+ @NEW_LINE + '    @payload_columns              : ' + COALESCE(@payload_columns_string, '<NULL>')
						+ @NEW_LINE + '    @sat_is_columnstore           : ' + COALESCE(CAST(@sat_is_columnstore AS varchar), '<NULL>')
						+ @NEW_LINE + '    @recreate_flag                : ' + COALESCE(@recreate_flag, '<NULL>')
						+ @NEW_LINE + '    @DoGenerateError              : ' + COALESCE(CAST(@DoGenerateError AS varchar), '<NULL>')
						+ @NEW_LINE + '    @DoThrowError                 : ' + COALESCE(CAST(@DoThrowError AS varchar), '<NULL>')
						+ @NEW_LINE

BEGIN TRY
SET @_Step = 'Generate any required error';
IF @DoGenerateError = 1
   select 1 / 0
SET @_Step = 'Validate inputs';

IF isnull(@object_name, '')		= '' RAISERROR('No @object_name: %s', 16, 1, @object_name);
IF isnull(@object_schema, '')	= '' RAISERROR('No @object_schema: %s', 16, 1, @object_schema);
IF isnull(@object_database, '')	= '' RAISERROR('No @object_database: %s', 16, 1, @object_database);
IF isnull(@object_database, '')	= '' RAISERROR('No @object_filegroup: %s', 16, 1, @object_filegroup);
IF isnull(@object_type, '')	not in('Hub', 'Lnk', 'Sat') RAISERROR(' @object_type: %s: Valid Values: Hub, Lnk or Sat', 16, 1, @object_type);
IF isnull(@payload_columns_string, '')	= '' RAISERROR('No @payload_columns: %s', 16, 1, @payload_columns_string);
IF isnull(@recreate_flag, '') not in ('Y', 'N') RAISERROR('Valid values for recreate_flag are Y or N : %s', 16, 1, @recreate_flag);
/*--------------------------------------------------------------------------------------------------------------*/
SET @_Step = 'Get Defaults'

select @varobject_name = [dbo].[fn_get_object_name](@object_name, @object_type)
select @table_name = quotename(@object_database) + '.' + quotename (@object_schema) + '.' + quotename(@varobject_name)

insert @default_columns	
select  [column_name]
       ,[column_type]
       ,[column_length]
	   ,[column_precision]
	   ,[column_scale]
	   ,[collation_Name]
	   ,-1
       ,[ordinal_position]
	   ,-1
	   ,''
	   ,''
from [dbo].[dv_default_column]
where 1=1
and [object_type] = @object_type
and [object_column_type] <> 'Object_Key'

/*--------------------------------------------------------------------------------------------------------------*/
SET @_Step = 'If Recreate then Drop Existing Table'

IF @recreate_flag = 'Y'
BEGIN
	select @SQL += 'IF EXISTS (select 1 from ' + quotename(@object_database) + '.INFORMATION_SCHEMA.TABLES where TABLE_TYPE = ''BASE TABLE'' and TABLE_SCHEMA = ''' + @object_schema + ''' and TABLE_NAME = ''' + @varobject_name + ''')' + @crlf + ' '
	select @SQL += 'DROP TABLE ' + @table_name + @crlf + ' '
END
/*--------------------------------------------------------------------------------------------------------------*/
SET @_Step = 'Create Table Statement'
select @SQL += 'CREATE TABLE ' + @table_name + '(' + @crlf + ' '

/*--------------------------------------------------------------------------------------------------------------*/
SET @_Step = 'Add the Columns'
--1. Primary Key
select @SQL = @SQL + column_name + dbo.[fn_build_column_definition]([column_type], [column_length], [column_precision], [column_scale], [Collation_Name], 0, 1) + @crlf + ',' 
from [fn_get_key_definition](@object_name, @object_type)

--Payload
select @SQL = @SQL + column_name + ' ' + dbo.[fn_build_column_definition]([column_type], [column_length], [column_precision], [column_scale], [Collation_Name], 1, 0) + @crlf + ',' 
from
(select *
from @default_columns) a
order by source_ordinal_position

select @SQL = @SQL + column_name + ' ' + dbo.[fn_build_column_definition]([column_type], [column_length], [column_precision], [column_scale], [Collation_Name], 1, 0) + @crlf + ',' 
from
(select *
from @payload_columns) a
order by satellite_ordinal_position, column_name

/*--------------------------------------------------------------------------------------------------------------*/
SET @_Step = 'Add the Primary Key'
if @sat_is_columnstore = 0
	begin
	select @pk_name = column_name from [fn_get_key_definition](@object_name, @object_type)
	select @SQL += 'PRIMARY KEY CLUSTERED (' + @pk_name + ') ON ' + quotename(@object_filegroup) + @crlf
	end
	
select @SQL += ') ON ' + quotename(@object_filegroup) + ';' + @crlf

/*--------------------------------------------------------------------------------------------------------------*/
SET @_Step = 'Create The Table'
IF @_JournalOnOff = 'ON' SET @_ProgressText  = @_ProgressText + @crlf + @SQL + @crlf
--select @SQL --**************
exec (@SQL)

/*--------------------------------------------------------------------------------------------------------------*/

SET @_ProgressText  = @_ProgressText + @NEW_LINE
				+ 'Step: [' + @_Step + '] completed ' 

IF @@TRANCOUNT > 0 COMMIT TRAN;

SET @_Message   = 'Successfully Created Object: ' + @table_name

END TRY
BEGIN CATCH
SET @_ErrorContext	= 'Failed to Create Object: ' + @table_name
IF (XACT_STATE() = -1) -- uncommitable transaction
OR (@@TRANCOUNT > 0 AND XACT_STATE() != 1) -- undocumented uncommitable transaction
	BEGIN
		ROLLBACK TRAN;
		SET @_ErrorContext = @_ErrorContext + ' (Forced rolled back of all changes)';
	END
	
EXEC log4.ExceptionHandler
		  @ErrorContext  = @_ErrorContext
		, @ErrorNumber   = @_Error OUT
		, @ReturnMessage = @_Message OUT
		, @ExceptionId   = @_ExceptionId OUT
;
END CATCH

--/////////////////////////////////////////////////////////////////////////////////////////////////
OnComplete:
--/////////////////////////////////////////////////////////////////////////////////////////////////

	--! Clean up

	--!
	--! Use dbo.udf_FormatElapsedTime() to get a nicely formatted run time string e.g.
	--! "0 hr(s) 1 min(s) and 22 sec(s)" or "1345 milliseconds"
	--!
	IF @_Error = 0
		BEGIN
			SET @_Step			= 'OnComplete'
			SET @_Severity		= @SEVERITY_SUCCESS
			SET @_Message		= COALESCE(@_Message, @_Step)
								+ ' in a total run time of ' + log4.FormatElapsedTime(@_SprocStartTime, NULL, 3)
			SET @_ProgressText  = @_ProgressText + @NEW_LINE + @_Message;
		END
	ELSE
		BEGIN
			SET @_Step			= COALESCE(@_Step, 'OnError')
			SET @_Severity		= @SEVERITY_SEVERE
			SET @_Message		= COALESCE(@_Message, @_Step)
								+ ' after a total run time of ' + log4.FormatElapsedTime(@_SprocStartTime, NULL, 3)
			SET @_ProgressText  = @_ProgressText + @NEW_LINE + @_Message;
		END

	IF @_JournalOnOff = 'ON'
		EXEC log4.JournalWriter
				  @Task				= @_FunctionName
				, @FunctionName		= @_FunctionName
				, @StepInFunction	= @_Step
				, @MessageText		= @_Message
				, @Severity			= @_Severity
				, @ExceptionId		= @_ExceptionId
				--! Supply all the progress info after we've gone to such trouble to collect it
				, @ExtraInfo        = @_ProgressText

	--! Finally, throw an exception that will be detected by the caller
	IF @DoThrowError = 1 AND @_Error > 0
		RAISERROR(@_Message, 16, 99);

	SET NOCOUNT OFF;

	--! Return the value of @@ERROR (which will be zero on success)
	RETURN (@_Error);
END
GO
PRINT N'Creating [dbo].[dv_create_hub_table]...';


GO
CREATE PROCEDURE [dbo].[dv_create_hub_table]
(
  @vault_database			varchar(128)	= NULL
, @vault_hub_name			varchar(128)	= NULL
, @recreate_flag                 char(1)		= 'N'
, @dogenerateerror			bit				= 0
, @dothrowerror				bit				= 1
)
AS
BEGIN
SET NOCOUNT ON

declare @filegroup		varchar(256)
declare @schema			varchar(256)
declare @database		varchar(256)
declare @table_name		varchar(256)
declare @pk_name		varchar(256)
declare @crlf			char(2) = CHAR(13) + CHAR(10)
declare @SQL			varchar(4000) = ''
declare @varobject_name varchar(128)

-- Log4TSQL Journal Constants 
DECLARE @SEVERITY_CRITICAL      smallint = 1;
DECLARE @SEVERITY_SEVERE        smallint = 2;
DECLARE @SEVERITY_MAJOR         smallint = 4;
DECLARE @SEVERITY_MODERATE      smallint = 8;
DECLARE @SEVERITY_MINOR         smallint = 16;
DECLARE @SEVERITY_CONCURRENCY   smallint = 32;
DECLARE @SEVERITY_INFORMATION   smallint = 256;
DECLARE @SEVERITY_SUCCESS       smallint = 512;
DECLARE @SEVERITY_DEBUG         smallint = 1024;
DECLARE @NEW_LINE               char(1)  = CHAR(10);

-- Log4TSQL Standard/ExceptionHandler variables
DECLARE	  @_Error         int
		, @_RowCount      int
		, @_Step          varchar(128)
		, @_Message       nvarchar(512)
		, @_ErrorContext  nvarchar(512)

-- Log4TSQL JournalWriter variables
DECLARE   @_FunctionName			varchar(255)
		, @_SprocStartTime			datetime
		, @_JournalOnOff			varchar(3)
		, @_Severity				smallint
		, @_ExceptionId				int
		, @_StepStartTime			datetime
		, @_ProgressText			nvarchar(max)

SET @_Error             = 0;
SET @_FunctionName      = OBJECT_NAME(@@PROCID);
SET @_Severity          = @SEVERITY_INFORMATION;
SET @_SprocStartTime    = sysdatetimeoffset();
SET @_ProgressText      = '' 
SET @_JournalOnOff      = log4.GetJournalControl(@_FunctionName, 'HOWTO');  -- left Group Name as HOWTO for now.


-- set the Parameters for logging:
SET @_ProgressText		= @_FunctionName + ' starting at ' + CONVERT(char(23), @_SprocStartTime, 121) + ' with inputs: '
						+ @NEW_LINE + '    @vault_database               : ' + COALESCE(@vault_database, '<NULL>')
						+ @NEW_LINE + '    @vault_hub_name               : ' + COALESCE(@vault_hub_name, '<NULL>')
						+ @NEW_LINE + '    @recreate_flag                : ' + COALESCE(@recreate_flag, '<NULL>')
						+ @NEW_LINE + '    @DoGenerateError              : ' + COALESCE(CAST(@DoGenerateError AS varchar), '<NULL>')
						+ @NEW_LINE + '    @DoThrowError                 : ' + COALESCE(CAST(@DoThrowError AS varchar), '<NULL>')
						+ @NEW_LINE

BEGIN TRY
SET @_Step = 'Generate any required error';
IF @DoGenerateError = 1
   select 1 / 0
SET @_Step = 'Validate inputs';

IF (select count(*) from [dbo].[dv_hub] where [hub_database] = @vault_database and [hub_name] = @vault_hub_name) <> 1
			RAISERROR('Invalid Hub Name: %s', 16, 1, @vault_hub_name);
IF isnull(@recreate_flag, '') not in ('Y', 'N') 
			RAISERROR('Valid values for recreate_flag are Y or N : %s', 16, 1, @recreate_flag);
/*--------------------------------------------------------------------------------------------------------------*/
SET @_Step = 'Get required Parameters'

declare @payload_columns [dbo].[dv_column_type]

select @database = [hub_database]
      ,@schema = [hub_schema]
	  ,@filegroup = null
from [dbo].[dv_hub]
where 1=1
   and [hub_database] = @vault_database
   and [hub_name]	  = @vault_hub_name

insert @payload_columns
select  hkc.[hub_key_column_name]
       ,hkc.[hub_key_column_type]
       ,hkc.[hub_key_column_length]
	   ,hkc.[hub_key_column_precision]
	   ,hkc.[hub_key_column_scale]
	   ,hkc.[hub_key_collation_name]
	   ,hkc.[hub_key_ordinal_position]
       ,hkc.[hub_key_ordinal_position]
	   ,hkc.[hub_key_ordinal_position]
	   ,''
	   ,''
  FROM [dbo].[dv_hub] h
  inner join [dbo].[dv_hub_key_column] hkc
  on h.hub_key = hkc.hub_key
  where 1=1
   and h.[hub_database] = @vault_database
   and h.[hub_name]		= @vault_hub_name

select @varobject_name = [dbo].[fn_get_object_name](@vault_hub_name, 'hub')
select @table_name = quotename(@database) + '.' + quotename (@schema) + '.' + quotename(@varobject_name)
select @filegroup = coalesce(cast([dbo].[fn_get_default_value] ('filegroup','hub') as varchar(128)), 'Primary')

/*--------------------------------------------------------------------------------------------------------------*/
SET @_Step = 'Create The Hub'

EXECUTE [dbo].[dv_create_DV_table] 
   @vault_hub_name
  ,@schema
  ,@database
  ,@filegroup
  ,'Hub'
  ,@payload_columns
  ,0
  ,@recreate_flag
  ,@dogenerateerror
  ,@dothrowerror

/*--------------------------------------------------------------------------------------------------------------*/
SET @_Step = 'Index the Hub on the Business Key'
select @SQL = ''
select @SQL += 'CREATE UNIQUE NONCLUSTERED INDEX ' + quotename('UX__' + @varobject_name + cast(newid() as varchar(56))) 
	select @SQL += ' ON ' + @table_name + '(' + @crlf + ' '
	select @SQL = @SQL + rtrim(quotename(column_name)) + @crlf +  ','
		from @payload_columns
		order by bk_ordinal_position
	select @SQL = left(@SQL, len(@SQL) -1) + ') ON ' + quotename(@filegroup) + @crlf

/*--------------------------------------------------------------------------------------------------------------*/
SET @_Step = 'Create The Index'
IF @_JournalOnOff = 'ON'
	SET @_ProgressText += @SQL
--print @SQL
exec (@SQL)

/*--------------------------------------------------------------------------------------------------------------*/

SET @_ProgressText  = @_ProgressText + @NEW_LINE
				+ 'Step: [' + @_Step + '] completed ' 

IF @@TRANCOUNT > 0 COMMIT TRAN;

SET @_Message   = 'Successfully Created Hub: ' + @table_name

END TRY
BEGIN CATCH
SET @_ErrorContext	= 'Failed to Create Hub: ' + @table_name
IF (XACT_STATE() = -1) -- uncommitable transaction
OR (@@TRANCOUNT > 0 AND XACT_STATE() != 1) -- undocumented uncommitable transaction
	BEGIN
		ROLLBACK TRAN;
		SET @_ErrorContext = @_ErrorContext + ' (Forced rolled back of all changes)';
	END
	
EXEC log4.ExceptionHandler
		  @ErrorContext  = @_ErrorContext
		, @ErrorNumber   = @_Error OUT
		, @ReturnMessage = @_Message OUT
		, @ExceptionId   = @_ExceptionId OUT
;
END CATCH

--/////////////////////////////////////////////////////////////////////////////////////////////////
OnComplete:
--/////////////////////////////////////////////////////////////////////////////////////////////////

	--! Clean up

	--!
	--! Use dbo.udf_FormatElapsedTime() to get a nicely formatted run time string e.g.
	--! "0 hr(s) 1 min(s) and 22 sec(s)" or "1345 milliseconds"
	--!
	IF @_Error = 0
		BEGIN
			SET @_Step			= 'OnComplete'
			SET @_Severity		= @SEVERITY_SUCCESS
			SET @_Message		= COALESCE(@_Message, @_Step)
								+ ' in a total run time of ' + log4.FormatElapsedTime(@_SprocStartTime, NULL, 3)
			SET @_ProgressText  = @_ProgressText + @NEW_LINE + @_Message;
		END
	ELSE
		BEGIN
			SET @_Step			= COALESCE(@_Step, 'OnError')
			SET @_Severity		= @SEVERITY_SEVERE
			SET @_Message		= COALESCE(@_Message, @_Step)
								+ ' after a total run time of ' + log4.FormatElapsedTime(@_SprocStartTime, NULL, 3)
			SET @_ProgressText  = @_ProgressText + @NEW_LINE + @_Message;
		END

	IF @_JournalOnOff = 'ON'
		EXEC log4.JournalWriter
				  @Task				= @_FunctionName
				, @FunctionName		= @_FunctionName
				, @StepInFunction	= @_Step
				, @MessageText		= @_Message
				, @Severity			= @_Severity
				, @ExceptionId		= @_ExceptionId
				--! Supply all the progress info after we've gone to such trouble to collect it
				, @ExtraInfo        = @_ProgressText

	--! Finally, throw an exception that will be detected by the caller
	IF @DoThrowError = 1 AND @_Error > 0
		RAISERROR(@_Message, 16, 99);

	SET NOCOUNT OFF;

	--! Return the value of @@ERROR (which will be zero on success)
	RETURN (@_Error);
END
GO
PRINT N'Creating [dbo].[dv_create_link_table]...';


GO
CREATE PROCEDURE [dbo].[dv_create_link_table]
(
  @vault_database				varchar(256)	= NULL
, @vault_link_name				varchar(256)	= NULL
, @recreate_flag                 char(1)		= 'N'
, @DoGenerateError               bit            = 0
, @DoThrowError                  bit			= 1
)
AS
BEGIN
SET NOCOUNT ON

declare @filegroup		varchar(256)
declare @schema			varchar(256)
declare @database		varchar(256)
declare @table_name		varchar(256)
declare @crlf			char(2) = CHAR(13) + CHAR(10)
declare @SQL			varchar(4000) = ''
declare @varobject_name varchar(128)

-- Log4TSQL Journal Constants 
DECLARE @SEVERITY_CRITICAL      smallint = 1;
DECLARE @SEVERITY_SEVERE        smallint = 2;
DECLARE @SEVERITY_MAJOR         smallint = 4;
DECLARE @SEVERITY_MODERATE      smallint = 8;
DECLARE @SEVERITY_MINOR         smallint = 16;
DECLARE @SEVERITY_CONCURRENCY   smallint = 32;
DECLARE @SEVERITY_INFORMATION   smallint = 256;
DECLARE @SEVERITY_SUCCESS       smallint = 512;
DECLARE @SEVERITY_DEBUG         smallint = 1024;
DECLARE @NEW_LINE               char(1)  = CHAR(10);

-- Log4TSQL Standard/ExceptionHandler variables
DECLARE	  @_Error         int
		, @_RowCount      int
		, @_Step          varchar(128)
		, @_Message       nvarchar(512)
		, @_ErrorContext  nvarchar(512)

-- Log4TSQL JournalWriter variables
DECLARE   @_FunctionName			varchar(255)
		, @_SprocStartTime			datetime
		, @_JournalOnOff			varchar(3)
		, @_Severity				smallint
		, @_ExceptionId				int
		, @_StepStartTime			datetime
		, @_ProgressText			nvarchar(max)

SET @_Error             = 0;
SET @_FunctionName      = OBJECT_NAME(@@PROCID);
SET @_Severity          = @SEVERITY_INFORMATION;
SET @_SprocStartTime    = sysdatetimeoffset();
SET @_ProgressText      = '' 
SET @_JournalOnOff      = log4.GetJournalControl(@_FunctionName, 'HOWTO');  -- left Group Name as HOWTO for now.


-- set the Parameters for logging:
SET @_ProgressText		= @_FunctionName + ' starting at ' + CONVERT(char(23), @_SprocStartTime, 121) + ' with inputs: '
						+ @NEW_LINE + '    @vault_database               : ' + COALESCE(@vault_database, '<NULL>')
						+ @NEW_LINE + '    @vault_link_name              : ' + COALESCE(@vault_link_name, '<NULL>')
						+ @NEW_LINE + '    @recreate_flag                : ' + COALESCE(@recreate_flag, '<NULL>')
						+ @NEW_LINE + '    @DoGenerateError              : ' + COALESCE(CAST(@DoGenerateError AS varchar), '<NULL>')
						+ @NEW_LINE + '    @DoThrowError                 : ' + COALESCE(CAST(@DoThrowError AS varchar), '<NULL>')
						+ @NEW_LINE

BEGIN TRY
SET @_Step = 'Generate any required error';
IF @DoGenerateError = 1
   select 1 / 0
SET @_Step = 'Validate inputs';

IF (select count(*) from [dbo].[dv_link] where [link_database]= @vault_database and [link_name] = @vault_link_name) <> 1
			RAISERROR('Invalid link Name: %s', 16, 1, @vault_link_name);
IF isnull(@recreate_flag, '') not in ('Y', 'N') 
			RAISERROR('Valid values for recreate_flag are Y or N : %s', 16, 1, @recreate_flag);
/*--------------------------------------------------------------------------------------------------------------*/
SET @_Step = 'Get required Parameters'

declare @payload_columns [dbo].[dv_column_type]

select @database = [link_database]
      ,@schema = [link_schema]
	  ,@filegroup = null
from [dbo].[dv_link]
where 1=1
  and [link_database] = @vault_database
  and [link_name]	  = @vault_link_name

insert @payload_columns
select hd.[column_name]
       ,hd.[column_type]
       ,hd.[column_length]
	   ,hd.[column_precision]
	   ,hd.[column_scale]
	   ,hd.[collation_Name]
	   ,1
       ,hd.[ordinal_position]
	   ,1 
	   ,''
	   ,''
FROM [dbo].[dv_link] l
inner join [dbo].[dv_hub_link] hl
on l.link_key = hl.link_key
inner join [dbo].[dv_hub] h
on h.hub_key = hl.hub_key
cross apply [fn_get_key_definition](h.hub_name, 'hub') hd
where l.[link_name] = @vault_link_name

select @varobject_name = [dbo].[fn_get_object_name](@vault_link_name, 'lnk')
select @table_name = quotename(@database) + '.' + quotename (@schema) + '.' + quotename(@varobject_name)
select @filegroup = coalesce(cast([dbo].[fn_get_default_value] ('filegroup','lnk') as varchar(128)), 'Primary')

/*--------------------------------------------------------------------------------------------------------------*/
SET @_Step = 'Create the Link'

EXECUTE [dbo].[dv_create_DV_table] 
   @vault_link_name
  ,@schema
  ,@database
  ,@filegroup
  ,'lnk'
  ,@payload_columns
  ,0
  ,@recreate_flag
  ,@dogenerateerror
  ,@dothrowerror

/*--------------------------------------------------------------------------------------------------------------*/
SET @_Step = 'Index the Link on the Hub Keys'
select @SQL = ''
select @SQL += 'CREATE UNIQUE NONCLUSTERED INDEX ' + quotename('UX__' + @varobject_name + cast(newid() as varchar(56))) 
	select @SQL += ' ON ' + @table_name + '(' + @crlf + ' '
	select @SQL = @SQL + rtrim(column_name) + @crlf +  ','
		from @payload_columns
		order by column_name
	select @SQL = left(@SQL, len(@SQL) -1) + ') ON ' + quotename(@filegroup) + @crlf 

/*--------------------------------------------------------------------------------------------------------------*/
SET @_Step = 'Create The Index'
IF @_JournalOnOff = 'ON'
	SET @_ProgressText += @SQL
--print @SQL
exec (@SQL)

/*--------------------------------------------------------------------------------------------------------------*/
IF @@TRANCOUNT > 0 COMMIT TRAN;

SET @_Message   = 'Successfully Created link: ' + @table_name

END TRY
BEGIN CATCH
SET @_ErrorContext	= 'Failed to Create link: ' + @table_name
IF (XACT_STATE() = -1) -- uncommitable transaction
OR (@@TRANCOUNT > 0 AND XACT_STATE() != 1) -- undocumented uncommitable transaction
	BEGIN
		ROLLBACK TRAN;
		SET @_ErrorContext = @_ErrorContext + ' (Forced rolled back of all changes)';
	END
	
EXEC log4.ExceptionHandler
		  @ErrorContext  = @_ErrorContext
		, @ErrorNumber   = @_Error OUT
		, @ReturnMessage = @_Message OUT
		, @ExceptionId   = @_ExceptionId OUT
;
END CATCH

--/////////////////////////////////////////////////////////////////////////////////////////////////
OnComplete:
--/////////////////////////////////////////////////////////////////////////////////////////////////

	--! Clean up

	--!
	--! Use dbo.udf_FormatElapsedTime() to get a nicely formatted run time string e.g.
	--! "0 hr(s) 1 min(s) and 22 sec(s)" or "1345 milliseconds"
	--!
	IF @_Error = 0
		BEGIN
			SET @_Step			= 'OnComplete'
			SET @_Severity		= @SEVERITY_SUCCESS
			SET @_Message		= COALESCE(@_Message, @_Step)
								+ ' in a total run time of ' + log4.FormatElapsedTime(@_SprocStartTime, NULL, 3)
			SET @_ProgressText  = @_ProgressText + @NEW_LINE + @_Message;
		END
	ELSE
		BEGIN
			SET @_Step			= COALESCE(@_Step, 'OnError')
			SET @_Severity		= @SEVERITY_SEVERE
			SET @_Message		= COALESCE(@_Message, @_Step)
								+ ' after a total run time of ' + log4.FormatElapsedTime(@_SprocStartTime, NULL, 3)
			SET @_ProgressText  = @_ProgressText + @NEW_LINE + @_Message;
		END

	IF @_JournalOnOff = 'ON'
		EXEC log4.JournalWriter
				  @Task				= @_FunctionName
				, @FunctionName		= @_FunctionName
				, @StepInFunction	= @_Step
				, @MessageText		= @_Message
				, @Severity			= @_Severity
				, @ExceptionId		= @_ExceptionId
				--! Supply all the progress info after we've gone to such trouble to collect it
				, @ExtraInfo        = @_ProgressText

	--! Finally, throw an exception that will be detected by the caller
	IF @DoThrowError = 1 AND @_Error > 0
		RAISERROR(@_Message, 16, 99);

	SET NOCOUNT OFF;

	--! Return the value of @@ERROR (which will be zero on success)
	RETURN (@_Error);
END
GO
PRINT N'Creating [dbo].[dv_create_sat_table]...';


GO
CREATE PROCEDURE [dbo].[dv_create_sat_table]
(
  @vault_database                varchar(128)   = NULL
, @vault_sat_name                varchar(128)   = NULL
, @recreate_flag                 char(1)		= 'N'
, @DoGenerateError               bit            = 0
, @DoThrowError                  bit			= 1
)
AS
BEGIN
SET NOCOUNT ON

DECLARE @crlf								char(2)			= CHAR(13) + CHAR(10)
-- Global Defaults
DECLARE  
		 @def_global_lowdate				datetime
        ,@def_global_highdate				datetime
        ,@def_global_default_load_date_time	varchar(128)
		,@def_global_failed_lookup_key		int
-- Hub Defaults									
        ,@def_hub_prefix					varchar(128)
		,@def_hub_schema					varchar(128)
		,@def_hub_filegroup					varchar(128)
--Link Defaults									
		,@def_link_prefix					varchar(128)
		,@def_link_schema					varchar(128)
		,@def_link_filegroup				varchar(128)
--Sat Defaults									
		,@def_sat_prefix					varchar(128)
		,@def_sat_schema					varchar(128)
		,@def_sat_filegroup					varchar(128)
		,@sat_start_date_col				varchar(128)
		,@sat_end_date_col					varchar(128)
		,@sat_current_row_col				varchar(128)				

-- Object Specific Settings
-- Source Table
		,@source_system						varchar(128)
		,@source_database					varchar(128)
		,@source_schema						varchar(128)
		,@source_table						varchar(128)
		,@source_table_config_key			int
		,@source_qualified_name				varchar(512)
		,@source_load_date_time				varchar(128)
		,@source_payload					nvarchar(max)
-- Hub Table
		,@hub_database						varchar(128)
		,@hub_schema						varchar(128)
		,@hub_table							varchar(128)
		,@hub_surrogate_keyname				varchar(128)
		,@hub_config_key					int
		,@hub_qualified_name				varchar(512)
		,@hubt_technical_columns			nvarchar(max)
-- Link Table
		,@link_database						varchar(128)
		,@link_schema						varchar(128)
		,@link_table						varchar(128)
		,@link_surrogate_keyname			varchar(128)
		,@link_config_key					int
		,@link_qualified_name				varchar(512)
		,@link_technical_columns			nvarchar(max)
		,@link_lookup_joins					nvarchar(max)
		,@link_hub_keys						nvarchar(max)
-- Sat Table
		,@sat_database						varchar(128)
		,@sat_schema						varchar(128)
		,@sat_table							varchar(128)
		,@sat_surrogate_keyname				varchar(128)
		,@hub_link_surrogate_key			varchar(128)
		,@sat_config_key					int
		,@sat_link_hub_flag					char(1)
		,@sat_qualified_name				varchar(512)
		,@sat_tombstone_indicator			varchar(50)
		,@sat_is_columnstore				bit
		,@sat_technical_columns				nvarchar(max)
		,@sat_payload						nvarchar(max)

-- Working Storage

DECLARE  @sql						nvarchar(max)
        ,@payload_columns           [dbo].[dv_column_type]

-- Log4TSQL Journal Constants 
DECLARE @SEVERITY_CRITICAL      smallint = 1;
DECLARE @SEVERITY_SEVERE        smallint = 2;
DECLARE @SEVERITY_MAJOR         smallint = 4;
DECLARE @SEVERITY_MODERATE      smallint = 8;
DECLARE @SEVERITY_MINOR         smallint = 16;
DECLARE @SEVERITY_CONCURRENCY   smallint = 32;
DECLARE @SEVERITY_INFORMATION   smallint = 256;
DECLARE @SEVERITY_SUCCESS       smallint = 512;
DECLARE @SEVERITY_DEBUG         smallint = 1024;
DECLARE @NEW_LINE               char(1)  = CHAR(10);

-- Log4TSQL Standard/ExceptionHandler variables
DECLARE	  @_Error         int
		, @_RowCount      int
		, @_Step          varchar(128)
		, @_Message       nvarchar(512)
		, @_ErrorContext  nvarchar(512)

-- Log4TSQL JournalWriter variables
DECLARE   @_FunctionName			varchar(255)
		, @_SprocStartTime			datetime
		, @_JournalOnOff			varchar(3)
		, @_Severity				smallint
		, @_ExceptionId				int
		, @_StepStartTime			datetime
		, @_ProgressText			nvarchar(max)

SET @_Error             = 0;
SET @_FunctionName      = OBJECT_NAME(@@PROCID);
SET @_Severity          = @SEVERITY_INFORMATION;
SET @_SprocStartTime    = sysdatetimeoffset();
SET @_ProgressText      = '' 
SET @_JournalOnOff      = log4.GetJournalControl(@_FunctionName, 'HOWTO');  -- left Group Name as HOWTO for now.


-- set the Parameters for logging:
SET @_ProgressText		= @_FunctionName + ' starting at ' + CONVERT(char(23), @_SprocStartTime, 121) + ' with inputs: '
						+ @NEW_LINE + '    @vault_database               : ' + COALESCE(@vault_database, '<NULL>')
						+ @NEW_LINE + '    @vault_sat_name               : ' + COALESCE(@vault_sat_name, '<NULL>')
						+ @NEW_LINE + '    @recreate_flag                : ' + COALESCE(@recreate_flag, '<NULL>')
						+ @NEW_LINE + '    @DoGenerateError              : ' + COALESCE(CAST(@DoGenerateError AS varchar), '<NULL>')
						+ @NEW_LINE + '    @DoThrowError                 : ' + COALESCE(CAST(@DoThrowError AS varchar), '<NULL>')
						+ @NEW_LINE

BEGIN TRY
SET @_Step = 'Generate any required error';
IF @DoGenerateError = 1
   select 1 / 0
SET @_Step = 'Validate inputs';

IF (select count(*) from [dbo].[dv_satellite] where [satellite_database] = @vault_database and [satellite_name] = @vault_sat_name) <> 1
			RAISERROR('Invalid Sat Name: %s', 16, 1, @vault_sat_name);
IF isnull(@recreate_flag, '') not in ('Y', 'N') 
			RAISERROR('Valid values for recreate_flag are Y or N : %s', 16, 1, @recreate_flag);
/*--------------------------------------------------------------------------------------------------------------*/
SET @_Step = 'Get required Parameters'

SET @_Step = 'Get Defaults'
-- System Wide Defaults
select
-- Global Defaults
 @def_global_lowdate				= cast([dbo].[fn_get_default_value] ('LowDate','Global')				as datetime)			
,@def_global_highdate				= cast([dbo].[fn_get_default_value] ('HighDate','Global')				as datetime)	
,@def_global_default_load_date_time	= cast([dbo].[fn_get_default_value] ('DefaultLoadDateTime','Global')	as varchar(128))
,@def_global_failed_lookup_key		= cast([dbo].[fn_get_default_value] ('FailedLookupKey', 'Global')     as integer)

-- Hub Defaults								
,@def_hub_prefix					= cast([dbo].[fn_get_default_value] ('prefix','hub')					as varchar(128))	
,@def_hub_schema					= cast([dbo].[fn_get_default_value] ('schema','hub')					as varchar(128))	
,@def_hub_filegroup					= cast([dbo].[fn_get_default_value] ('filegroup','hub')				as varchar(128))	
-- Link Defaults																						
,@def_link_prefix					= cast([dbo].[fn_get_default_value] ('prefix','lnk')					as varchar(128))	
,@def_link_schema					= cast([dbo].[fn_get_default_value] ('schema','lnk')					as varchar(128))	
,@def_link_filegroup				= cast([dbo].[fn_get_default_value] ('filegroup','lnk')				as varchar(128))	
-- Sat Defaults																							
,@def_sat_prefix					= cast([dbo].[fn_get_default_value] ('prefix','sat')					as varchar(128))	
,@def_sat_schema					= cast([dbo].[fn_get_default_value] ('schema','sat')					as varchar(128))	
,@def_sat_filegroup					= cast([dbo].[fn_get_default_value] ('filegroup','sat')				as varchar(128))

--Satellite Details
select @sat_start_date_col = quotename(column_name)
from [dbo].[dv_default_column]
where 1=1
and object_type	= 'sat'
and object_column_type = 'Version_Start_Date'
select @sat_end_date_col = quotename(column_name)
from [dbo].[dv_default_column]
where 1=1
and object_type	= 'sat'
and object_column_type = 'Version_End_Date'
select @sat_current_row_col = quotename(column_name)
from [dbo].[dv_default_column]
where 1=1
and object_type	= 'sat'
and object_column_type = 'Current_Row'

select @sat_tombstone_indicator = quotename(column_name)
from [dbo].[dv_default_column]
where 1=1
and object_type	= 'sat'
and object_column_type = 'Tombstone_Indicator'


-- Get Satellite Specifics
select 	 @sat_database			= sat.[satellite_database]						
		,@sat_schema			= coalesce(sat.[satellite_schema], @def_sat_schema, 'dbo')		
		,@sat_table				= sat.[satellite_name]		
		,@sat_surrogate_keyname	= [dbo].[fn_get_object_name] (sat.[satellite_name],'SatSurrogate')		
		,@sat_config_key		= sat.[satellite_key]		
		,@sat_link_hub_flag		= sat.[link_hub_satellite_flag]
		,@sat_is_columnstore	= sat.[is_columnstore]		
		,@sat_qualified_name	= quotename(sat.[satellite_database]) + '.' + quotename(coalesce(sat.[satellite_schema], @def_sat_schema, 'dbo')) + '.' + quotename((select [dbo].[fn_get_object_name] (sat.[satellite_name], 'sat')))       
from [dbo].[dv_column] c
inner join [dbo].[dv_satellite_column] sc
on sc.column_key = c.column_key
inner join [dbo].[dv_satellite] sat
on sat.satellite_key = sc.satellite_key
where 1=1
and sat.[satellite_database] = @vault_database
and sat.[satellite_name]	 = @vault_sat_name
and isnull(c.discard_flag, 0) <> 1 


if @sat_link_hub_flag = 'H'
insert @payload_columns
select top 1 k.[column_name]
       ,k.[column_type]
       ,k.[column_length]
	   ,k.[column_precision]
	   ,k.[column_scale]
	   ,k.[collation_Name]
	   ,k.[bk_ordinal_position]
       ,k.[ordinal_position]
	   ,0 --k.[satellite_ordinal_position]
	   ,''
	   ,''
  FROM [dbo].[dv_satellite] s
  inner join [dbo].[dv_satellite_column] hc
  on s.satellite_key = hc.satellite_key
  inner join [dbo].[dv_column] c
  on hc.column_key = c.column_key
  inner join [dbo].[dv_hub] h
  on s.[hub_key] = h.[hub_key]
  cross apply [dbo].[fn_get_key_definition] (h.hub_name, 'hub') k
  where s.[satellite_key] = @sat_config_key
else 
insert @payload_columns
select top 1 k.[column_name]
       ,k.[column_type]
       ,k.[column_length]
	   ,k.[column_precision]
	   ,k.[column_scale]
	   ,k.[collation_Name]
	   ,k.[bk_ordinal_position]
       ,k.[ordinal_position]
	   ,0 --k.[satellite_ordinal_position]
	   ,''
	   ,''
  FROM [dbo].[dv_satellite] s
  inner join [dbo].[dv_satellite_column] hc
  on s.satellite_key = hc.satellite_key
  inner join [dbo].[dv_column] c
  on hc.column_key = c.column_key
  inner join [dbo].[dv_link] l
  on s.[link_key] = l.[link_key]
  cross apply [dbo].[fn_get_key_definition] (l.link_name, 'lnk') k
  where s.[satellite_key] = @sat_config_key

select @hub_link_surrogate_key = [column_name] from @payload_columns

insert @payload_columns
select  c.[column_name]
       ,c.[column_type]
       ,c.[column_length]
	   ,c.[column_precision]
	   ,c.[column_scale]
	   ,c.[collation_Name]
	   ,c.[bk_ordinal_position]
       ,c.[source_ordinal_position]
	   ,c.[satellite_ordinal_position]
	   ,''
	   ,''
  FROM [dbo].[dv_satellite] s
  inner join [dbo].[dv_satellite_column] hc
  on s.satellite_key = hc.satellite_key
  inner join [dbo].[dv_column] c
  on hc.column_key = c.column_key
  where 1=1
  and s.[satellite_key] = @sat_config_key
  and isnull(c.discard_flag, 0) <> 1 

 /*--------------------------------------------------------------------------------------------------------------*/
SET @_Step = 'Create The Sat'

EXECUTE [dbo].[dv_create_DV_table] 
   @sat_table
  ,@sat_schema
  ,@sat_database
  ,@def_sat_filegroup
  ,'Sat'
  ,@payload_columns
  ,@sat_is_columnstore
  ,@recreate_flag
  ,@dogenerateerror
  ,@dothrowerror

/*--------------------------------------------------------------------------------------------------------------*/
SET @_Step = 'Index the Sat on the Surrogate Key Plus Row End Date'
select @SQL = ''
if @sat_is_columnstore = 0
	begin
	select @SQL += 'CREATE UNIQUE NONCLUSTERED INDEX ' + quotename('UX__' + @sat_table + cast(newid() as varchar(56))) 
	select @SQL += ' ON ' + @sat_qualified_name + '(' + @crlf + ' '
	--select @SQL = @SQL + @hub_link_surrogate_key + ',' + @sat_end_date_col +',' + @sat_current_row_col + ',' + @sat_tombstone_indicator	
	select @SQL = @SQL + @hub_link_surrogate_key + ',' + @sat_start_date_col 	
	select @SQL = @SQL + ') INCLUDE(' + @sat_current_row_col +',' + @sat_tombstone_indicator + ') ON ' + quotename(@def_sat_filegroup) + @crlf
	end
else
	begin
	select @SQL += 'CREATE CLUSTERED COLUMNSTORE INDEX ' + quotename('CCX__' + @sat_table + cast(newid() as varchar(56)))
	select @SQL += ' ON ' + @sat_qualified_name + @crlf + ' ' 
	end
/*--------------------------------------------------------------------------------------------------------------*/
SET @_Step = 'Create The Index'
IF @_JournalOnOff = 'ON' SET @_ProgressText  = @_ProgressText + @crlf + @SQL + @crlf
--select @SQL
exec (@SQL)

/*--------------------------------------------------------------------------------------------------------------*/

SET @_ProgressText  = @_ProgressText + @NEW_LINE
				+ 'Step: [' + @_Step + '] completed ' 

IF @@TRANCOUNT > 0 COMMIT TRAN;

SET @_Message   = 'Successfully Created Sat: ' + @sat_table

END TRY
BEGIN CATCH
SET @_ErrorContext	= 'Failed to Create Sat: ' + @sat_table
IF (XACT_STATE() = -1) -- uncommitable transaction
OR (@@TRANCOUNT > 0 AND XACT_STATE() != 1) -- undocumented uncommitable transaction
	BEGIN
		ROLLBACK TRAN;
		SET @_ErrorContext = @_ErrorContext + ' (Forced rolled back of all changes)';
	END
	
EXEC log4.ExceptionHandler
		  @ErrorContext  = @_ErrorContext
		, @ErrorNumber   = @_Error OUT
		, @ReturnMessage = @_Message OUT
		, @ExceptionId   = @_ExceptionId OUT
;
END CATCH

--/////////////////////////////////////////////////////////////////////////////////////////////////
OnComplete:
--/////////////////////////////////////////////////////////////////////////////////////////////////

	--! Clean up

	--!
	--! Use dbo.udf_FormatElapsedTime() to get a nicely formatted run time string e.g.
	--! "0 hr(s) 1 min(s) and 22 sec(s)" or "1345 milliseconds"
	--!
	IF @_Error = 0
		BEGIN
			SET @_Step			= 'OnComplete'
			SET @_Severity		= @SEVERITY_SUCCESS
			SET @_Message		= COALESCE(@_Message, @_Step)
								+ ' in a total run time of ' + log4.FormatElapsedTime(@_SprocStartTime, NULL, 3)
			SET @_ProgressText  = @_ProgressText + @NEW_LINE + @_Message;
		END
	ELSE
		BEGIN
			SET @_Step			= COALESCE(@_Step, 'OnError')
			SET @_Severity		= @SEVERITY_SEVERE
			SET @_Message		= COALESCE(@_Message, @_Step)
								+ ' after a total run time of ' + log4.FormatElapsedTime(@_SprocStartTime, NULL, 3)
			SET @_ProgressText  = @_ProgressText + @NEW_LINE + @_Message;
		END

	IF @_JournalOnOff = 'ON'
		EXEC log4.JournalWriter
				  @Task				= @_FunctionName
				, @FunctionName		= @_FunctionName
				, @StepInFunction	= @_Step
				, @MessageText		= @_Message
				, @Severity			= @_Severity
				, @ExceptionId		= @_ExceptionId
				--! Supply all the progress info after we've gone to such trouble to collect it
				, @ExtraInfo        = @_ProgressText

	--! Finally, throw an exception that will be detected by the caller
	IF @DoThrowError = 1 AND @_Error > 0
		RAISERROR(@_Message, 16, 99);

	SET NOCOUNT OFF;

	--! Return the value of @@ERROR (which will be zero on success)
	RETURN (@_Error);
END
GO
PRINT N'Creating [dv_config].[dv_global_config_update]...';


GO


CREATE PROCEDURE [dv_config].[dv_global_config_update]
(
     @vault_config_update_type				varchar(50)		= 'Set_Release'
	,@vault_release_number					int				= 0
	,@DoGenerateError						bit				= 0
	,@DoThrowError							bit				= 1
)
AS
BEGIN
SET NOCOUNT ON;

-- Internal use variables

declare @release_key			int
	   ,@rc						int
	   ,@schema_name			sysname
       ,@table_name				sysname
       ,@sql					nvarchar(max)


-- Log4TSQL Journal Constants 
DECLARE @SEVERITY_CRITICAL      smallint = 1;
DECLARE @SEVERITY_SEVERE        smallint = 2;
DECLARE @SEVERITY_MAJOR         smallint = 4;
DECLARE @SEVERITY_MODERATE      smallint = 8;
DECLARE @SEVERITY_MINOR         smallint = 16;
DECLARE @SEVERITY_CONCURRENCY   smallint = 32;
DECLARE @SEVERITY_INFORMATION   smallint = 256;
DECLARE @SEVERITY_SUCCESS       smallint = 512;
DECLARE @SEVERITY_DEBUG         smallint = 1024;
DECLARE @NEW_LINE               char(1)  = CHAR(10);

-- Log4TSQL Standard/ExceptionHandler variables
DECLARE	  @_Error         int
		, @_RowCount      int
		, @_Step          varchar(128)
		, @_Message       nvarchar(512)
		, @_ErrorContext  nvarchar(512)

-- Log4TSQL JournalWriter variables
DECLARE   @_FunctionName			varchar(255)
		, @_SprocStartTime			datetime
		, @_JournalOnOff			varchar(3)
		, @_Severity				smallint
		, @_ExceptionId				int
		, @_StepStartTime			datetime
		, @_ProgressText			nvarchar(max)

SET @_Error             = 0;
SET @_FunctionName      = OBJECT_NAME(@@PROCID);
SET @_Severity          = @SEVERITY_INFORMATION;
SET @_SprocStartTime    = sysdatetimeoffset();
SET @_ProgressText      = '' 
SET @_JournalOnOff      = log4.GetJournalControl(@_FunctionName, 'HOWTO');  -- left Group Name as HOWTO for now.

--set the Parameters for logging:
SET @_ProgressText	    = @_FunctionName + ' starting at ' + CONVERT(char(23), @_SprocStartTime, 121) + ' with inputs: '
						+ @NEW_LINE + '    @vault_config_update_type           : ' + COALESCE(@vault_config_update_type					, '<NULL>')
						+ @NEW_LINE + '    @vault_release_number               : ' + COALESCE(cast(@vault_release_number as varchar)	, '<NULL>')
						+ @NEW_LINE + '    @DoGenerateError : ' + COALESCE(CAST(@DoGenerateError AS varchar)							, '<NULL>')
						+ @NEW_LINE + '    @DoThrowError    : ' + COALESCE(CAST(@DoThrowError AS varchar)								, '<NULL>')
						+ @NEW_LINE

BEGIN TRANSACTION
BEGIN TRY
SET @_Step = 'Generate any required error';
IF @DoGenerateError = 1
   select 1 / 0
SET @_Step = 'Validate Inputs';

if @vault_config_update_type = 'Set_Release'
begin
	select @release_key = [release_key] from [dv_release].[dv_release_master] where [release_number] = @vault_release_number
	set @rc = @@rowcount
	if @rc <> 1 
		RAISERROR('Release Number %i Does Not Exist', 16, 1, @vault_release_number)
	end
		
declare Config_Cursor cursor forward_only for 
select  dv_schema_name, dv_table_name
from [dv_release].[fn_config_table_list] ()
order by dv_load_order desc   --bb20151113

open Config_Cursor
fetch next from Config_Cursor into  @schema_name, @table_name				

while @@FETCH_STATUS = 0
begin
if @vault_config_update_type = 	'Set_Release'							
	SELECT @sql = 'update ' + quotename(@schema_name) + '.' + quotename(@table_name) + ' set  [release_key] = ' + cast(@release_key as varchar)
else if @vault_config_update_type = 	'Empty_All_Config'
	SELECT @sql = 'delete ' + quotename(@schema_name) + '.' + quotename(@table_name)
else 
	RAISERROR('@vault_config_update_type must be one of <Set_Release> or <Empty_All_Config>: %s', 16, 1, @vault_config_update_type)

--print @sql
exec (@SQL)

fetch next from Config_Cursor into  @schema_name, @table_name	
end
close Config_Cursor
deallocate Config_Cursor


/*--------------------------------------------------------------------------------------------------------------*/
IF @@TRANCOUNT > 0 COMMIT TRAN;

SET @_Message   = 'Successful Global Config Update: ' + @vault_config_update_type

END TRY
BEGIN CATCH
SET @_ErrorContext	= 'Failed Global Config Update: ' + @vault_config_update_type
IF (XACT_STATE() = -1) -- uncommitable transaction
OR (@@TRANCOUNT > 0) -- AND XACT_STATE() != 1) -- undocumented uncommitable transaction
	BEGIN
		ROLLBACK TRAN;
		SET @_ErrorContext = @_ErrorContext + ' (Forced rolled back of all changes)';
	END
	
EXEC log4.ExceptionHandler
		  @ErrorContext  = @_ErrorContext
		, @ErrorNumber   = @_Error OUT
		, @ReturnMessage = @_Message OUT
		, @ExceptionId   = @_ExceptionId OUT
;
END CATCH

--/////////////////////////////////////////////////////////////////////////////////////////////////
OnComplete:
--/////////////////////////////////////////////////////////////////////////////////////////////////

	--! Clean up

	--!
	--! Use dbo.udf_FormatElapsedTime() to get a nicely formatted run time string e.g.
	--! "0 hr(s) 1 min(s) and 22 sec(s)" or "1345 milliseconds"
	--!
	IF @_Error = 0
		BEGIN
			SET @_Step			= 'OnComplete'
			SET @_Severity		= @SEVERITY_SUCCESS
			SET @_Message		= COALESCE(@_Message, @_Step)
								+ ' in a total run time of ' + log4.FormatElapsedTime(@_SprocStartTime, NULL, 3)
			SET @_ProgressText  = @_ProgressText + @NEW_LINE + @_Message;
		END
	ELSE
		BEGIN
			SET @_Step			= COALESCE(@_Step, 'OnError')
			SET @_Severity		= @SEVERITY_SEVERE
			SET @_Message		= COALESCE(@_Message, @_Step)
								+ ' after a total run time of ' + log4.FormatElapsedTime(@_SprocStartTime, NULL, 3)
			SET @_ProgressText  = @_ProgressText + @NEW_LINE + @_Message;
		END

	IF @_JournalOnOff = 'ON'
		EXEC log4.JournalWriter
				  @Task				= @_FunctionName
				, @FunctionName		= @_FunctionName
				, @StepInFunction	= @_Step
				, @MessageText		= @_Message
				, @Severity			= @_Severity
				, @ExceptionId		= @_ExceptionId
				--! Supply all the progress info after we've gone to such trouble to collect it
				, @ExtraInfo        = @_ProgressText

	--! Finally, throw an exception that will be detected by the caller
	IF @DoThrowError = 1 AND @_Error > 0
		RAISERROR(@_Message, 16, 99);

	SET NOCOUNT OFF;

	--! Return the value of @@ERROR (which will be zero on success)
	RETURN (@_Error);
END
GO
PRINT N'Creating [dv_config].[dv_populate_source_table_columns]...';


GO

CREATE PROCEDURE [dv_config].[dv_populate_source_table_columns]
(
	 @vault_source_system					varchar(50)
    ,@vault_source_schema					varchar(128)
	,@vault_source_table					varchar(128)	
	,@vault_source_table_load_type			varchar(128)
	,@vault_source_procedure_schema			varchar(128)	= Null		
	,@vault_source_procedure_name			varchar(128)	= Null
	,@vault_release_number					int				= 0
	,@vault_rerun_column_insert				bit				= 0
	,@DoGenerateError						bit				= 0
	,@DoThrowError							bit				= 1
)
AS
BEGIN
SET NOCOUNT ON;

-- Internal use variables

declare @vault_stage_database				 varchar(128)
	   ,@system_key							 int
	   ,@source_table_key					 int
	   ,@procedure_fully_qualified			 nvarchar(512)
	   ,@table_fully_qualified				 nvarchar(512)


-- Log4TSQL Journal Constants 
DECLARE @SEVERITY_CRITICAL      smallint = 1;
DECLARE @SEVERITY_SEVERE        smallint = 2;
DECLARE @SEVERITY_MAJOR         smallint = 4;
DECLARE @SEVERITY_MODERATE      smallint = 8;
DECLARE @SEVERITY_MINOR         smallint = 16;
DECLARE @SEVERITY_CONCURRENCY   smallint = 32;
DECLARE @SEVERITY_INFORMATION   smallint = 256;
DECLARE @SEVERITY_SUCCESS       smallint = 512;
DECLARE @SEVERITY_DEBUG         smallint = 1024;
DECLARE @NEW_LINE               char(1)  = CHAR(10);

-- Log4TSQL Standard/ExceptionHandler variables
DECLARE	  @_Error         int
		, @_RowCount      int
		, @_Step          varchar(128)
		, @_Message       nvarchar(512)
		, @_ErrorContext  nvarchar(512)

-- Log4TSQL JournalWriter variables
DECLARE   @_FunctionName			varchar(255)
		, @_SprocStartTime			datetime
		, @_JournalOnOff			varchar(3)
		, @_Severity				smallint
		, @_ExceptionId				int
		, @_StepStartTime			datetime
		, @_ProgressText			nvarchar(max)

SET @_Error             = 0;
SET @_FunctionName      = OBJECT_NAME(@@PROCID);
SET @_Severity          = @SEVERITY_INFORMATION;
SET @_SprocStartTime    = sysdatetimeoffset();
SET @_ProgressText      = '' 
SET @_JournalOnOff      = log4.GetJournalControl(@_FunctionName, 'HOWTO');  -- left Group Name as HOWTO for now.

--set the Parameters for logging:
SET @_ProgressText		= @_FunctionName + ' starting at ' + CONVERT(char(23), @_SprocStartTime, 121) + ' with inputs: '
						+ @NEW_LINE + '    @vault_source_system          : ' + COALESCE(@vault_source_system						, '<NULL>')
						+ @NEW_LINE + '    @vault_source_schema          : ' + COALESCE(@vault_source_schema						, '<NULL>')
						+ @NEW_LINE + '    @vault_source_table           : ' + COALESCE(@vault_source_table							, '<NULL>')
						+ @NEW_LINE + '    @vault_source_table_load_type : ' + COALESCE(@vault_source_table_load_type				, '<NULL>')
						+ @NEW_LINE + '    @vault_source_procedure_schema: ' + COALESCE(@vault_source_procedure_schema				, '<NULL>')
						+ @NEW_LINE + '    @vault_source_procedure_name  : ' + COALESCE(@vault_source_procedure_name				, '<NULL>')
						+ @NEW_LINE + '    @vault_release_number         : ' + COALESCE(cast(@vault_release_number as varchar)		, '<NULL>')
						+ @NEW_LINE + '    @vault_rerun_column_insert    : ' + COALESCE(cast(@vault_rerun_column_insert as varchar)	, '<NULL>')
						+ @NEW_LINE + '    @DoGenerateError : ' + COALESCE(CAST(@DoGenerateError AS varchar)						, '<NULL>')
						+ @NEW_LINE + '    @DoThrowError    : ' + COALESCE(CAST(@DoThrowError AS varchar)							, '<NULL>')
						+ @NEW_LINE

BEGIN TRANSACTION
BEGIN TRY
SET @_Step = 'Generate any required error';
IF @DoGenerateError = 1
   select 1 / 0
SET @_Step = 'Validate Inputs';

select @vault_stage_database = [timevault_name]
      ,@system_key			 = [source_system_key]
	from [dbo].[dv_source_system] where [source_system_name] = @vault_source_system

select @table_fully_qualified = quotename(@vault_source_system) + '.' + quotename(@vault_source_schema) + '.' + quotename(@vault_source_table)
select @procedure_fully_qualified = quotename(@vault_stage_database) + '.' + quotename(@vault_source_procedure_schema) + '.' + quotename(@vault_source_procedure_name)

if not (isnull(@vault_source_procedure_schema, '') = '' and isnull(@vault_source_procedure_name, '') = '')
	if OBJECT_ID(@procedure_fully_qualified, N'P') is null
		raiserror('Procedure %s does not exist. Please Create it and retry this Process', 16, 1, @procedure_fully_qualified)

SET @_Step = 'Initialise Variables';

SET @_Step = 'Create Config For Table';

select @vault_stage_database = [timevault_name]
      ,@system_key			 = [source_system_key]
	from [dbo].[dv_source_system] where [source_system_name] = @vault_source_system
select @source_table_key = [source_table_key] 
	from [dbo].[dv_source_table] where [system_key] = @system_key and [source_table_schema] = @vault_source_schema and [source_table_name] = @vault_source_table
if @@ROWCOUNT = 0  -- Table doesn't exist in Config.
	begin
	EXECUTE @source_table_key			= [dbo].[dv_source_table_insert] 
		    @system_key					= @system_key
		   ,@source_table_schema		= @vault_source_schema
		   ,@source_table_name			= @vault_source_table
		   ,@source_table_load_type		= @vault_source_table_load_type
		   ,@source_procedure_schema	= @vault_source_procedure_schema
		   ,@source_procedure_name		= @vault_source_procedure_name
		   ,@is_retired					= 0
		   ,@release_number				= @vault_release_number
	end
	else  -- Table Does Exist in Config
	begin
	if @vault_rerun_column_insert = 1
	    begin
		delete from [dbo].[dv_column] where [table_key] = @source_table_key
		EXECUTE [dbo].[dv_source_table_update] 
			@table_key					= @source_table_key					
		   ,@system_key					= @system_key
		   ,@source_table_schema		= @vault_source_schema
		   ,@source_table_name			= @vault_source_table
		   ,@source_table_load_type		= @vault_source_table_load_type
		   ,@source_procedure_schema	= @vault_source_procedure_schema
		   ,@source_procedure_name		= @vault_source_procedure_name
		   ,@is_retired = 0
		end
	else
		begin
			raiserror('Table %s has already been defined. Either Remove it or set the @vault_rerun_column_insert paramater to 1 and try again.',  16, 1, @table_fully_qualified)
		end
	end
		
DECLARE @sql nvarchar(4000);
DECLARE @parm_definition nvarchar(4000);
declare @column_list_xml xml
declare @column_list table(column_name varchar(128));

declare @columns table(
		 column_name				varchar(128)
		,column_type				varchar(30)
		,column_length				int 
		,column_precision			int 
		,column_scale				int 
		,Collation_Name				nvarchar(128) 
		,bk_ordinal_position		int
		,source_ordinal_position	int) 

SET @parm_definition = N'@schema_name varchar(128), @table_name varchar(128), @column_list_OUT xml OUTPUT'

select @sql = 
'select @column_list_OUT = (
select [column_name]				= c.[name]
      ,[column_type]				= t.name
      ,[column_length]				= c.max_length
      ,[column_precision]			= c.[precision]
      ,[column_scale]				= c.[scale]
      ,[collation_Name]				= c.collation_name
      ,[source_ordinal_position]    = row_number() over (order by c.column_id)
	  ,[satellite_ordinal_position] = row_number() over (order by c.name)
from            [' + @vault_stage_database + '].sys.columns c
inner join      [' + @vault_stage_database + '].sys.objects o
on c.object_id = o.object_id
inner join      [' + @vault_stage_database + '].sys.schemas s
on o.schema_id = s.schema_id
inner join      [' + @vault_stage_database + '].sys.types t
on  c.system_type_id    = t.system_type_id
and t.is_user_defined   = 0
and t.user_type_id		= t.system_type_id
where 1=1
and o.type in(''U'', ''V'')
and s.name = @schema_name
and o.name = @table_name
for xml raw)'

declare
@column_name				varchar(128),
@column_type				varchar(30),
@column_length				int = NULL,
@column_precision			int = NULL,
@column_scale				int = NULL,
@Collation_Name				nvarchar(128) = NULL,
@bk_ordinal_position		int,
@source_ordinal_position	int,
@satellite_ordinal_position	int,
@is_source_date				bit,
@discard_flag				bit,
@is_retired					bit

--print @sql
if @_JournalOnOff = 'ON'
	set @_ProgressText  = @_ProgressText + @NEW_LINE + @sql + @NEW_LINE;
exec sp_executesql @sql, @parm_definition, @schema_name = @vault_source_schema, @table_name = @vault_source_table, @column_list_OUT=@column_list_xml output;
declare Col_Cursor cursor forward_only for 
SELECT  
 --      Tbl.Col.value('@table_key', 'int')					table_key,
       Tbl.Col.value('@column_name', 'varchar(128)')		column_name,  
       Tbl.Col.value('@column_type', 'varchar(30)')			column_type,
       Tbl.Col.value('@column_length', 'int')				column_length,
       Tbl.Col.value('@column_precision', 'int')			column_precision,
       Tbl.Col.value('@column_scale', 'int')				column_scale,
	   Tbl.Col.value('@Collation_Name', 'nvarchar(128)')	collation_name,
	   cast(0 as int)										bk_ordinal_position,
	   Tbl.Col.value('@source_ordinal_position', 'int')		source_ordinal_position,
	   Tbl.Col.value('@satellite_ordinal_position', 'int')	satellite_ordinal_position,
	   cast(0 as bit)										is_source_date,
	   cast(0 as bit)										discard_flag,
	   cast(0 as bit)										is_retired
FROM @column_list_xml.nodes('//row') Tbl(Col)
order by satellite_ordinal_position
open Col_Cursor
fetch next from Col_Cursor into  @column_name				
								,@column_type				
								,@column_length				
								,@column_precision			
								,@column_scale				
								,@Collation_Name				
								,@bk_ordinal_position		
								,@source_ordinal_position	
								,@satellite_ordinal_position	
								,@is_source_date				
								,@discard_flag				
								,@is_retired	

while @@FETCH_STATUS = 0
begin								
select  @column_name					
	   ,@column_type				
	   ,@column_length				
	   ,@column_precision			
	   ,@column_scale				
	   ,@Collation_Name				
	   ,@bk_ordinal_position		
	   ,@source_ordinal_position	
	   ,@satellite_ordinal_position	
	   ,@is_source_date				
	   ,@discard_flag				
	   ,@is_retired

EXECUTE [dbo].[dv_column_insert] 
	    @table_key					= @source_table_key
	   ,@release_number				= @vault_release_number
	   ,@column_name				= @column_name					
	   ,@column_type				= @column_type				
	   ,@column_length				= @column_length				
	   ,@column_precision			= @column_precision			
	   ,@column_scale				= @column_scale				
	   ,@Collation_Name				= @Collation_Name				
	   ,@bk_ordinal_position		= @bk_ordinal_position		
	   ,@source_ordinal_position	= @source_ordinal_position	
	   ,@satellite_ordinal_position	= @satellite_ordinal_position	
	   ,@is_source_date				= @is_source_date				
	   ,@discard_flag				= @discard_flag				
	   ,@is_retired			        = @is_retired

fetch next from Col_Cursor into  @column_name				
								,@column_type				
								,@column_length				
								,@column_precision			
								,@column_scale				
								,@Collation_Name				
								,@bk_ordinal_position		
								,@source_ordinal_position	
								,@satellite_ordinal_position	
								,@is_source_date				
								,@discard_flag				
								,@is_retired
end
close Col_Cursor
deallocate Col_Cursor


/*--------------------------------------------------------------------------------------------------------------*/
IF @@TRANCOUNT > 0 COMMIT TRAN;

SET @_Message   = 'Successfully Populated Config for Table: ' + @table_fully_qualified

END TRY
BEGIN CATCH
SET @_ErrorContext	= 'Failed to Populate Config for Table: ' + @table_fully_qualified
IF (XACT_STATE() = -1) -- uncommitable transaction
OR (@@TRANCOUNT > 0) -- AND XACT_STATE() != 1) -- undocumented uncommitable transaction
	BEGIN
		ROLLBACK TRAN;
		SET @_ErrorContext = @_ErrorContext + ' (Forced rolled back of all changes)';
	END
	
EXEC log4.ExceptionHandler
		  @ErrorContext  = @_ErrorContext
		, @ErrorNumber   = @_Error OUT
		, @ReturnMessage = @_Message OUT
		, @ExceptionId   = @_ExceptionId OUT
;
END CATCH

--/////////////////////////////////////////////////////////////////////////////////////////////////
OnComplete:
--/////////////////////////////////////////////////////////////////////////////////////////////////

	--! Clean up

	--!
	--! Use dbo.udf_FormatElapsedTime() to get a nicely formatted run time string e.g.
	--! "0 hr(s) 1 min(s) and 22 sec(s)" or "1345 milliseconds"
	--!
	IF @_Error = 0
		BEGIN
			SET @_Step			= 'OnComplete'
			SET @_Severity		= @SEVERITY_SUCCESS
			SET @_Message		= COALESCE(@_Message, @_Step)
								+ ' in a total run time of ' + log4.FormatElapsedTime(@_SprocStartTime, NULL, 3)
			SET @_ProgressText  = @_ProgressText + @NEW_LINE + @_Message;
		END
	ELSE
		BEGIN
			SET @_Step			= COALESCE(@_Step, 'OnError')
			SET @_Severity		= @SEVERITY_SEVERE
			SET @_Message		= COALESCE(@_Message, @_Step)
								+ ' after a total run time of ' + log4.FormatElapsedTime(@_SprocStartTime, NULL, 3)
			SET @_ProgressText  = @_ProgressText + @NEW_LINE + @_Message;
		END

	IF @_JournalOnOff = 'ON'
		EXEC log4.JournalWriter
				  @Task				= @_FunctionName
				, @FunctionName		= @_FunctionName
				, @StepInFunction	= @_Step
				, @MessageText		= @_Message
				, @Severity			= @_Severity
				, @ExceptionId		= @_ExceptionId
				--! Supply all the progress info after we've gone to such trouble to collect it
				, @ExtraInfo        = @_ProgressText

	--! Finally, throw an exception that will be detected by the caller
	IF @DoThrowError = 1 AND @_Error > 0
		RAISERROR(@_Message, 16, 99);

	SET NOCOUNT OFF;

	--! Return the value of @@ERROR (which will be zero on success)
	RETURN (@_Error);
END
GO
PRINT N'Creating [dv_config].[dv_populate_satellite_columns]...';


GO
CREATE PROCEDURE [dv_config].[dv_populate_satellite_columns]
(
	 @vault_source_system					varchar(50)
    ,@vault_source_schema					varchar(128)
	,@vault_source_table					varchar(128)	
	,@vault_satellite_name					varchar(128)	= Null
	,@vault_release_number					int				= 0
	,@vault_rerun_satellite_column_insert	bit				= 0
	,@DoGenerateError						bit				= 0
	,@DoThrowError							bit				= 1
)
AS
BEGIN
SET NOCOUNT ON;

-- Internal use variables

declare @table_fully_qualified				nvarchar(512)
	   ,@satellite_key						int
	   ,@source_table_key					int


-- Log4TSQL Journal Constants 
DECLARE @SEVERITY_CRITICAL      smallint = 1;
DECLARE @SEVERITY_SEVERE        smallint = 2;
DECLARE @SEVERITY_MAJOR         smallint = 4;
DECLARE @SEVERITY_MODERATE      smallint = 8;
DECLARE @SEVERITY_MINOR         smallint = 16;
DECLARE @SEVERITY_CONCURRENCY   smallint = 32;
DECLARE @SEVERITY_INFORMATION   smallint = 256;
DECLARE @SEVERITY_SUCCESS       smallint = 512;
DECLARE @SEVERITY_DEBUG         smallint = 1024;
DECLARE @NEW_LINE               char(1)  = CHAR(10);

-- Log4TSQL Standard/ExceptionHandler variables
DECLARE	  @_Error         int
		, @_RowCount      int
		, @_Step          varchar(128)
		, @_Message       nvarchar(512)
		, @_ErrorContext  nvarchar(512)

-- Log4TSQL JournalWriter variables
DECLARE   @_FunctionName			varchar(255)
		, @_SprocStartTime			datetime
		, @_JournalOnOff			varchar(3)
		, @_Severity				smallint
		, @_ExceptionId				int
		, @_StepStartTime			datetime
		, @_ProgressText			nvarchar(max)

SET @_Error             = 0;
SET @_FunctionName      = OBJECT_NAME(@@PROCID);
SET @_Severity          = @SEVERITY_INFORMATION;
SET @_SprocStartTime    = sysdatetimeoffset();
SET @_ProgressText      = '' 
SET @_JournalOnOff      = log4.GetJournalControl(@_FunctionName, 'HOWTO');  -- left Group Name as HOWTO for now.

--set the Parameters for logging:
SET @_ProgressText		= @_FunctionName + ' starting at ' + CONVERT(char(23), @_SprocStartTime, 121) + ' with inputs: '
						+ @NEW_LINE + '    @vault_source_system                : ' + COALESCE(@vault_source_system						, '<NULL>')
						+ @NEW_LINE + '    @vault_source_schema                : ' + COALESCE(@vault_source_schema						, '<NULL>')
						+ @NEW_LINE + '    @vault_source_table                 : ' + COALESCE(@vault_source_table						, '<NULL>')
						+ @NEW_LINE + '    @vault_satellite_name               : ' + COALESCE(@vault_satellite_name						, '<NULL>')
						+ @NEW_LINE + '    @vault_rerun_satellite_column_insert: ' + COALESCE(cast(@vault_rerun_satellite_column_insert as varchar)	, '<NULL>')
						+ @NEW_LINE + '    @DoGenerateError : ' + COALESCE(CAST(@DoGenerateError AS varchar)							, '<NULL>')
						+ @NEW_LINE + '    @DoThrowError    : ' + COALESCE(CAST(@DoThrowError AS varchar)								, '<NULL>')
						+ @NEW_LINE

BEGIN TRANSACTION
BEGIN TRY
SET @_Step = 'Generate any required error';
IF @DoGenerateError = 1
   select 1 / 0
SET @_Step = 'Validate Inputs';

select @table_fully_qualified = quotename(@vault_source_system) + '.' + quotename(@vault_source_schema) + '.' + quotename(@vault_source_table)

SET @_Step = 'Initialise Variables';

SET @_Step = 'Create Config Satellite Columns';

select @satellite_key = [satellite_key]
	from [dbo].[dv_satellite] where [satellite_name] = @vault_satellite_name

select @source_table_key = st.[source_table_key] 
	from [dbo].[dv_source_table] st
	inner join [dbo].[dv_source_system] ss
	on ss.source_system_key = st.system_key
	where ss.[source_system_name]	= @vault_source_system
	  and st.[source_table_schema]	= @vault_source_schema 
	  and st.[source_table_name]	= @vault_source_table
select 1 from [dbo].[dv_satellite_column] where [satellite_key] = @satellite_key
if @@ROWCOUNT > 0  -- Satellite already has Columns attached
	begin
	if @vault_rerun_satellite_column_insert = 1
	    begin
		delete from [dbo].[dv_satellite_column] where [satellite_key] = @satellite_key
		end
	else
		begin
			raiserror('Satellite %s has columns linked to it. Either Remove them from the Satellite or set the @vault_rerun_satellite_column_insert paramater to 1 and try again.',  16, 1, @vault_satellite_name)
		end
	end
		
declare @column_key int
declare Col_Cursor cursor forward_only for 
SELECT  column_key from [dbo].[dv_column]	
 where [table_key] = @source_table_key
open Col_Cursor
fetch next from Col_Cursor into  @column_key				

while @@FETCH_STATUS = 0
begin								
select @satellite_key, @column_key,@vault_release_number 
EXECUTE [dbo].[dv_satellite_column_insert] 
   @satellite_key
  ,@column_key
  ,@vault_release_number

fetch next from Col_Cursor into  @column_key
end
close Col_Cursor
deallocate Col_Cursor


/*--------------------------------------------------------------------------------------------------------------*/
IF @@TRANCOUNT > 0 COMMIT TRAN;

SET @_Message   = 'Successfully Populated Columns for Satellite: ' + @vault_satellite_name

END TRY
BEGIN CATCH
SET @_ErrorContext	= 'Failed to Populate Columns for Satellite: ' + @vault_satellite_name
IF (XACT_STATE() = -1) -- uncommitable transaction
OR (@@TRANCOUNT > 0) -- AND XACT_STATE() != 1) -- undocumented uncommitable transaction
	BEGIN
		ROLLBACK TRAN;
		SET @_ErrorContext = @_ErrorContext + ' (Forced rolled back of all changes)';
	END
	
EXEC log4.ExceptionHandler
		  @ErrorContext  = @_ErrorContext
		, @ErrorNumber   = @_Error OUT
		, @ReturnMessage = @_Message OUT
		, @ExceptionId   = @_ExceptionId OUT
;
END CATCH

--/////////////////////////////////////////////////////////////////////////////////////////////////
OnComplete:
--/////////////////////////////////////////////////////////////////////////////////////////////////

	--! Clean up

	--!
	--! Use dbo.udf_FormatElapsedTime() to get a nicely formatted run time string e.g.
	--! "0 hr(s) 1 min(s) and 22 sec(s)" or "1345 milliseconds"
	--!
	IF @_Error = 0
		BEGIN
			SET @_Step			= 'OnComplete'
			SET @_Severity		= @SEVERITY_SUCCESS
			SET @_Message		= COALESCE(@_Message, @_Step)
								+ ' in a total run time of ' + log4.FormatElapsedTime(@_SprocStartTime, NULL, 3)
			SET @_ProgressText  = @_ProgressText + @NEW_LINE + @_Message;
		END
	ELSE
		BEGIN
			SET @_Step			= COALESCE(@_Step, 'OnError')
			SET @_Severity		= @SEVERITY_SEVERE
			SET @_Message		= COALESCE(@_Message, @_Step)
								+ ' after a total run time of ' + log4.FormatElapsedTime(@_SprocStartTime, NULL, 3)
			SET @_ProgressText  = @_ProgressText + @NEW_LINE + @_Message;
		END

	IF @_JournalOnOff = 'ON'
		EXEC log4.JournalWriter
				  @Task				= @_FunctionName
				, @FunctionName		= @_FunctionName
				, @StepInFunction	= @_Step
				, @MessageText		= @_Message
				, @Severity			= @_Severity
				, @ExceptionId		= @_ExceptionId
				--! Supply all the progress info after we've gone to such trouble to collect it
				, @ExtraInfo        = @_ProgressText

	--! Finally, throw an exception that will be detected by the caller
	IF @DoThrowError = 1 AND @_Error > 0
		RAISERROR(@_Message, 16, 99);

	SET NOCOUNT OFF;

	--! Return the value of @@ERROR (which will be zero on success)
	RETURN (@_Error);
END
GO
PRINT N'Creating [dv_config].[dv_populate_satellite]...';


GO
CREATE PROCEDURE [dv_config].[dv_populate_satellite]
(
	 @vault_satellite_name					varchar(128)	= Null
    ,@vault_link_hub_flag					char(1)			= null
	,@vault_hub_link_name					varchar(128)	= Null
	,@vault_satellite_database				varchar(128)	= Null
	,@vault_duplicate_removal_threshold		bit				= 0
	,@vault_is_columnstore					bit				= 0
	,@vault_rerun_satellite_insert			bit				= 0
	,@vault_release_number					int				= 0
	,@DoGenerateError						bit				= 0
	,@DoThrowError							bit				= 1
)
AS
BEGIN
SET NOCOUNT ON;

-- Internal use variables

declare @satellite_key						int
       ,@hub_key							int
       ,@link_key							int
	   ,@link_hub_satellite_flag			char(1)
	   ,@satellite_name						varchar(128)
	   ,@satellite_abbreviation				varchar(4)
	   ,@satellite_schema					varchar(128)	
	   ,@satellite_database					varchar(128)
	   ,@duplicate_removal_threshold		int
	   ,@is_columnstore						bit
	   ,@release_key						bit
	   ,@source_table_key					int


-- Log4TSQL Journal Constants 
DECLARE @SEVERITY_CRITICAL      smallint = 1;
DECLARE @SEVERITY_SEVERE        smallint = 2;
DECLARE @SEVERITY_MAJOR         smallint = 4;
DECLARE @SEVERITY_MODERATE      smallint = 8;
DECLARE @SEVERITY_MINOR         smallint = 16;
DECLARE @SEVERITY_CONCURRENCY   smallint = 32;
DECLARE @SEVERITY_INFORMATION   smallint = 256;
DECLARE @SEVERITY_SUCCESS       smallint = 512;
DECLARE @SEVERITY_DEBUG         smallint = 1024;
DECLARE @NEW_LINE               char(1)  = CHAR(10);

-- Log4TSQL Standard/ExceptionHandler variables
DECLARE	  @_Error         int
		, @_RowCount      int
		, @_Step          varchar(128)
		, @_Message       nvarchar(512)
		, @_ErrorContext  nvarchar(512)

-- Log4TSQL JournalWriter variables
DECLARE   @_FunctionName			varchar(255)
		, @_SprocStartTime			datetime
		, @_JournalOnOff			varchar(3)
		, @_Severity				smallint
		, @_ExceptionId				int
		, @_StepStartTime			datetime
		, @_ProgressText			nvarchar(max)

SET @_Error             = 0;
SET @_FunctionName      = OBJECT_NAME(@@PROCID);
SET @_Severity          = @SEVERITY_INFORMATION;
SET @_SprocStartTime    = sysdatetimeoffset();
SET @_ProgressText      = '' 
SET @_JournalOnOff      = log4.GetJournalControl(@_FunctionName, 'HOWTO');  -- left Group Name as HOWTO for now.


--set the Parameters for logging:
SET @_ProgressText		= @_FunctionName + ' starting at ' + CONVERT(char(23), @_SprocStartTime, 121) + ' with inputs: '
						+ @NEW_LINE + '    @vault_satellite_name               : ' + COALESCE(@vault_satellite_name						, '<NULL>')
						+ @NEW_LINE + '    @vault_link_hub_flag                : ' + COALESCE(@vault_link_hub_flag						, '<NULL>')
						+ @NEW_LINE + '    @vault_satellite_database           : ' + COALESCE(@vault_satellite_database					, '<NULL>')
						+ @NEW_LINE + '    @vault_duplicate_removal_threshold  : ' + COALESCE(cast(@vault_satellite_name as varchar)	, '<NULL>')
						+ @NEW_LINE + '    @vault_rerun_satellite_insert       : ' + COALESCE(cast(@vault_rerun_satellite_insert as varchar), '<NULL>')
						+ @NEW_LINE + '    @vault_release_number               : ' + COALESCE(CAST(@vault_release_number AS varchar)	, '<NULL>')
						+ @NEW_LINE + '    @DoGenerateError : ' + COALESCE(CAST(@DoGenerateError AS varchar)							, '<NULL>')
						+ @NEW_LINE + '    @DoThrowError    : ' + COALESCE(CAST(@DoThrowError AS varchar)								, '<NULL>')
						+ @NEW_LINE

BEGIN TRANSACTION
BEGIN TRY
SET @_Step = 'Generate any required error';
IF @DoGenerateError = 1
   select 1 / 0
SET @_Step = 'Validate Inputs';

SET @_Step = 'Initialise Variables';

SET @_Step = 'Create Config Satellite Columns';

select @satellite_key				= [satellite_key]
	from [dbo].[dv_satellite] where [satellite_name] = @vault_satellite_name
 
if @satellite_key is not null  -- Satellite Exists - keeping it simple for now - just blow the sat away and redo it.
	begin
	if @vault_rerun_satellite_insert = 1
	    begin
		delete from [dbo].[dv_satellite_column] where [satellite_key] = @satellite_key
		delete from [dbo].[dv_satellite] where [satellite_key] = @satellite_key
		end
	else
		begin
			raiserror('Satellite %s Exists. Either Remove the Satellite or set the @vault_rerun_satellite_column_insert paramater to 1 and try again.',  16, 1, @vault_satellite_name)
		end
	end

if @vault_link_hub_flag = 'H'
	select @hub_key = [hub_key]
	      ,@link_key = 0
	from [dbo].[dv_hub]
	where [hub_name] = @vault_hub_link_name
else
	select @link_key = [link_key]
	      ,@hub_key = 0
	from [dbo].[dv_link]
	where [link_name] = @vault_hub_link_name
	
select @satellite_abbreviation	= [dbo].[fn_get_next_abbreviation] ()
select @satellite_schema		= cast([dbo].[fn_get_default_value]('Schema', 'Sat') as varchar)	
	
EXECUTE  [dbo].[dv_satellite_insert] 
   @hub_key						= @hub_key 
  ,@link_key					= @link_key
  ,@link_hub_satellite_flag		= @vault_link_hub_flag
  ,@satellite_name				= @vault_satellite_name
  ,@satellite_abbreviation		= @satellite_abbreviation	
  ,@satellite_schema			= @satellite_schema
  ,@satellite_database			= @vault_satellite_database
  ,@duplicate_removal_threshold = @vault_duplicate_removal_threshold
  ,@is_columnstore				= @vault_is_columnstore
  ,@is_retired					= 0
  ,@release_number				= @vault_release_number



/*--------------------------------------------------------------------------------------------------------------*/
IF @@TRANCOUNT > 0 COMMIT TRAN;

SET @_Message   = 'Successfully Populated Satellite: ' + @vault_satellite_name

END TRY
BEGIN CATCH
SET @_ErrorContext	= 'Failed to Populate Satellite: ' + @vault_satellite_name
IF (XACT_STATE() = -1) -- uncommitable transaction
OR (@@TRANCOUNT > 0) -- AND XACT_STATE() != 1) -- undocumented uncommitable transaction
	BEGIN
		ROLLBACK TRAN;
		SET @_ErrorContext = @_ErrorContext + ' (Forced rolled back of all changes)';
	END
	
EXEC log4.ExceptionHandler
		  @ErrorContext  = @_ErrorContext
		, @ErrorNumber   = @_Error OUT
		, @ReturnMessage = @_Message OUT
		, @ExceptionId   = @_ExceptionId OUT
;
END CATCH

--/////////////////////////////////////////////////////////////////////////////////////////////////
OnComplete:
--/////////////////////////////////////////////////////////////////////////////////////////////////

	--! Clean up

	--!
	--! Use dbo.udf_FormatElapsedTime() to get a nicely formatted run time string e.g.
	--! "0 hr(s) 1 min(s) and 22 sec(s)" or "1345 milliseconds"
	--!
	IF @_Error = 0
		BEGIN
			SET @_Step			= 'OnComplete'
			SET @_Severity		= @SEVERITY_SUCCESS
			SET @_Message		= COALESCE(@_Message, @_Step)
								+ ' in a total run time of ' + log4.FormatElapsedTime(@_SprocStartTime, NULL, 3)
			SET @_ProgressText  = @_ProgressText + @NEW_LINE + @_Message;
		END
	ELSE
		BEGIN
			SET @_Step			= COALESCE(@_Step, 'OnError')
			SET @_Severity		= @SEVERITY_SEVERE
			SET @_Message		= COALESCE(@_Message, @_Step)
								+ ' after a total run time of ' + log4.FormatElapsedTime(@_SprocStartTime, NULL, 3)
			SET @_ProgressText  = @_ProgressText + @NEW_LINE + @_Message;
		END

	IF @_JournalOnOff = 'ON'
		EXEC log4.JournalWriter
				  @Task				= @_FunctionName
				, @FunctionName		= @_FunctionName
				, @StepInFunction	= @_Step
				, @MessageText		= @_Message
				, @Severity			= @_Severity
				, @ExceptionId		= @_ExceptionId
				--! Supply all the progress info after we've gone to such trouble to collect it
				, @ExtraInfo        = @_ProgressText

	--! Finally, throw an exception that will be detected by the caller
	IF @DoThrowError = 1 AND @_Error > 0
		RAISERROR(@_Message, 16, 99);

	SET NOCOUNT OFF;

	--! Return the value of @@ERROR (which will be zero on success)
	RETURN (@_Error);
END
GO
PRINT N'Creating [dv_config].[dv_populate_hub_key_columns]...';


GO
Create PROCEDURE [dv_config].[dv_populate_hub_key_columns]
(
	 @vault_source_system					varchar(50)
    ,@vault_source_schema					varchar(128)
	,@vault_source_table					varchar(128)	
	,@vault_source_column_name				varchar(128)
	,@vault_hub_name						varchar(128)	= Null		
	,@vault_hub_key_column_name				varchar(128)	= Null
	,@vault_release_number					int				= 0
	,@DoGenerateError						bit				= 0
	,@DoThrowError							bit				= 1
)
AS
BEGIN
SET NOCOUNT ON;

-- Internal use variables

declare @column_key							int
	   ,@hub_key_column_key					int
	   ,@hub_key_fully_qualified			nvarchar(512)
	   ,@column_fully_qualified				nvarchar(512)


-- Log4TSQL Journal Constants 
DECLARE @SEVERITY_CRITICAL      smallint = 1;
DECLARE @SEVERITY_SEVERE        smallint = 2;
DECLARE @SEVERITY_MAJOR         smallint = 4;
DECLARE @SEVERITY_MODERATE      smallint = 8;
DECLARE @SEVERITY_MINOR         smallint = 16;
DECLARE @SEVERITY_CONCURRENCY   smallint = 32;
DECLARE @SEVERITY_INFORMATION   smallint = 256;
DECLARE @SEVERITY_SUCCESS       smallint = 512;
DECLARE @SEVERITY_DEBUG         smallint = 1024;
DECLARE @NEW_LINE               char(1)  = CHAR(10);

-- Log4TSQL Standard/ExceptionHandler variables
DECLARE	  @_Error         int
		, @_RowCount      int
		, @_Step          varchar(128)
		, @_Message       nvarchar(512)
		, @_ErrorContext  nvarchar(512)

-- Log4TSQL JournalWriter variables
DECLARE   @_FunctionName			varchar(255)
		, @_SprocStartTime			datetime
		, @_JournalOnOff			varchar(3)
		, @_Severity				smallint
		, @_ExceptionId				int
		, @_StepStartTime			datetime
		, @_ProgressText			nvarchar(max)

SET @_Error             = 0;
SET @_FunctionName      = OBJECT_NAME(@@PROCID);
SET @_Severity          = @SEVERITY_INFORMATION;
SET @_SprocStartTime    = sysdatetimeoffset();
SET @_ProgressText      = '' 
SET @_JournalOnOff      = log4.GetJournalControl(@_FunctionName, 'HOWTO');  -- left Group Name as HOWTO for now.

--set the Parameters for logging:
SET @_ProgressText		= @_FunctionName + ' starting at ' + CONVERT(char(23), @_SprocStartTime, 121) + ' with inputs: '
						+ @NEW_LINE + '    @vault_source_system          : ' + COALESCE(@vault_source_system						, '<NULL>')
						+ @NEW_LINE + '    @vault_source_schema          : ' + COALESCE(@vault_source_schema						, '<NULL>')
						+ @NEW_LINE + '    @vault_source_table           : ' + COALESCE(@vault_source_table							, '<NULL>')
						+ @NEW_LINE + '    @vault_source_column_name     : ' + COALESCE(@vault_source_column_name					, '<NULL>')
						+ @NEW_LINE + '    @vault_hub_name               : ' + COALESCE(@vault_hub_name								, '<NULL>')
						+ @NEW_LINE + '    @vault_hub_key_column_name    : ' + COALESCE(@vault_hub_key_column_name					, '<NULL>')
						+ @NEW_LINE + '    @vault_release_number         : ' + COALESCE(cast(@vault_release_number as varchar)		, '<NULL>')
						+ @NEW_LINE + '    @DoGenerateError : ' + COALESCE(CAST(@DoGenerateError AS varchar)						, '<NULL>')
						+ @NEW_LINE + '    @DoThrowError    : ' + COALESCE(CAST(@DoThrowError AS varchar)							, '<NULL>')
						+ @NEW_LINE

BEGIN TRANSACTION
BEGIN TRY
SET @_Step = 'Generate any required error';
IF @DoGenerateError = 1
   select 1 / 0
SET @_Step = 'Validate Inputs';

select @column_fully_qualified = quotename(@vault_source_system) + '.' + quotename(@vault_source_schema) + '.' + quotename(@vault_source_table) + '.' + quotename(@vault_source_column_name)
select @hub_key_fully_qualified = quotename(@vault_hub_name) + '.' + quotename(@vault_hub_key_column_name) 

SET @_Step = 'Initialise Variables';

SET @_Step = 'Create Config For Hub Key';

select @column_key = c.column_key
from [dbo].[dv_source_system] ss
  left join [dbo].[dv_source_table] st
  on st.system_key = ss.source_system_key
  left join [dbo].[dv_column] c
  on st.source_table_key = c.table_key 
where ss.source_system_name = @vault_source_system
  and st.source_table_schema = @vault_source_schema
  and st.source_table_name = @vault_source_table 
  and c.column_name = @vault_source_column_name

select @hub_key_column_key = hkc.hub_key_column_key
from [dbo].[dv_hub] h
  left join [dbo].[dv_hub_key_column] hkc
  on h.hub_key = hkc.hub_key
where h.hub_name = @vault_hub_name
  and hkc.hub_key_column_name = @vault_hub_key_column_name

select @column_key			
  	  ,@hub_key_column_key	

EXECUTE[dbo].[dv_hub_column_insert] 
   @hub_key_column_key 
  ,@column_key
  ,@vault_release_number
		


/*--------------------------------------------------------------------------------------------------------------*/
IF @@TRANCOUNT > 0 COMMIT TRAN;

SET @_Message   = 'Successfully Populated Config for Hub Key: ' + @hub_key_fully_qualified

END TRY
BEGIN CATCH
SET @_ErrorContext	= 'Failed to Populate Config for Hub Key: ' + @hub_key_fully_qualified
IF (XACT_STATE() = -1) -- uncommitable transaction
OR (@@TRANCOUNT > 0) -- AND XACT_STATE() != 1) -- undocumented uncommitable transaction
	BEGIN
		ROLLBACK TRAN;
		SET @_ErrorContext = @_ErrorContext + ' (Forced rolled back of all changes)';
	END
	
EXEC log4.ExceptionHandler
		  @ErrorContext  = @_ErrorContext
		, @ErrorNumber   = @_Error OUT
		, @ReturnMessage = @_Message OUT
		, @ExceptionId   = @_ExceptionId OUT
;
END CATCH

--/////////////////////////////////////////////////////////////////////////////////////////////////
OnComplete:
--/////////////////////////////////////////////////////////////////////////////////////////////////

	--! Clean up

	--!
	--! Use dbo.udf_FormatElapsedTime() to get a nicely formatted run time string e.g.
	--! "0 hr(s) 1 min(s) and 22 sec(s)" or "1345 milliseconds"
	--!
	IF @_Error = 0
		BEGIN
			SET @_Step			= 'OnComplete'
			SET @_Severity		= @SEVERITY_SUCCESS
			SET @_Message		= COALESCE(@_Message, @_Step)
								+ ' in a total run time of ' + log4.FormatElapsedTime(@_SprocStartTime, NULL, 3)
			SET @_ProgressText  = @_ProgressText + @NEW_LINE + @_Message;
		END
	ELSE
		BEGIN
			SET @_Step			= COALESCE(@_Step, 'OnError')
			SET @_Severity		= @SEVERITY_SEVERE
			SET @_Message		= COALESCE(@_Message, @_Step)
								+ ' after a total run time of ' + log4.FormatElapsedTime(@_SprocStartTime, NULL, 3)
			SET @_ProgressText  = @_ProgressText + @NEW_LINE + @_Message;
		END

	IF @_JournalOnOff = 'ON'
		EXEC log4.JournalWriter
				  @Task				= @_FunctionName
				, @FunctionName		= @_FunctionName
				, @StepInFunction	= @_Step
				, @MessageText		= @_Message
				, @Severity			= @_Severity
				, @ExceptionId		= @_ExceptionId
				--! Supply all the progress info after we've gone to such trouble to collect it
				, @ExtraInfo        = @_ProgressText

	--! Finally, throw an exception that will be detected by the caller
	IF @DoThrowError = 1 AND @_Error > 0
		RAISERROR(@_Message, 16, 99);

	SET NOCOUNT OFF;

	--! Return the value of @@ERROR (which will be zero on success)
	RETURN (@_Error);
END
GO
PRINT N'Creating [dv_integrity].[dv_col_metrics]...';


GO

CREATE PROCEDURE [dv_integrity].[dv_col_metrics]
(
   @satellite_key				int				= 0
  ,@stage_database				varchar(128)	= 'ODV_Metrics_Stage'
  ,@stage_schema				varchar(128)	= 'Stage'
  ,@stage_table					varchar(128)	= 'Integrity_Col_Counts'
  ,@dogenerateerror				bit				= 0
  ,@dothrowerror				bit				= 1
)
as
begin
set nocount on

-- Local Defaults Values
declare @crlf char(2) = char(13) + char(10)
--Global Defaults
DECLARE  
		 @def_global_lowdate				datetime
        ,@def_global_highdate				datetime
        ,@def_global_default_load_date_time	varchar(128)

-- Proc Defaults
declare  @def_runtype						varchar(128)
--Sat Defaults									
declare  @sat_tombstone_col					varchar(128)
		,@sat_current_row_col				varchar(128)
		,@sat_start_date_col				varchar(128)
		,@sat_end_date_col					varchar(128)	
-- Sat Table
declare  @sat_database						varchar(128)
		,@sat_schema						varchar(128)
		,@sat_table							varchar(128)
		,@sat_qualified_name				varchar(512)
declare @Tests		table (test_name varchar(50), test_prefix varchar(10), test_type varchar(10), test_template varchar(256), test_column varchar(128))
declare @Columns	table (satellite_key bigint,satellite_name varchar(256),table_name varchar(1024),column_key bigint, column_name varchar(256), test_name varchar(50), test_script varchar(max), test_column varchar(128))   

-- Stage Table
declare  @stage_qualified_name				varchar(512)

--  Working Storage
declare @sql1								nvarchar(max) = ''
declare @sql2								nvarchar(max) = ''
declare @run_time							varchar(50)
declare @col_loop_key						varchar(128)
declare @sat_loop_key						bigint
declare @sat_loop_stop_key					bigint

-- Log4TSQL Journal Constants 										
DECLARE @SEVERITY_CRITICAL      smallint = 1;
DECLARE @SEVERITY_SEVERE        smallint = 2;
DECLARE @SEVERITY_MAJOR         smallint = 4;
DECLARE @SEVERITY_MODERATE      smallint = 8;
DECLARE @SEVERITY_MINOR         smallint = 16;
DECLARE @SEVERITY_CONCURRENCY   smallint = 32;
DECLARE @SEVERITY_INFORMATION   smallint = 256;
DECLARE @SEVERITY_SUCCESS       smallint = 512;
DECLARE @SEVERITY_DEBUG         smallint = 1024;
DECLARE @NEW_LINE               char(1)  = CHAR(10);

-- Log4TSQL Standard/ExceptionHandler variables
DECLARE	  @_Error         int
		, @_RowCount      int
		, @_Step          varchar(128)
		, @_Message       nvarchar(512)
		, @_ErrorContext  nvarchar(512)

-- Log4TSQL JournalWriter variables
DECLARE   @_FunctionName			varchar(255)
		, @_SprocStartTime			datetime
		, @_JournalOnOff			varchar(3)
		, @_Severity				smallint
		, @_ExceptionId				int
		, @_StepStartTime			datetime
		, @_ProgressText			nvarchar(max)

SET @_Error             = 0;
SET @_FunctionName      = OBJECT_NAME(@@PROCID);
SET @_Severity          = @SEVERITY_INFORMATION;
SET @_SprocStartTime    = sysdatetimeoffset();
SET @_ProgressText      = '' 
SET @_JournalOnOff      = log4.GetJournalControl(@_FunctionName, 'IntegrityChecks');  -- left Group Name as HOWTO for now.
select @_FunctionName   = isnull(OBJECT_NAME(@@PROCID), 'Test');

-- set Log4TSQL Parameters for Logging:
SET @_ProgressText		= @_FunctionName + ' starting at ' + CONVERT(char(23), @_SprocStartTime, 121) + ' with inputs: '
						+ @NEW_LINE + '    @satellite_key                : ' + COALESCE(CAST(@satellite_key AS varchar), 'NULL') 
						+ @NEW_LINE + '    @stage_database               : ' + @stage_database					
						+ @NEW_LINE + '    @stage_schema                 : ' + @stage_schema				
						+ @NEW_LINE + '    @stage_table                  : ' + @stage_table					    
						+ @NEW_LINE + '    @DoGenerateError              : ' + COALESCE(CAST(@DoGenerateError AS varchar), 'NULL')
						+ @NEW_LINE + '    @DoThrowError                 : ' + COALESCE(CAST(@DoThrowError AS varchar), 'NULL')
						+ @NEW_LINE

BEGIN TRY
SET @_Step = 'Generate any required error';
IF @DoGenerateError = 1
   select 1 / 0
SET @_Step = 'Validate inputs';

/*--------------------------------------------------------------------------------------------------------------*/
select
-- Global Defaults
 @def_global_lowdate				= cast([dbo].[fn_get_default_value] ('LowDate','Global')							as datetime)			
,@def_global_highdate				= cast([dbo].[fn_get_default_value] ('HighDate','Global')							as datetime)	
,@def_global_default_load_date_time	= cast([dbo].[fn_get_default_value] ('DefaultLoadDateTime','Global')				as varchar(128))
-- Proc Defaults
,@def_runtype						= cast(isnull([dbo].[fn_get_default_value] ('RunType', 'dv_col_metrics'), 'Full')	as varchar(128))
-- overide the default to Full if a specific Satellite was requested:
if isnull(@satellite_key, 0) > 0
	set @def_runtype = 'Full'
-- Sat Defaults
select @sat_start_date_col = quotename(column_name)
from [dbo].[dv_default_column]
where 1=1
and object_type	= 'sat'
and object_column_type = 'Version_Start_Date'
select @sat_end_date_col = quotename(column_name)
from [dbo].[dv_default_column]
where 1=1
and object_type	= 'sat'
and object_column_type = 'Version_End_Date'
select @sat_current_row_col = quotename(column_name)
from [dbo].[dv_default_column]
where 1=1
and object_type	= 'sat'
and object_column_type = 'Current_Row'
select @sat_tombstone_col = quotename(column_name)
from [dbo].[dv_default_column]
where 1=1
and object_type	= 'sat'
and object_column_type = 'Tombstone_Indicator'

--stage values
set @stage_qualified_name = quotename(@stage_database) + '.' + quotename(@stage_schema) + '.' + quotename(@stage_table) 
select @run_time = cast(sysdatetimeoffset() as varchar(50))

--tests:
-- Note that each test must have a case for each data type being references (it must be a regular matrix)
insert @tests values('min'		, 'min'			, 'varchar'	, 'cast(min([<column_name>]) as varchar(max)) as [min_<column_name>]', '[min_<column_name>]')
insert @tests values('min'		, 'min'			, 'nvarchar', 'cast(min([<column_name>]) as varchar(max)) as [min_<column_name>]', '[min_<column_name>]')
insert @tests values('min'		, 'min'			, 'numeric'	, 'cast(min([<column_name>]) as varchar(max)) as [min_<column_name>]', '[min_<column_name>]')
insert @tests values('min'		, 'min'			, 'int'		, 'cast(min([<column_name>]) as varchar(max)) as [min_<column_name>]', '[min_<column_name>]')
insert @tests values('min'		, 'min'			, 'bigint'	, 'cast(min([<column_name>]) as varchar(max)) as [min_<column_name>]', '[min_<column_name>]')

insert @tests values('max'		, 'max'			, 'varchar'	, 'cast(max([<column_name>]) as varchar(max)) as [max_<column_name>]', '[max_<column_name>]')
insert @tests values('max'		, 'max'			, 'nvarchar', 'cast(max([<column_name>]) as varchar(max)) as [max_<column_name>]', '[max_<column_name>]')
insert @tests values('max'		, 'max'			, 'numeric'	, 'cast(max([<column_name>]) as varchar(max)) as [max_<column_name>]', '[max_<column_name>]')
insert @tests values('max'		, 'max'			, 'int'		, 'cast(max([<column_name>]) as varchar(max)) as [max_<column_name>]', '[max_<column_name>]')
insert @tests values('max'		, 'max'			, 'bigint'	, 'cast(max([<column_name>]) as varchar(max)) as [max_<column_name>]', '[max_<column_name>]')

insert @tests values('domain'	, 'domain'		, 'varchar' , 'count_big(distinct [<column_name>]) as [domain_<column_name>]'	 , '[domain_<column_name>]')
insert @tests values('domain'	, 'domain'		, 'nvarchar', 'count_big(distinct [<column_name>]) as [domain_<column_name>]'	 , '[domain_<column_name>]')
insert @tests values('domain'	, 'domain'		, 'numeric'	, 'count_big(distinct [<column_name>]) as [domain_<column_name>]'	 , '[domain_<column_name>]')
insert @tests values('domain'	, 'domain'		, 'int'		, 'count_big(distinct [<column_name>]) as [domain_<column_name>]'	 , '[domain_<column_name>]')
insert @tests values('domain'	, 'domain'		, 'bigint'	, 'count_big(distinct [<column_name>]) as [domain_<column_name>]'	 , '[domain_<column_name>]')

insert @tests values('nullcount', 'nullcount'	, 'varchar' , 'sum(cast(case when [<column_name>] is null then 1 else 0 end as bigint)) as [nullcount_<column_name>]', '[nullcount_<column_name>]')
insert @tests values('nullcount', 'nullcount'	, 'nvarchar','sum(cast(case when [<column_name>] is null then 1 else 0 end as bigint)) as [nullcount_<column_name>]', '[nullcount_<column_name>]')
insert @tests values('nullcount', 'nullcount'	, 'numeric' , 'sum(cast(case when [<column_name>] is null then 1 else 0 end as bigint)) as [nullcount_<column_name>]', '[nullcount_<column_name>]')
insert @tests values('nullcount', 'nullcount'	, 'int'		, 'sum(cast(case when [<column_name>] is null then 1 else 0 end as bigint)) as [nullcount_<column_name>]', '[nullcount_<column_name>]')
insert @tests values('nullcount', 'nullcount'	, 'bigint'  , 'sum(cast(case when [<column_name>] is null then 1 else 0 end as bigint)) as [nullcount_<column_name>]', '[nullcount_<column_name>]')

insert @tests values('blankcount', 'blankcount'	, 'varchar' , 'sum(cast(case when [<column_name>] = '''' then 1 else 0 end as bigint)) as [blankcount_<column_name>]', '[blankcount_<column_name>]')
insert @tests values('blankcount', 'blankcount'	, 'nvarchar' ,'sum(cast(case when [<column_name>] = '''' then 1 else 0 end as bigint)) as [blankcount_<column_name>]', '[blankcount_<column_name>]')
insert @tests values('blankcount', 'blankcount'	, 'numeric' , 'cast(0 as bigint) as [blankcount_<column_name>]', '[blankcount_<column_name>]')
insert @tests values('blankcount', 'blankcount'	, 'int'		, 'cast(0 as bigint) as [blankcount_<column_name>]', '[blankcount_<column_name>]')
insert @tests values('blankcount', 'blankcount'	, 'bigint'  , 'cast(0 as bigint) as [blankcount_<column_name>]', '[blankcount_<column_name>]')

insert @tests values('minlength', 'minlength'	, 'varchar' , 'min(cast(len([<column_name>]) as bigint)) as [minlength_<column_name>]', '[minlength_<column_name>]')
insert @tests values('minlength', 'minlength'	, 'nvarchar' ,'min(cast(len([<column_name>]) as bigint)) as [minlength_<column_name>]', '[minlength_<column_name>]')
insert @tests values('minlength', 'minlength'	, 'numeric' , 'cast(0 as bigint) as [minlength_<column_name>]', '[minlength_<column_name>]')
insert @tests values('minlength', 'minlength'	, 'int'		, 'cast(0 as bigint) as [minlength_<column_name>]', '[minlength_<column_name>]')
insert @tests values('minlength', 'minlength'	, 'bigint'  , 'cast(0 as bigint) as [minlength_<column_name>]', '[minlength_<column_name>]')

insert @tests values('maxlength', 'maxlength'	, 'varchar' , 'max(cast(len([<column_name>]) as bigint)) as [maxlength_<column_name>]', '[maxlength_<column_name>]')
insert @tests values('maxlength', 'maxlength'	, 'nvarchar' ,'max(cast(len([<column_name>]) as bigint)) as [maxlength_<column_name>]', '[maxlength_<column_name>]')
insert @tests values('maxlength', 'maxlength'	, 'numeric' , 'cast(0 as bigint) as [maxlength_<column_name>]', '[maxlength_<column_name>]')
insert @tests values('maxlength', 'maxlength'	, 'int'		, 'cast(0 as bigint) as [maxlength_<column_name>]', '[maxlength_<column_name>]')
insert @tests values('maxlength', 'maxlength'	, 'bigint'  , 'cast(0 as bigint) as [maxlength_<column_name>]', '[maxlength_<column_name>]')

-- Truncate the Stage Table
set @sql1 = 'truncate table ' + @stage_qualified_name
exec(@sql1)

-- Build the test SQL

select @sat_loop_key = case when isnull(@satellite_key, 0) = 0 then max(satellite_key) else @satellite_key end 
	from [dbo].[dv_satellite] 
set @sat_loop_stop_key = isnull(@satellite_key, 0)
while @sat_loop_key >= @sat_loop_stop_key
/**********************************************************************************************************************/
begin
-- Looping through all Satellites
	if (@def_runtype = 'Weekly' and @sat_loop_key%7 = datepart(weekday, getdate()-7)-1)
	   or @def_runtype = 'Full'
	begin 
		delete from @Columns
		insert @Columns
		  select s.satellite_key
				,s.satellite_name
				,table_name = quotename(s.[satellite_database]) + '.' + quotename(s.[satellite_schema]) + '.' + quotename([ODV_Config].[dbo].[fn_get_object_name] (s.satellite_name, 'sat'))
				,c.column_key
				,c.column_name
				,t.test_name
				,replace(t.test_template,'<column_name>', c.column_name) as  test_script
				,replace(t.test_column,'<column_name>', c.column_name) as  test_column

		  from [dbo].[dv_satellite] s
		  inner join [dbo].[dv_satellite_column] sc
		  on sc.[satellite_key] = s.[satellite_key]
		  inner join [dbo].[dv_column] c
		  on c.column_key = sc.column_key
		  inner join @tests t
		  on c.[column_type] = t.[test_type]
		  where 1=1
			and c.discard_flag = 0 
			and c.is_retired = 0
			and s.satellite_key = @sat_loop_key
			and c.column_length >= 0
    
		if @@rowcount > 0
		begin
			select @sql1 = 'with w1 as ('
						 + 'select ''' + @run_time + ''' as [runtime]' + @crlf +
						 + ',' + cast(satellite_key as varchar(20)) + ' as [sat_key]' + @crlf 
						 + ',''' + satellite_name + ''' as [sat_name]' + @crlf
						 + ',''Sat'' as [object_type]' + @crlf
			from @Columns
			select @sql1 += ',' + test_script
						 -- + ',''' + test_name + '''as test_name' 
						 + @crlf
			from @Columns
			order by satellite_name, column_name
			select @sql2 = 'from ' + table_name + @crlf from @Columns
			set @sql2 += 'where ' + @def_global_default_load_date_time + ' >= ' + @sat_start_date_col + ' and ' +  @def_global_default_load_date_time + ' < ' + @sat_end_date_col + @crlf
					   + 'and ' + @sat_tombstone_col + '= 0)' + @crlf
					   + 'insert ' + @stage_qualified_name + @crlf 

			select @col_loop_key  = min(column_name) from @Columns
			while @col_loop_key is not null
			begin 
			--Looping through all Columns
				select @sql2 = @sql2 + 'select ' + @crlf
					  + ' runtime' + @crlf	
					  + ',sat_key' + @crlf	
					  + ',sat_name' + @crlf
					  + ',''' + @col_loop_key + ''' as [column_name]' + @crlf
				select @sql2 = @sql2 + ',''' + cast(column_key as varchar(20)) + ''' as [column_key]' + @crlf
					  from (select distinct column_key from @Columns where column_name = @col_loop_key) a
				select @sql2 += ',' + [test_column] + @crlf
					  from @Columns where column_name = @col_loop_key
				select @sql2 += 'from w1' + @crlf + 'union' + @crlf
				select @col_loop_key = min(column_name) from @Columns where column_name > @col_loop_key
			end
			set @sql2 = left(@sql2, len(@sql2) - 7)
			set @sql1 = @sql1 + @sql2
			execute sp_executesql @sql1
			IF @_JournalOnOff = 'ON' SET @_ProgressText = @crlf + @sql1 + @crlf
			--select @sql1
		end
	end
	select @sat_loop_key = max(satellite_key) from [dbo].[dv_satellite]
			where satellite_key < @sat_loop_key 
end
/**********************************************************************************************************************/

SET @_Step = 'Extract the Stats'
IF @_JournalOnOff = 'ON' SET @_ProgressText  = @_ProgressText + @crlf + @sql1 + @crlf

set @_Step = 'Completed'

/**********************************************************************************************************************/

SET @_ProgressText  = @_ProgressText + @NEW_LINE
				+ 'Step: [' + @_Step + '] completed ' 

IF @@TRANCOUNT > 0 COMMIT TRAN;

SET @_Message   = 'Successfully Ran Column Integrity Checker' 

END TRY
BEGIN CATCH
SET @_ErrorContext	= 'Failed to Run Column Integrity Checker' + @sat_qualified_name
IF (XACT_STATE() = -1) -- uncommitable transaction
OR (@@TRANCOUNT > 0 AND XACT_STATE() != 1) -- undocumented uncommitable transaction
	BEGIN
		ROLLBACK TRAN;
		SET @_ErrorContext = @_ErrorContext + ' (Forced rolled back of all changes)';
	END
	
EXEC log4.ExceptionHandler
		  @ErrorContext  = @_ErrorContext
		, @ErrorNumber   = @_Error OUT
		, @ReturnMessage = @_Message OUT
		, @ExceptionId   = @_ExceptionId OUT
;
END CATCH

--/////////////////////////////////////////////////////////////////////////////////////////////////
OnComplete:
--/////////////////////////////////////////////////////////////////////////////////////////////////

	--! Clean up

	--!
	--! Use dbo.udf_FormatElapsedTime() to get a nicely formatted run time string e.g.
	--! "0 hr(s) 1 min(s) and 22 sec(s)" or "1345 milliseconds"
	--!
	IF @_Error = 0
		BEGIN
			SET @_Step			= 'OnComplete'
			SET @_Severity		= @SEVERITY_SUCCESS
			SET @_Message		= COALESCE(@_Message, @_Step)
								+ ' in a total run time of ' + log4.FormatElapsedTime(@_SprocStartTime, NULL, 3)
			SET @_ProgressText  = @_ProgressText + @NEW_LINE + @_Message;
		END
	ELSE
		BEGIN
			SET @_Step			= COALESCE(@_Step, 'OnError')
			SET @_Severity		= @SEVERITY_SEVERE
			SET @_Message		= COALESCE(@_Message, @_Step)
								+ ' after a total run time of ' + log4.FormatElapsedTime(@_SprocStartTime, NULL, 3)
			SET @_ProgressText  = @_ProgressText + @NEW_LINE + @_Message;
		END

	IF @_JournalOnOff = 'ON'
		EXEC log4.JournalWriter
				  @Task				= @_FunctionName
				, @FunctionName		= @_FunctionName
				, @StepInFunction	= @_Step
				, @MessageText		= @_Message
				, @Severity			= @_Severity
				, @ExceptionId		= @_ExceptionId
				--! Supply all the progress info after we've gone to such trouble to collect it
				, @ExtraInfo        = @_ProgressText

	--! Finally, throw an exception that will be detected by the caller
	IF @DoThrowError = 1 AND @_Error > 0
		RAISERROR(@_Message, 16, 99);

	SET NOCOUNT OFF;

	--! Return the value of @@ERROR (which will be zero on success)
	RETURN (@_Error);
END
GO
PRINT N'Creating [dv_integrity].[dv_hub_metrics]...';


GO

CREATE procedure [dv_integrity].[dv_hub_metrics]
(
   @hub_key						int				= 0
  ,@stage_database				varchar(128)	= 'ODV_Metrics_Stage'
  ,@stage_schema				varchar(128)	= 'Stage'
  ,@stage_table					varchar(128)	= 'Integrity_Hub_Counts'
  ,@dogenerateerror				bit				= 0
  ,@dothrowerror				bit				= 1
)
as
begin
set nocount on
-- Local Defaults Values
declare @crlf char(2) = char(13) + char(10)
-- Global Defaults
DECLARE  
		 @def_global_default_load_date_time	varchar(128)
-- hub Table
declare  @hub_qualified_name				varchar(512)
        ,@hub_data_source_col               varchar(50)
		,@hub_load_date_time				varchar(50)
		
-- Stage Table
declare  @stage_qualified_name				varchar(512)
--  Working Storage
declare @SQL								nvarchar(max) = ''
declare @hub_loop_key						bigint
declare @hub_loop_stop_key					bigint
declare @run_time							varchar(50)

-- Log4TSQL Journal Constants 										
DECLARE @SEVERITY_CRITICAL      smallint = 1;
DECLARE @SEVERITY_SEVERE        smallint = 2;
DECLARE @SEVERITY_MAJOR         smallint = 4;
DECLARE @SEVERITY_MODERATE      smallint = 8;
DECLARE @SEVERITY_MINOR         smallint = 16;
DECLARE @SEVERITY_CONCURRENCY   smallint = 32;
DECLARE @SEVERITY_INFORMATION   smallint = 256;
DECLARE @SEVERITY_SUCCESS       smallint = 512;
DECLARE @SEVERITY_DEBUG         smallint = 1024;
DECLARE @NEW_LINE               char(1)  = CHAR(10);

-- Log4TSQL Standard/ExceptionHandler variables
DECLARE	  @_Error         int
		, @_RowCount      int
		, @_Step          varchar(128)
		, @_Message       nvarchar(512)
		, @_ErrorContext  nvarchar(512)

-- Log4TSQL JournalWriter variables
DECLARE   @_FunctionName			varchar(255)
		, @_SprocStartTime			datetime
		, @_JournalOnOff			varchar(3)
		, @_Severity				smallint
		, @_ExceptionId				int
		, @_StepStartTime			datetime
		, @_ProgressText			nvarchar(max)

SET @_Error             = 0;
SET @_FunctionName      = OBJECT_NAME(@@PROCID);
SET @_Severity          = @SEVERITY_INFORMATION;
SET @_SprocStartTime    = sysdatetimeoffset();
SET @_ProgressText      = '' 
SET @_JournalOnOff      = log4.GetJournalControl(@_FunctionName, 'IntegrityChecks');  -- left Group Name as HOWTO for now.
select @_FunctionName   = isnull(OBJECT_NAME(@@PROCID), 'Test');

-- set Log4TSQL Parameters for Logging:
SET @_ProgressText		= @_FunctionName + ' starting at ' + CONVERT(char(23), @_SprocStartTime, 121) + ' with inputs: '
						+ @NEW_LINE + '    @hub_key                     : ' + COALESCE(CAST(@hub_key AS varchar), 'NULL') 
						+ @NEW_LINE + '    @stage_database               : ' + @stage_database					
						+ @NEW_LINE + '    @stage_schema                 : ' + @stage_schema				
						+ @NEW_LINE + '    @stage_table                  : ' + @stage_table					    
						+ @NEW_LINE + '    @DoGenerateError              : ' + COALESCE(CAST(@DoGenerateError AS varchar), 'NULL')
						+ @NEW_LINE + '    @DoThrowError                 : ' + COALESCE(CAST(@DoThrowError AS varchar), 'NULL')
						+ @NEW_LINE

BEGIN TRY
SET @_Step = 'Generate any required error';
IF @DoGenerateError = 1
   select 1 / 0
SET @_Step = 'Validate inputs';

/*--------------------------------------------------------------------------------------------------------------*/
SET @_Step = 'Get Defaults'
select
-- Global Defaults
	@def_global_default_load_date_time	= cast([dbo].[fn_get_default_value] ('DefaultLoadDateTime','Global')	as varchar(128))

-- hub Defaults
select @hub_data_source_col = quotename(column_name)
from [dbo].[dv_default_column]
where 1=1
and object_type = 'hub'
and object_column_type = 'Data_Source'

select @hub_load_date_time = quotename(column_name)
from [dbo].[dv_default_column]
where 1=1
and object_type = 'hub'
and object_column_type = 'Load_Date_Time'

 --Stage Values
set @stage_qualified_name = quotename(@stage_database) + '.' + quotename(@stage_schema) + '.' + quotename(@stage_table) 
select @run_time = cast(sysdatetimeoffset() as varchar(50))

-- Truncate the Stage Table
set @SQL = 'truncate table ' + @stage_qualified_name
exec(@SQL)

set @_Step = 'Build the test SQL'
select @hub_loop_key = case when isnull(@hub_key, 0) = 0 then max(hub_key) else @hub_key end from [dbo].[dv_hub]
set @hub_loop_stop_key = isnull(@hub_key, 0)
while @hub_loop_key >= @hub_loop_stop_key
/**********************************************************************************************************************/
begin
if @hub_loop_key > 0
begin
	select @SQL =
	'if exists (select 1 from ' + quotename(l.[hub_database]) + '.[information_schema].[tables] where [table_schema] = ''' + l.[hub_schema] + ''' and [table_name] = ''' + [ODV_Config].[dbo].[fn_get_object_name] (l.hub_name, 'hub') + ''')' + @crlf +
	'begin' + @crlf +
	'insert ' + @stage_qualified_name + @crlf +
	'select ''' + @run_time + '''' + @crlf +
		+',' + cast(l.hub_key as varchar(50)) + ' as [object_key]' + @crlf
		+ ',''' + l.hub_name + ''' as [object_name]' + @crlf
		+ ',l.' + @hub_data_source_col + ' as [record_source]' + @crlf
		+ ',ss.[source_system_name]' + @crlf
		+ ',cfg.[source_table_name]' + @crlf

	+ ',count_big(*) as [RowCount]' + @crlf
	+'from ' + quotename(l.[hub_database]) + '.' + quotename(l.[hub_schema]) + '.' + quotename([ODV_Config].[dbo].[fn_get_object_name] (l.hub_name, 'hub')) +' l' + @crlf
	+'left join [dbo].[dv_source_table] cfg on cfg.source_table_key = l.' + @hub_data_source_col + @crlf
	+'left join [dbo].[dv_source_system] ss on ss.[source_system_key] = cfg.[system_key]' + @crlf
	+'where ' + @hub_load_date_time + ' <= ''' + @run_time + '''' + @crlf + 
	+ 'group by l.' + @hub_data_source_col + ', ss.[source_system_name],cfg.[source_table_name]' + @crlf 
	+ 'end' + @crlf
	+ @crlf + @crlf
	from [dbo].[dv_hub] l
	where hub_key = @hub_loop_key
	--select @SQL
	execute sp_executesql @SQL
end
select @hub_loop_key = max(hub_key) from [dbo].[dv_hub]
		where hub_key < @hub_loop_key
end
/**********************************************************************************************************************/

SET @_Step = 'Extract the Stats'
IF @_JournalOnOff = 'ON' SET @_ProgressText  = @_ProgressText + @crlf + @SQL + @crlf

set @_Step = 'Completed'

/**********************************************************************************************************************/

SET @_ProgressText  = @_ProgressText + @NEW_LINE
				+ 'Step: [' + @_Step + '] completed ' 

IF @@TRANCOUNT > 0 COMMIT TRAN;

SET @_Message   = 'Successfully Ran Hub Integrity Checker' 

END TRY
BEGIN CATCH
SET @_ErrorContext	= 'Failed to Run Hub Integrity Checker' + @hub_qualified_name
IF (XACT_STATE() = -1) -- uncommitable transaction
OR (@@TRANCOUNT > 0 AND XACT_STATE() != 1) -- undocumented uncommitable transaction
	BEGIN
		ROLLBACK TRAN;
		SET @_ErrorContext = @_ErrorContext + ' (Forced rolled back of all changes)';
	END
	
EXEC log4.ExceptionHandler
		  @ErrorContext  = @_ErrorContext
		, @ErrorNumber   = @_Error OUT
		, @ReturnMessage = @_Message OUT
		, @ExceptionId   = @_ExceptionId OUT
;
END CATCH

--/////////////////////////////////////////////////////////////////////////////////////////////////
OnComplete:
--/////////////////////////////////////////////////////////////////////////////////////////////////

	--! Clean up

	--!
	--! Use dbo.udf_FormatElapsedTime() to get a nicely formatted run time string e.g.
	--! "0 hr(s) 1 min(s) and 22 sec(s)" or "1345 milliseconds"
	--!
	IF @_Error = 0
		BEGIN
			SET @_Step			= 'OnComplete'
			SET @_Severity		= @SEVERITY_SUCCESS
			SET @_Message		= COALESCE(@_Message, @_Step)
								+ ' in a total run time of ' + log4.FormatElapsedTime(@_SprocStartTime, NULL, 3)
			SET @_ProgressText  = @_ProgressText + @NEW_LINE + @_Message;
		END
	ELSE
		BEGIN
			SET @_Step			= COALESCE(@_Step, 'OnError')
			SET @_Severity		= @SEVERITY_SEVERE
			SET @_Message		= COALESCE(@_Message, @_Step)
								+ ' after a total run time of ' + log4.FormatElapsedTime(@_SprocStartTime, NULL, 3)
			SET @_ProgressText  = @_ProgressText + @NEW_LINE + @_Message;
		END

	IF @_JournalOnOff = 'ON'
		EXEC log4.JournalWriter
				  @Task				= @_FunctionName
				, @FunctionName		= @_FunctionName
				, @StepInFunction	= @_Step
				, @MessageText		= @_Message
				, @Severity			= @_Severity
				, @ExceptionId		= @_ExceptionId
				--! Supply all the progress info after we've gone to such trouble to collect it
				, @ExtraInfo        = @_ProgressText

	--! Finally, throw an exception that will be detected by the caller
	IF @DoThrowError = 1 AND @_Error > 0
		RAISERROR(@_Message, 16, 99);

	SET NOCOUNT OFF;

	--! Return the value of @@ERROR (which will be zero on success)
	RETURN (@_Error);
END
GO
PRINT N'Creating [dv_integrity].[dv_link_metrics]...';


GO

CREATE procedure [dv_integrity].[dv_link_metrics]
(
   @link_key					int				= 0
  ,@stage_database				varchar(128)	= 'ODV_Metrics_Stage'
  ,@stage_schema				varchar(128)	= 'Stage'
  ,@stage_table					varchar(128)	= 'Integrity_Link_Counts'
  ,@dogenerateerror				bit				= 0
  ,@dothrowerror				bit				= 1
)
as
begin
set nocount on
-- Local Defaults Values
declare @crlf char(2) = char(13) + char(10)
-- Global Defaults
DECLARE  
		 @def_global_default_load_date_time	varchar(128)
-- Link Table
declare  @link_qualified_name				varchar(512)
        ,@link_data_source_col              varchar(50)
		,@link_load_date_time				varchar(50)
-- Stage Table
declare  @stage_qualified_name				varchar(512)
--  Working Storage
declare @SQL								nvarchar(max) = ''
declare @link_loop_key						bigint
declare @link_loop_stop_key					bigint
declare @run_time							varchar(50)

-- Log4TSQL Journal Constants 										
DECLARE @SEVERITY_CRITICAL      smallint = 1;
DECLARE @SEVERITY_SEVERE        smallint = 2;
DECLARE @SEVERITY_MAJOR         smallint = 4;
DECLARE @SEVERITY_MODERATE      smallint = 8;
DECLARE @SEVERITY_MINOR         smallint = 16;
DECLARE @SEVERITY_CONCURRENCY   smallint = 32;
DECLARE @SEVERITY_INFORMATION   smallint = 256;
DECLARE @SEVERITY_SUCCESS       smallint = 512;
DECLARE @SEVERITY_DEBUG         smallint = 1024;
DECLARE @NEW_LINE               char(1)  = CHAR(10);

-- Log4TSQL Standard/ExceptionHandler variables
DECLARE	  @_Error         int
		, @_RowCount      int
		, @_Step          varchar(128)
		, @_Message       nvarchar(512)
		, @_ErrorContext  nvarchar(512)

-- Log4TSQL JournalWriter variables
DECLARE   @_FunctionName			varchar(255)
		, @_SprocStartTime			datetime
		, @_JournalOnOff			varchar(3)
		, @_Severity				smallint
		, @_ExceptionId				int
		, @_StepStartTime			datetime
		, @_ProgressText			nvarchar(max)

SET @_Error             = 0;
SET @_FunctionName      = OBJECT_NAME(@@PROCID);
SET @_Severity          = @SEVERITY_INFORMATION;
SET @_SprocStartTime    = sysdatetimeoffset();
SET @_ProgressText      = '' 
SET @_JournalOnOff      = log4.GetJournalControl(@_FunctionName, 'IntegrityChecks');  -- left Group Name as HOWTO for now.
select @_FunctionName   = isnull(OBJECT_NAME(@@PROCID), 'Test');

-- set Log4TSQL Parameters for Logging:
SET @_ProgressText		= @_FunctionName + ' starting at ' + CONVERT(char(23), @_SprocStartTime, 121) + ' with inputs: '
						+ @NEW_LINE + '    @link_key                     : ' + COALESCE(CAST(@link_key AS varchar), 'NULL') 
						+ @NEW_LINE + '    @stage_database               : ' + @stage_database					
						+ @NEW_LINE + '    @stage_schema                 : ' + @stage_schema				
						+ @NEW_LINE + '    @stage_table                  : ' + @stage_table					    
						+ @NEW_LINE + '    @DoGenerateError              : ' + COALESCE(CAST(@DoGenerateError AS varchar), 'NULL')
						+ @NEW_LINE + '    @DoThrowError                 : ' + COALESCE(CAST(@DoThrowError AS varchar), 'NULL')
						+ @NEW_LINE

BEGIN TRY
SET @_Step = 'Generate any required error';
IF @DoGenerateError = 1
   select 1 / 0
SET @_Step = 'Validate inputs';

/*--------------------------------------------------------------------------------------------------------------*/
SET @_Step = 'Get Defaults'
select
-- Global Defaults
	@def_global_default_load_date_time	= cast([dbo].[fn_get_default_value] ('DefaultLoadDateTime','Global')	as varchar(128))

-- Link Defaults
select @link_data_source_col = quotename(column_name)
from [dbo].[dv_default_column]
where 1=1
and object_type = 'lnk'
and object_column_type = 'Data_Source'

select @link_load_date_time = quotename(column_name)
from [dbo].[dv_default_column]
where 1=1
and object_type = 'lnk'
and object_column_type = 'Load_Date_Time'

 --Stage Values
set @stage_qualified_name = quotename(@stage_database) + '.' + quotename(@stage_schema) + '.' + quotename(@stage_table) 
select @run_time = cast(sysdatetimeoffset() as varchar(50))

--Truncate the Stage Table
set @SQL = 'truncate table ' + @stage_qualified_name
exec(@SQL)

set @_Step = 'Build the test SQL'
select @link_loop_key = case when isnull(@link_key, 0) = 0 then max(link_key) else @link_key end from [dbo].[dv_link]
set @link_loop_stop_key = isnull(@link_key, 0)
while @link_loop_key >= @link_loop_stop_key
/**********************************************************************************************************************/
begin
if @link_loop_key > 0
begin
	select @SQL =
	'if exists (select 1 from ' + quotename(l.[link_database]) + '.[information_schema].[tables] where [table_schema] = ''' + l.[link_schema] + ''' and [table_name] = ''' + [ODV_Config].[dbo].[fn_get_object_name] (l.link_name, 'lnk') + ''')' + @crlf +
	'begin' + @crlf +
	'insert ' + @stage_qualified_name + @crlf +
	'select ''' + @run_time + '''' + @crlf +
	+',' + cast(l.link_key as varchar(50)) + ' as [object_key]' + @crlf
	+ ',''' + l.link_name + ''' as [object_name]' + @crlf
	+ ',l.' + @link_data_source_col + ' as [record_source]' + @crlf
	+ ',ss.[source_system_name]' + @crlf
	+ ',cfg.[source_table_name]' + @crlf
	+ ',count_big(*) as [Runkey]' + @crlf
	+'from ' + quotename(l.[link_database]) + '.' + quotename(l.[link_schema]) + '.' + quotename([ODV_Config].[dbo].[fn_get_object_name] (l.link_name, 'lnk')) +' l' + @crlf
	+'left join [dbo].[dv_source_table] cfg on cfg.source_table_key = l.' + @link_data_source_col + @crlf
	+'left join [dbo].[dv_source_system] ss on ss.[source_system_key] = cfg.[system_key]' + @crlf
	+'where ' + @link_load_date_time + ' <= ''' + @run_time + '''' + @crlf + 
	+ 'group by l.' + @link_data_source_col + ', ss.[source_system_name],cfg.[source_table_name]' + @crlf 
	+ 'end' + @crlf
    + @crlf + @crlf
	from [dbo].[dv_link] l
	where link_key = @link_loop_key
	--select @SQL
	exec sp_executesql @SQL
end
select @link_loop_key = max(link_key) from [dbo].[dv_link]
		where link_key < @link_loop_key
end
/**********************************************************************************************************************/

SET @_Step = 'Extract the Stats'
IF @_JournalOnOff = 'ON' SET @_ProgressText  = @_ProgressText + @crlf + @SQL + @crlf

set @_Step = 'Completed'

/**********************************************************************************************************************/

SET @_ProgressText  = @_ProgressText + @NEW_LINE
				+ 'Step: [' + @_Step + '] completed ' 

IF @@TRANCOUNT > 0 COMMIT TRAN;

SET @_Message   = 'Successfully Ran Link Integrity Checker' 

END TRY
BEGIN CATCH
SET @_ErrorContext	= 'Failed to Run Link Integrity Checker' + @link_qualified_name
IF (XACT_STATE() = -1) -- uncommitable transaction
OR (@@TRANCOUNT > 0 AND XACT_STATE() != 1) -- undocumented uncommitable transaction
	BEGIN
		ROLLBACK TRAN;
		SET @_ErrorContext = @_ErrorContext + ' (Forced rolled back of all changes)';
	END
	
EXEC log4.ExceptionHandler
		  @ErrorContext  = @_ErrorContext
		, @ErrorNumber   = @_Error OUT
		, @ReturnMessage = @_Message OUT
		, @ExceptionId   = @_ExceptionId OUT
;
END CATCH

--/////////////////////////////////////////////////////////////////////////////////////////////////
OnComplete:
--/////////////////////////////////////////////////////////////////////////////////////////////////

	--! Clean up

	--!
	--! Use dbo.udf_FormatElapsedTime() to get a nicely formatted run time string e.g.
	--! "0 hr(s) 1 min(s) and 22 sec(s)" or "1345 milliseconds"
	--!
	IF @_Error = 0
		BEGIN
			SET @_Step			= 'OnComplete'
			SET @_Severity		= @SEVERITY_SUCCESS
			SET @_Message		= COALESCE(@_Message, @_Step)
								+ ' in a total run time of ' + log4.FormatElapsedTime(@_SprocStartTime, NULL, 3)
			SET @_ProgressText  = @_ProgressText + @NEW_LINE + @_Message;
		END
	ELSE
		BEGIN
			SET @_Step			= COALESCE(@_Step, 'OnError')
			SET @_Severity		= @SEVERITY_SEVERE
			SET @_Message		= COALESCE(@_Message, @_Step)
								+ ' after a total run time of ' + log4.FormatElapsedTime(@_SprocStartTime, NULL, 3)
			SET @_ProgressText  = @_ProgressText + @NEW_LINE + @_Message;
		END

	IF @_JournalOnOff = 'ON'
		EXEC log4.JournalWriter
				  @Task				= @_FunctionName
				, @FunctionName		= @_FunctionName
				, @StepInFunction	= @_Step
				, @MessageText		= @_Message
				, @Severity			= @_Severity
				, @ExceptionId		= @_ExceptionId
				--! Supply all the progress info after we've gone to such trouble to collect it
				, @ExtraInfo        = @_ProgressText

	--! Finally, throw an exception that will be detected by the caller
	IF @DoThrowError = 1 AND @_Error > 0
		RAISERROR(@_Message, 16, 99);

	SET NOCOUNT OFF;

	--! Return the value of @@ERROR (which will be zero on success)
	RETURN (@_Error);
END
GO
PRINT N'Creating [dv_integrity].[dv_sat_metrics]...';


GO

CREATE procedure [dv_integrity].[dv_sat_metrics]
(
   @satellite_key				int				= 0
  ,@stage_database				varchar(128)	= 'ODV_Metrics_Stage'
  ,@stage_schema				varchar(128)	= 'Stage'
  ,@stage_table					varchar(128)	= 'Integrity_Sat_Counts'
  ,@dogenerateerror				bit				= 0
  ,@dothrowerror				bit				= 1
)
as
begin
set nocount on
-- Local Defaults Values
declare @crlf char(2) = char(13) + char(10)
-- Global Defaults
DECLARE  
		 @def_global_default_load_date_time	varchar(128)
--Sat Defaults									
declare  @sat_tombstone_col					varchar(128)
		,@sat_current_row_col				varchar(128)
		,@sat_start_date_col				varchar(128)
		,@sat_end_date_col					varchar(128)	
-- Sat Table
declare  @sat_database						varchar(128)
		,@sat_schema						varchar(128)
		,@sat_table							varchar(128)
		,@sat_qualified_name				varchar(512)
-- Stage Table
declare  @stage_qualified_name				varchar(512)
--  Working Storage
declare @SQL								nvarchar(max) = ''
declare @sat_loop_key						bigint
declare @sat_loop_stop_key					bigint
declare @run_time							varchar(50)

-- Log4TSQL Journal Constants 										
DECLARE @SEVERITY_CRITICAL      smallint = 1;
DECLARE @SEVERITY_SEVERE        smallint = 2;
DECLARE @SEVERITY_MAJOR         smallint = 4;
DECLARE @SEVERITY_MODERATE      smallint = 8;
DECLARE @SEVERITY_MINOR         smallint = 16;
DECLARE @SEVERITY_CONCURRENCY   smallint = 32;
DECLARE @SEVERITY_INFORMATION   smallint = 256;
DECLARE @SEVERITY_SUCCESS       smallint = 512;
DECLARE @SEVERITY_DEBUG         smallint = 1024;
DECLARE @NEW_LINE               char(1)  = CHAR(10);

-- Log4TSQL Standard/ExceptionHandler variables
DECLARE	  @_Error         int
		, @_RowCount      int
		, @_Step          varchar(128)
		, @_Message       nvarchar(512)
		, @_ErrorContext  nvarchar(512)

-- Log4TSQL JournalWriter variables
DECLARE   @_FunctionName			varchar(255)
		, @_SprocStartTime			datetime
		, @_JournalOnOff			varchar(3)
		, @_Severity				smallint
		, @_ExceptionId				int
		, @_StepStartTime			datetime
		, @_ProgressText			nvarchar(max)

SET @_Error             = 0;
SET @_FunctionName      = OBJECT_NAME(@@PROCID);
SET @_Severity          = @SEVERITY_INFORMATION;
SET @_SprocStartTime    = sysdatetimeoffset();
SET @_ProgressText      = '' 
SET @_JournalOnOff      = log4.GetJournalControl(@_FunctionName, 'IntegrityChecks');  -- left Group Name as HOWTO for now.
select @_FunctionName   = isnull(OBJECT_NAME(@@PROCID), 'Test');

-- set Log4TSQL Parameters for Logging:
SET @_ProgressText		= @_FunctionName + ' starting at ' + CONVERT(char(23), @_SprocStartTime, 121) + ' with inputs: '
						+ @NEW_LINE + '    @satellite_key                : ' + COALESCE(CAST(@satellite_key AS varchar), 'NULL') 
						+ @NEW_LINE + '    @stage_database               : ' + @stage_database					
						+ @NEW_LINE + '    @stage_schema                 : ' + @stage_schema				
						+ @NEW_LINE + '    @stage_table                  : ' + @stage_table					    
						+ @NEW_LINE + '    @DoGenerateError              : ' + COALESCE(CAST(@DoGenerateError AS varchar), 'NULL')
						+ @NEW_LINE + '    @DoThrowError                 : ' + COALESCE(CAST(@DoThrowError AS varchar), 'NULL')
						+ @NEW_LINE

BEGIN TRY
SET @_Step = 'Generate any required error';
IF @DoGenerateError = 1
   select 1 / 0
SET @_Step = 'Validate inputs';

/*--------------------------------------------------------------------------------------------------------------*/
SET @_Step = 'Get Defaults'
select
-- Global Defaults
	@def_global_default_load_date_time	= cast([dbo].[fn_get_default_value] ('DefaultLoadDateTime','Global')	as varchar(128))

-- Sat Defaults
select @sat_start_date_col = quotename(column_name)
from [dbo].[dv_default_column]
where 1=1
and object_type	= 'sat'
and object_column_type = 'Version_Start_Date'
select @sat_end_date_col = quotename(column_name)
from [dbo].[dv_default_column]
where 1=1
and object_type	= 'sat'
and object_column_type = 'Version_End_Date'
select @sat_current_row_col = quotename(column_name)
from [dbo].[dv_default_column]
where 1=1
and object_type	= 'sat'
and object_column_type = 'Current_Row'
select @sat_tombstone_col = quotename(column_name)
from [dbo].[dv_default_column]
where 1=1
and object_type	= 'sat'
and object_column_type = 'Tombstone_Indicator'
 --Stage Values
set @stage_qualified_name = quotename(@stage_database) + '.' + quotename(@stage_schema) + '.' + quotename(@stage_table) 
select @run_time = cast(sysdatetimeoffset() as varchar(50))

-- Truncate the Stage Table
set @SQL = 'truncate table ' + @stage_qualified_name
exec(@SQL)

set @_Step = 'Build the test SQL'
select @sat_loop_key = case when isnull(@satellite_key, 0) = 0 then max(satellite_key) else @satellite_key end from [dbo].[dv_satellite]
set @sat_loop_stop_key = isnull(@satellite_key, 0)
while @sat_loop_key >= @sat_loop_stop_key
/**********************************************************************************************************************/
begin
select @SQL =
'if exists (select 1 from ' + quotename(s.[satellite_database]) + '.[information_schema].[tables] where [table_schema] = ''' + s.[satellite_schema] + ''' and [table_name] = ''' + [ODV_Config].[dbo].[fn_get_object_name] (s.satellite_name, 'sat') + ''')' + @crlf +
'begin' + @crlf +
'insert ' + @stage_qualified_name + @crlf +
'select ''' + @run_time + '''' + @crlf +
+',' + cast(s.satellite_key as varchar(50)) + ' as [object_key]' + @crlf
      + ',''' + s.satellite_name + ''' as [object_name]' + @crlf
+ ',count_big(*) as [total_rows]' + @crlf
+ ',sum(cast(case when ' + @sat_tombstone_col + ' = 0 and ' + @sat_current_row_col + ' = 1 then 1 else 0 end as bigint)) as [current_rows]' + @crlf
+ ',sum(cast(case when ' + @sat_tombstone_col + ' = 0 and ' + @sat_current_row_col + ' = 0 then 1 else 0 end as bigint)) as [versioned_rows]' + @crlf
+ ',sum(cast(' + @sat_tombstone_col + ' as bigint)) as [tombstones]'  + @crlf
+ 'from ' + quotename(s.[satellite_database]) + '.' + quotename(s.[satellite_schema]) + '.' + quotename([ODV_Config].[dbo].[fn_get_object_name] (s.satellite_name, 'sat')) + @crlf
+ 'end' + @crlf
+ @crlf + @crlf
from [dbo].[dv_satellite] s
where satellite_key = @sat_loop_key
--select @SQL
execute sp_executesql @SQL
select @sat_loop_key = max(satellite_key) from [dbo].[dv_satellite]
		where satellite_key < @sat_loop_key
end
/**********************************************************************************************************************/

SET @_Step = 'Extract the Stats'
IF @_JournalOnOff = 'ON' SET @_ProgressText  = @_ProgressText + @crlf + @SQL + @crlf

set @_Step = 'Completed'

/**********************************************************************************************************************/

SET @_ProgressText  = @_ProgressText + @NEW_LINE
				+ 'Step: [' + @_Step + '] completed ' 

IF @@TRANCOUNT > 0 COMMIT TRAN;

SET @_Message   = 'Successfully Ran Satellite Integrity Checker' 

END TRY
BEGIN CATCH
SET @_ErrorContext	= 'Failed to Run Satellite Integrity Checker' + @sat_qualified_name
IF (XACT_STATE() = -1) -- uncommitable transaction
OR (@@TRANCOUNT > 0 AND XACT_STATE() != 1) -- undocumented uncommitable transaction
	BEGIN
		ROLLBACK TRAN;
		SET @_ErrorContext = @_ErrorContext + ' (Forced rolled back of all changes)';
	END
	
EXEC log4.ExceptionHandler
		  @ErrorContext  = @_ErrorContext
		, @ErrorNumber   = @_Error OUT
		, @ReturnMessage = @_Message OUT
		, @ExceptionId   = @_ExceptionId OUT
;
END CATCH

--/////////////////////////////////////////////////////////////////////////////////////////////////
OnComplete:
--/////////////////////////////////////////////////////////////////////////////////////////////////

	--! Clean up

	--!
	--! Use dbo.udf_FormatElapsedTime() to get a nicely formatted run time string e.g.
	--! "0 hr(s) 1 min(s) and 22 sec(s)" or "1345 milliseconds"
	--!
	IF @_Error = 0
		BEGIN
			SET @_Step			= 'OnComplete'
			SET @_Severity		= @SEVERITY_SUCCESS
			SET @_Message		= COALESCE(@_Message, @_Step)
								+ ' in a total run time of ' + log4.FormatElapsedTime(@_SprocStartTime, NULL, 3)
			SET @_ProgressText  = @_ProgressText + @NEW_LINE + @_Message;
		END
	ELSE
		BEGIN
			SET @_Step			= COALESCE(@_Step, 'OnError')
			SET @_Severity		= @SEVERITY_SEVERE
			SET @_Message		= COALESCE(@_Message, @_Step)
								+ ' after a total run time of ' + log4.FormatElapsedTime(@_SprocStartTime, NULL, 3)
			SET @_ProgressText  = @_ProgressText + @NEW_LINE + @_Message;
		END

	IF @_JournalOnOff = 'ON'
		EXEC log4.JournalWriter
				  @Task				= @_FunctionName
				, @FunctionName		= @_FunctionName
				, @StepInFunction	= @_Step
				, @MessageText		= @_Message
				, @Severity			= @_Severity
				, @ExceptionId		= @_ExceptionId
				--! Supply all the progress info after we've gone to such trouble to collect it
				, @ExtraInfo        = @_ProgressText

	--! Finally, throw an exception that will be detected by the caller
	IF @DoThrowError = 1 AND @_Error > 0
		RAISERROR(@_Message, 16, 99);

	SET NOCOUNT OFF;

	--! Return the value of @@ERROR (which will be zero on success)
	RETURN (@_Error);
END
GO
PRINT N'Creating [dv_integrity].[dv_check_sats_for_duplicate_keys]...';


GO
CREATE procedure [dv_integrity].[dv_check_sats_for_duplicate_keys]
(
  @dogenerateerror				bit				= 0
, @dothrowerror					bit				= 1
)
as
begin
set nocount on
declare 
	 @def_sat_schema		varchar(128)
	,@def_dv_rowstartdate		varchar(128)
	,@def_dv_row_is_current	varchar(128)
	,@def_dv_is_tombstone	varchar(128)
	,@sat_surrogate_keyname	varchar(128)
	,@sat_database			varchar(128)
	,@sat_qualified_name	varchar(512)

	,@sql					nvarchar(max)

declare @crlf				char(2) = CHAR(13) + CHAR(10)

-- Log4TSQL Journal Constants 										
DECLARE @SEVERITY_CRITICAL      smallint = 1;
DECLARE @SEVERITY_SEVERE        smallint = 2;
DECLARE @SEVERITY_MAJOR         smallint = 4;
DECLARE @SEVERITY_MODERATE      smallint = 8;
DECLARE @SEVERITY_MINOR         smallint = 16;
DECLARE @SEVERITY_CONCURRENCY   smallint = 32;
DECLARE @SEVERITY_INFORMATION   smallint = 256;
DECLARE @SEVERITY_SUCCESS       smallint = 512;
DECLARE @SEVERITY_DEBUG         smallint = 1024;
DECLARE @NEW_LINE               char(1)  = CHAR(10);

-- Log4TSQL Standard/ExceptionHandler variables
DECLARE	  @_Error         int
		, @_RowCount      int
		, @_Step          varchar(128)
		, @_Message       nvarchar(512)
		, @_ErrorContext  nvarchar(512)

-- Log4TSQL JournalWriter variables
DECLARE   @_FunctionName			varchar(255)
		, @_SprocStartTime			datetime
		, @_JournalOnOff			varchar(3)
		, @_Severity				smallint
		, @_ExceptionId				int
		, @_StepStartTime			datetime
		, @_ProgressText			nvarchar(max)

SET @_Error             = 0;
SET @_FunctionName      = OBJECT_NAME(@@PROCID);
SET @_Severity          = @SEVERITY_INFORMATION;
SET @_SprocStartTime    = sysdatetimeoffset();
SET @_ProgressText      = '' 
SET @_JournalOnOff      = log4.GetJournalControl(@_FunctionName, 'IntegrityChecks');  -- left Group Name as HOWTO for now.


-- set Log4TSQL Parameters for Logging:
SET @_ProgressText		= @_FunctionName + ' starting at ' + CONVERT(char(23), @_SprocStartTime, 121) + ' with inputs: '
						+ @NEW_LINE + '    @DoGenerateError              : ' + COALESCE(CAST(@DoGenerateError AS varchar), 'NULL')
						+ @NEW_LINE + '    @DoThrowError                 : ' + COALESCE(CAST(@DoThrowError AS varchar), 'NULL')
						+ @NEW_LINE

BEGIN TRY
SET @_Step = 'Generate any required error';
IF @DoGenerateError = 1
   select 1 / 0
SET @_Step = 'Validate inputs';

--IF isnull(@vault_source_load_type, 'Full') not in ('Full', 'Delta')
--			RAISERROR('Invalid Load Type: %s', 16, 1, @vault_source_load_type);
--IF isnull(@recreate_flag, '') not in ('Y', 'N') 
--			RAISERROR('Valid values for recreate_flag are Y or N : %s', 16, 1, @recreate_flag);
/*--------------------------------------------------------------------------------------------------------------*/
SET @_Step = 'Get Defaults'

select @_FunctionName      = isnull(OBJECT_NAME(@@PROCID), 'Test');
select @def_sat_schema	= cast([dbo].[fn_get_default_value]('schema','sat') as varchar)

select  @def_dv_rowstartdate	   	= [column_name] from [dbo].[dv_default_column] where object_type = 'sat' and object_column_type = 'Version_Start_Date'
select  @def_dv_row_is_current	= [column_name] from [dbo].[dv_default_column] where object_type = 'sat' and object_column_type = 'Current_Row'
select  @def_dv_is_tombstone	= [column_name] from [dbo].[dv_default_column] where object_type = 'sat' and object_column_type = 'Tombstone_Indicator'


SET @_Step = 'Build Cursor for all Satellites' 
declare cur_checks cursor for 
select 	 sat_surrogate_keyname	= case when link_hub_satellite_flag = 'H' then (select column_name from [dbo].[fn_get_key_definition](h.[hub_name],'Hub'))	
                                       when link_hub_satellite_flag = 'L' then (select column_name from [dbo].[fn_get_key_definition](l.[link_name],'Lnk'))
									   else '<Unknown>'
									   end		
		,sat_qualified_name		= quotename(s.[satellite_database]) + '.' + quotename(coalesce(s.[satellite_schema], @def_sat_schema, 'dbo')) + '.' + quotename((select [dbo].[fn_get_object_name] (s.[satellite_name], 'sat')))       
		,sat_database = s.[satellite_database]
from [dbo].[dv_satellite] s
left join [dbo].[dv_hub] h
on h.hub_key = s.hub_key
and s.link_hub_satellite_flag = 'H' 
left join [dbo].[dv_link] l
on l.link_key = s.link_key
and s.link_hub_satellite_flag = 'L'
where 1=1
order by sat_qualified_name
				
open cur_checks
fetch next from cur_checks 
into 	 @sat_surrogate_keyname	
	 	,@sat_qualified_name
		,@sat_database

while @@FETCH_STATUS = 0
begin
SET @_Step = 'Checks on: ' + @sat_qualified_name

set @sql     = 'declare @xml1 varchar(max);'					+ @crlf +
               'select  @xml1 = ('								+ @crlf
select @sql += 'select s.'  + @sat_surrogate_keyname + ''		+ @crlf +
			   '      ,s.[' + @def_dv_rowstartdate	   + ']'	+ @crlf +
			   'from ' + @sat_qualified_name + ' s'				+ @crlf + 
			   'group by s.'  + @sat_surrogate_keyname + ''		+ @crlf +
			   '        ,s.[' + @def_dv_rowstartdate    + '] having count(*) > 1' + @crlf +
			   'order by s.'  + @sat_surrogate_keyname + ''		+ @crlf +
			   '        ,s.[' + @def_dv_rowstartdate    + ']'		+ @crlf +
			   'for xml auto)'									+ @crlf
set @sql = @sql
			+ 'if @xml1 is not null '							+ @crlf
            + 'EXECUTE [log4].[JournalWriter] @FunctionName = ''' + @_FunctionName + ''''
			+ ', @MessageText = ''Duplicate Keys Detected In - ' + @sat_qualified_name + ' - See [log4].[JournalDetail] for details''' 
			+ ', @ExtraInfo = @xml1' 
			+ ', @DatabaseName = ''' + @sat_database + ''''
			+ ', @Task = ''Duplicate Satellite Key Check'''
			+ ', @StepInFunction = ''' + @_Step + ''''
			+ ', @Severity = 256'
			+ ', @ExceptionId = 3601;' + @crlf
set @_ProgressText = @_ProgressText + 'Checked ' + @sat_qualified_name + ' for Duplicate Keys' + @crlf
--print @sql
EXECUTE sp_executesql @sql;

fetch next from cur_checks 
into 	 @sat_surrogate_keyname	
	 	,@sat_qualified_name
		,@sat_database
end

close cur_checks
deallocate cur_checks

set @_Step = 'Completed'

/**********************************************************************************************************************/

SET @_ProgressText  = @_ProgressText + @NEW_LINE
				+ 'Step: [' + @_Step + '] completed ' 

IF @@TRANCOUNT > 0 COMMIT TRAN;

SET @_Message   = 'Successfully Ran Satellite Duplicate Key Checker' 

END TRY
BEGIN CATCH
SET @_ErrorContext	= 'Failed to Run Satellite Duplicate Key Checker' + @sat_qualified_name
IF (XACT_STATE() = -1) -- uncommitable transaction
OR (@@TRANCOUNT > 0 AND XACT_STATE() != 1) -- undocumented uncommitable transaction
	BEGIN
		ROLLBACK TRAN;
		SET @_ErrorContext = @_ErrorContext + ' (Forced rolled back of all changes)';
	END
	
EXEC log4.ExceptionHandler
		  @ErrorContext  = @_ErrorContext
		, @ErrorNumber   = @_Error OUT
		, @ReturnMessage = @_Message OUT
		, @ExceptionId   = @_ExceptionId OUT
;
END CATCH

--/////////////////////////////////////////////////////////////////////////////////////////////////
OnComplete:
--/////////////////////////////////////////////////////////////////////////////////////////////////

	--! Clean up

	--!
	--! Use dbo.udf_FormatElapsedTime() to get a nicely formatted run time string e.g.
	--! "0 hr(s) 1 min(s) and 22 sec(s)" or "1345 milliseconds"
	--!
	IF @_Error = 0
		BEGIN
			SET @_Step			= 'OnComplete'
			SET @_Severity		= @SEVERITY_SUCCESS
			SET @_Message		= COALESCE(@_Message, @_Step)
								+ ' in a total run time of ' + log4.FormatElapsedTime(@_SprocStartTime, NULL, 3)
			SET @_ProgressText  = @_ProgressText + @NEW_LINE + @_Message;
		END
	ELSE
		BEGIN
			SET @_Step			= COALESCE(@_Step, 'OnError')
			SET @_Severity		= @SEVERITY_SEVERE
			SET @_Message		= COALESCE(@_Message, @_Step)
								+ ' after a total run time of ' + log4.FormatElapsedTime(@_SprocStartTime, NULL, 3)
			SET @_ProgressText  = @_ProgressText + @NEW_LINE + @_Message;
		END

	IF @_JournalOnOff = 'ON'
		EXEC log4.JournalWriter
				  @Task				= @_FunctionName
				, @FunctionName		= @_FunctionName
				, @StepInFunction	= @_Step
				, @MessageText		= @_Message
				, @Severity			= @_Severity
				, @ExceptionId		= @_ExceptionId
				--! Supply all the progress info after we've gone to such trouble to collect it
				, @ExtraInfo        = @_ProgressText

	--! Finally, throw an exception that will be detected by the caller
	IF @DoThrowError = 1 AND @_Error > 0
		RAISERROR(@_Message, 16, 99);

	SET NOCOUNT OFF;

	--! Return the value of @@ERROR (which will be zero on success)
	RETURN (@_Error);
END
GO
PRINT N'Creating [dv_release].[dv_change_object_release]...';


GO
CREATE PROCEDURE [dv_release].[dv_change_object_release]
(
  @vault_config_table		varchar(128)	= NULL
, @vault_config_table_key   int				= NULL
, @vault_old_release		int				= NULL
, @vault_new_release		int				= NULL
, @dogenerateerror			bit				= 0
, @dothrowerror				bit				= 1
)
AS
BEGIN
SET NOCOUNT ON

--declare @filegroup		varchar(256)
--declare @schema			varchar(256)
--declare @database		varchar(256)
--declare @table_name		varchar(256)
--declare @pk_name		varchar(256)
--declare @crlf			char(2) = CHAR(13) + CHAR(10)
declare @SQL							nvarchar(max) = ''
declare @new_release_key				int
declare @old_release_key				int
declare @vault_config_table_schema_name varchar(128)
declare @vault_config_table_key_name	varchar(128)

-- Log4TSQL Journal Constants 
DECLARE @SEVERITY_CRITICAL      smallint = 1;
DECLARE @SEVERITY_SEVERE        smallint = 2;
DECLARE @SEVERITY_MAJOR         smallint = 4;
DECLARE @SEVERITY_MODERATE      smallint = 8;
DECLARE @SEVERITY_MINOR         smallint = 16;
DECLARE @SEVERITY_CONCURRENCY   smallint = 32;
DECLARE @SEVERITY_INFORMATION   smallint = 256;
DECLARE @SEVERITY_SUCCESS       smallint = 512;
DECLARE @SEVERITY_DEBUG         smallint = 1024;
DECLARE @NEW_LINE               char(1)  = CHAR(10);

-- Log4TSQL Standard/ExceptionHandler variables
DECLARE	  @_Error         int
		, @_RowCount      int
		, @_Step          varchar(128)
		, @_Message       nvarchar(512)
		, @_ErrorContext  nvarchar(512)

-- Log4TSQL JournalWriter variables
DECLARE   @_FunctionName			varchar(255)
		, @_SprocStartTime			datetime
		, @_JournalOnOff			varchar(3)
		, @_Severity				smallint
		, @_ExceptionId				int
		, @_StepStartTime			datetime
		, @_ProgressText			nvarchar(max)

SET @_Error             = 0;
SET @_FunctionName      = OBJECT_NAME(@@PROCID);
SET @_Severity          = @SEVERITY_INFORMATION;
SET @_SprocStartTime    = sysdatetimeoffset();
SET @_ProgressText      = '' 
SET @_JournalOnOff      = log4.GetJournalControl(@_FunctionName, 'HOWTO');  -- left Group Name as HOWTO for now.

-- set the Parameters for logging:
SET @_ProgressText		= @_FunctionName + ' starting at ' + CONVERT(char(23), @_SprocStartTime, 121) + ' with inputs: '
						+ @NEW_LINE + '    @vault_config_table           : ' + COALESCE(@vault_config_table, '<NULL>')
						+ @NEW_LINE + '    @vault_config_table_key       : ' + COALESCE(cast(@vault_config_table_key as varchar(20)), '<NULL>')
						+ @NEW_LINE + '    @vault_old_release            : ' + COALESCE(cast(@vault_old_release as varchar(20)), '<NULL>')
						+ @NEW_LINE + '    @vault_new_release            : ' + COALESCE(cast(@vault_new_release as varchar(20)), '<NULL>')
						+ @NEW_LINE + '    @DoGenerateError              : ' + COALESCE(CAST(@DoGenerateError AS varchar), '<NULL>')
						+ @NEW_LINE + '    @DoThrowError                 : ' + COALESCE(CAST(@DoThrowError AS varchar), '<NULL>')
						+ @NEW_LINE

BEGIN TRY
SET @_Step = 'Generate any required error';
IF @DoGenerateError = 1
   select 1 / 0
SET @_Step = 'Validate inputs';

DECLARE @IncludeTables table(dv_schema_name sysname, dv_table_name sysname, dv_key_name sysname)
insert @IncludeTables 
SELECT dv_schema_name	
      ,dv_table_name	
	  ,dv_key_name
FROM [dv_release].[fn_config_table_list] ()

IF (select count(*) from @IncludeTables where dv_table_name = @vault_config_table) <> 1
			RAISERROR('Invalid Config Table Name Selected: %s', 16, 1, @vault_config_table);

select @old_release_key = [release_key] from [dv_release].[dv_release_master] where [release_number] = @vault_old_release
if @@rowcount <> 1 RAISERROR('Invalid Old Release Number Selected: %i', 16, 1, @vault_old_release)
select @new_release_key = [release_key] from [dv_release].[dv_release_master] where [release_number] = @vault_new_release
if @@rowcount <> 1 RAISERROR('Invalid New Release Number Selected: %i', 16, 1, @vault_new_release)
/*--------------------------------------------------------------------------------------------------------------*/
SET @_Step = 'Get Required Parameters'

select @vault_config_table_key_name = dv_key_name
      ,@vault_config_table_schema_name = dv_schema_name 
from @IncludeTables where dv_table_name = @vault_config_table
set @SQL = 'UPDATE #config_table_schema#.#config_table# SET [release_key] = #new_release_key# WHERE [release_key] = #old_release_key# and #vault_config_table_key_name# = #vault_config_table_key#'
set @SQL = replace(@SQL, '#config_table_schema#', quotename(@vault_config_table_schema_name))
set @SQL = replace(@SQL, '#config_table#', quotename(@vault_config_table))
set @SQL = replace(@SQL, '#new_release_key#', format(@new_release_key, '000000000'))
set @SQL = replace(@SQL, '#old_release_key#', format(@old_release_key, '000000000'))
set @SQL = replace(@SQL, '#vault_config_table_key_name#', @vault_config_table_key_name)
set @SQL = replace(@SQL, '#vault_config_table_key#', format(@vault_config_table_key, '000000000'))
/*--------------------------------------------------------------------------------------------------------------*/
SET @_Step = 'Move the Object to the New Release'
--print @SQL
exec (@SQL)
/*--------------------------------------------------------------------------------------------------------------*/

SET @_ProgressText  = @_ProgressText + @NEW_LINE
				+ 'Step: [' + @_Step + '] completed ' 

IF @@TRANCOUNT > 0 COMMIT TRAN;

SET @_Message   = 'Successfully Moved ' + @vault_config_table + '(' +  format(@vault_config_table_key, '00000000') + ')' 

END TRY
BEGIN CATCH
SET @_ErrorContext	= 'Failed to Move ' + @vault_config_table + '(' +  format(@vault_config_table_key, '00000000') + ')'
IF (XACT_STATE() = -1) -- uncommitable transaction
OR (@@TRANCOUNT > 0 AND XACT_STATE() != 1) -- undocumented uncommitable transaction
	BEGIN
		ROLLBACK TRAN;
		SET @_ErrorContext = @_ErrorContext + ' (Forced rolled back of all changes)';
	END
	
EXEC log4.ExceptionHandler
		  @ErrorContext  = @_ErrorContext
		, @ErrorNumber   = @_Error OUT
		, @ReturnMessage = @_Message OUT
		, @ExceptionId   = @_ExceptionId OUT
;
END CATCH

--/////////////////////////////////////////////////////////////////////////////////////////////////
OnComplete:
--/////////////////////////////////////////////////////////////////////////////////////////////////

	--! Clean up

	--!
	--! Use dbo.udf_FormatElapsedTime() to get a nicely formatted run time string e.g.
	--! "0 hr(s) 1 min(s) and 22 sec(s)" or "1345 milliseconds"
	--!
	IF @_Error = 0
		BEGIN
			SET @_Step			= 'OnComplete'
			SET @_Severity		= @SEVERITY_SUCCESS
			SET @_Message		= COALESCE(@_Message, @_Step)
								+ ' in a total run time of ' + log4.FormatElapsedTime(@_SprocStartTime, NULL, 3)
			SET @_ProgressText  = @_ProgressText + @NEW_LINE + @_Message;
		END
	ELSE
		BEGIN
			SET @_Step			= COALESCE(@_Step, 'OnError')
			SET @_Severity		= @SEVERITY_SEVERE
			SET @_Message		= COALESCE(@_Message, @_Step)
								+ ' after a total run time of ' + log4.FormatElapsedTime(@_SprocStartTime, NULL, 3)
			SET @_ProgressText  = @_ProgressText + @NEW_LINE + @_Message;
		END

	IF @_JournalOnOff = 'ON'
		EXEC log4.JournalWriter
				  @Task				= @_FunctionName
				, @FunctionName		= @_FunctionName
				, @StepInFunction	= @_Step
				, @MessageText		= @_Message
				, @Severity			= @_Severity
				, @ExceptionId		= @_ExceptionId
				--! Supply all the progress info after we've gone to such trouble to collect it
				, @ExtraInfo        = @_ProgressText

	--! Finally, throw an exception that will be detected by the caller
	IF @DoThrowError = 1 AND @_Error > 0
		RAISERROR(@_Message, 16, 99);

	SET NOCOUNT OFF;

	--! Return the value of @@ERROR (which will be zero on success)
	RETURN (@_Error);
END
GO
PRINT N'Creating [dv_release].[dv_apply_release_config]...';


GO
CREATE PROCEDURE [dv_release].[dv_apply_release_config]
(
  @vault_release_number			int			 = NULL
, @DoGenerateError              bit          = 0
, @DoThrowError                 bit			 = 1
)

AS
BEGIN
SET NOCOUNT ON

-- Internal use variables

DECLARE
    @vault_statement		nvarchar(max),
	@vault_change_count		int,
	@release_key			int,
	@release_number			int,
	@change_count			int = 0,
	@currtable				SYSNAME,
	@currschema				SYSNAME,
	@dv_schema_name			sysname,
	@dv_table_name			sysname,
    @parm_definition		nvarchar(500),
	@rc						int	

-- Log4TSQL Journal Constants 
DECLARE @SEVERITY_CRITICAL      smallint = 1;
DECLARE @SEVERITY_SEVERE        smallint = 2;
DECLARE @SEVERITY_MAJOR         smallint = 4;
DECLARE @SEVERITY_MODERATE      smallint = 8;
DECLARE @SEVERITY_MINOR         smallint = 16;
DECLARE @SEVERITY_CONCURRENCY   smallint = 32;
DECLARE @SEVERITY_INFORMATION   smallint = 256;
DECLARE @SEVERITY_SUCCESS       smallint = 512;
DECLARE @SEVERITY_DEBUG         smallint = 1024;
DECLARE @NEW_LINE               char(1)  = CHAR(10);

-- Log4TSQL Standard/ExceptionHandler variables
DECLARE	  @_Error         int
		, @_RowCount      int
		, @_Step          varchar(128)
		, @_Message       nvarchar(512)
		, @_ErrorContext  nvarchar(512)

-- Log4TSQL JournalWriter variables
DECLARE   @_FunctionName			varchar(255)
		, @_SprocStartTime			datetime
		, @_JournalOnOff			varchar(3)
		, @_Severity				smallint
		, @_ExceptionId				int
		, @_StepStartTime			datetime
		, @_ProgressText			nvarchar(max)

SET @_Error             = 0;
SET @_FunctionName      = OBJECT_NAME(@@PROCID);
SET @_Severity          = @SEVERITY_INFORMATION;
SET @_SprocStartTime    = sysdatetimeoffset();
SET @_ProgressText      = '' 
SET @_JournalOnOff      = log4.GetJournalControl(@_FunctionName, 'HOWTO');  -- left Group Name as HOWTO for now.
			
	
--set the Parameters for logging:
SET @_ProgressText		= @_FunctionName + ' starting at ' + CONVERT(char(23), @_SprocStartTime, 121) + ' with inputs: '
						+ @NEW_LINE + '    @vault_release_number         : ' + COALESCE(cast(@vault_release_number as varchar(20)), '<NULL>')
						+ @NEW_LINE + '    @DoGenerateError              : ' + COALESCE(CAST(@DoGenerateError AS varchar), '<NULL>')
						+ @NEW_LINE + '    @DoThrowError                 : ' + COALESCE(CAST(@DoThrowError AS varchar), '<NULL>')
						+ @NEW_LINE

BEGIN TRY
SET @_Step = 'Generate any required error';
IF @DoGenerateError = 1
   select 1 / 0
SET @_Step = 'Validate Inputs';

SET @_Step = 'Initialise Variables';

SET @_Step = 'Initialise Release';

select @vault_statement = [release_statement]
from [dv_release].[dv_release_build] 
where [release_number] = @vault_release_number
and [release_statement_type] = 'Header'

/*********************************************************************************************************************/
BEGIN TRANSACTION

set @parm_definition = N'@result int OUTPUT';
exec sp_executesql @vault_statement, @parm_definition, @result=@rc OUTPUT;
if isnull(@rc, 0) <> 1
	RAISERROR('Expected a Single Change to the Release Header. Received %i for Statement: %s', 16, 1, @rc, @vault_statement)

select @release_key = release_key from [dv_release].[dv_release_master] where release_number = @vault_release_number


update [dv_release].[dv_release_master]
set [release_start_datetime] = SYSDATETIMEOFFSET()
where [release_key] = @release_key

-- Extract the Changes per Table
DECLARE dv_table_cursor CURSOR FOR  
SELECT [release_statement], [affected_row_count]
FROM [dv_release].[dv_release_build]
where 1=1
and [release_build_key] = @release_key
and [release_statement_type] = 'Table'
order by [release_statement_sequence]

OPEN dv_table_cursor
FETCH NEXT FROM dv_table_cursor INTO @vault_statement, @change_count

WHILE @@FETCH_STATUS = 0   
BEGIN   
      --print @vault_statement
	  exec sp_executesql @vault_statement, @parm_definition, @result=@rc OUTPUT;
	  if @rc <> @change_count
			RAISERROR('Expected %i changes, Received %i for Statement: %s', 16, 1, @change_count, @rc, @vault_statement)
	  FETCH NEXT FROM dv_table_cursor INTO @vault_statement, @change_count   
END   

CLOSE dv_table_cursor   
DEALLOCATE dv_table_cursor

update [dv_release].[dv_release_master]
	set [release_complete_datetime] = SYSDATETIMEOFFSET(),
        [release_count] = isnull([release_count], 0) + 1
where [release_key] = @release_key
COMMIT

/*--------------------------------------------------------------------------------------------------------------*/
IF @@TRANCOUNT > 0 COMMIT TRAN;

SET @_Message   = 'Successfully Applied Release: ' + cast(@vault_release_number as varchar(20))

END TRY
BEGIN CATCH
SET @_ErrorContext	= 'Failed to Apply Release: ' + cast(@vault_release_number as varchar(20)) 
IF (XACT_STATE() = -1) -- uncommitable transaction
OR (@@TRANCOUNT > 0 AND XACT_STATE() != 1) -- undocumented uncommitable transaction
	BEGIN
		ROLLBACK TRAN;
		SET @_ErrorContext = @_ErrorContext + ' (Forced rolled back of all changes)';
	END
	
EXEC log4.ExceptionHandler
		  @ErrorContext  = @_ErrorContext
		, @ErrorNumber   = @_Error OUT
		, @ReturnMessage = @_Message OUT
		, @ExceptionId   = @_ExceptionId OUT
;
END CATCH

--/////////////////////////////////////////////////////////////////////////////////////////////////
OnComplete:
--/////////////////////////////////////////////////////////////////////////////////////////////////

	--! Clean up

	--!
	--! Use dbo.udf_FormatElapsedTime() to get a nicely formatted run time string e.g.
	--! "0 hr(s) 1 min(s) and 22 sec(s)" or "1345 milliseconds"
	--!
	IF @_Error = 0
		BEGIN
			SET @_Step			= 'OnComplete'
			SET @_Severity		= @SEVERITY_SUCCESS
			SET @_Message		= COALESCE(@_Message, @_Step)
								+ ' in a total run time of ' + log4.FormatElapsedTime(@_SprocStartTime, NULL, 3)
			SET @_ProgressText  = @_ProgressText + @NEW_LINE + @_Message;
		END
	ELSE
		BEGIN
			SET @_Step			= COALESCE(@_Step, 'OnError')
			SET @_Severity		= @SEVERITY_SEVERE
			SET @_Message		= COALESCE(@_Message, @_Step)
								+ ' after a total run time of ' + log4.FormatElapsedTime(@_SprocStartTime, NULL, 3)
			SET @_ProgressText  = @_ProgressText + @NEW_LINE + @_Message;
		END

	IF @_JournalOnOff = 'ON'
		EXEC log4.JournalWriter
				  @Task				= @_FunctionName
				, @FunctionName		= @_FunctionName
				, @StepInFunction	= @_Step
				, @MessageText		= @_Message
				, @Severity			= @_Severity
				, @ExceptionId		= @_ExceptionId
				--! Supply all the progress info after we've gone to such trouble to collect it
				, @ExtraInfo        = @_ProgressText

	--! Finally, throw an exception that will be detected by the caller
	IF @DoThrowError = 1 AND @_Error > 0
		RAISERROR(@_Message, 16, 99);

	SET NOCOUNT OFF;

	--! Return the value of @@ERROR (which will be zero on success)
	RETURN (@_Error);
END
GO
PRINT N'Creating [dv_release].[dv_build_release_config_table]...';


GO
CREATE PROCEDURE [dv_release].[dv_build_release_config_table]
(
  @vault_config_table_schema	varchar(128)	= NULL
, @vault_config_table_name		varchar(128)	= NULL
, @vault_release_number			int				= NULL
, @vault_exclude_columnsCSV		nvarchar(4000)	= null
, @vault_statement				nvarchar(max)	output
, @vault_change_count			int				output
, @DoGenerateError              bit				= 0
, @DoThrowError                 bit				= 1
)

AS
BEGIN
SET NOCOUNT ON

/*========================================================================================================================
Description:	This script generates a MERGE statement for the table provided, for a chosen Release Number, using the rows currently in the table.
				The MERGE statement is in a table variable.
Reference:		Based on code published by Eitan Blumin, Madeira SQL Server Services (http://www.madeira.co.il/generate-merge-statements-for-your-tables/)

Notes:			Tables without a primary key are not supported.
				Columns of the image data type may show conversion errors. This has yet to be resolved.
				This script can be used in test environments to capture a snapshot of a table before a test is performed,
				which changes the data in the table. Once the test is completed, the MERGE statement can be executed
				in order to bring the table back to its state before the test.
=========================================================================================================================*/

-- Internal use variables
DECLARE @ExcludeColumns table(column_name sysname)
insert @ExcludeColumns values ('version_number'), ('updated_by') ,('update_date_time')
if isnull(@vault_exclude_columnsCSV, '') <> ''
	insert @ExcludeColumns SELECT * FROM [dbo].[fn_split_strings] (@vault_exclude_columnsCSV, ',')

DECLARE
	@delete_unmatched_rows	BIT = 0,	-- enable/disable DELETION of rows
	@debug_mode				BIT = 0,	-- enable/disable debug mode
	@include_timestamp		BIT = 0,	-- include timestamp columns or not
	@omit_computed_cols		BIT = 1,	-- omit computed columns or not (in case target table doesn't have computed columns)
	@top_clause				NVARCHAR(4000)	= N'TOP 100 PERCENT' , -- you can use this to limit number of generated rows (e.g. TOP 200)
	@MergeStmnt				NVARCHAR(MAX),	
	@CurrColumnId			INT,
	@CurrColumnName			SYSNAME,
	@CurrColumnType			VARCHAR(1000),
	@ColumnList				NVARCHAR(MAX),
	@UpdateSet				NVARCHAR(MAX),
	@PKJoinClause			NVARCHAR(MAX),
	@HasIdentity			BIT,
	@GetValues				NVARCHAR(MAX),
	@Values					NVARCHAR(MAX),
	@release_key			int,
	@change_count			int = 0,
	@currtable				SYSNAME,
	@currschema				SYSNAME,
	@release_number			int

-- Log4TSQL Journal Constants 
DECLARE @SEVERITY_CRITICAL      smallint = 1;
DECLARE @SEVERITY_SEVERE        smallint = 2;
DECLARE @SEVERITY_MAJOR         smallint = 4;
DECLARE @SEVERITY_MODERATE      smallint = 8;
DECLARE @SEVERITY_MINOR         smallint = 16;
DECLARE @SEVERITY_CONCURRENCY   smallint = 32;
DECLARE @SEVERITY_INFORMATION   smallint = 256;
DECLARE @SEVERITY_SUCCESS       smallint = 512;
DECLARE @SEVERITY_DEBUG         smallint = 1024;
DECLARE @NEW_LINE               char(1)  = CHAR(10);

-- Log4TSQL Standard/ExceptionHandler variables
DECLARE	  @_Error         int
		, @_RowCount      int
		, @_Step          varchar(128)
		, @_Message       nvarchar(512)
		, @_ErrorContext  nvarchar(512)

-- Log4TSQL JournalWriter variables
DECLARE   @_FunctionName			varchar(255)
		, @_SprocStartTime			datetime
		, @_JournalOnOff			varchar(3)
		, @_Severity				smallint
		, @_ExceptionId				int
		, @_StepStartTime			datetime
		, @_ProgressText			nvarchar(max)

SET @_Error             = 0;
SET @_FunctionName      = OBJECT_NAME(@@PROCID);
SET @_Severity          = @SEVERITY_INFORMATION;
SET @_SprocStartTime    = sysdatetimeoffset();
SET @_ProgressText      = '' 
SET @_JournalOnOff      = log4.GetJournalControl(@_FunctionName, 'HOWTO');  -- left Group Name as HOWTO for now.

-- set the Parameters for logging:
SET @_ProgressText		= @_FunctionName + ' starting at ' + CONVERT(char(23), @_SprocStartTime, 121) + ' with inputs: '
						+ @NEW_LINE + '    @vault_config_table_schema    : ' + COALESCE(@vault_config_table_schema, '<NULL>')
						+ @NEW_LINE + '    @vault_config_table_name      : ' + COALESCE(@vault_config_table_name, '<NULL>')
						+ @NEW_LINE + '    @vault_release_number         : ' + COALESCE(cast(@vault_release_number as varchar(20)), '<NULL>')
						+ @NEW_LINE + '    @DoGenerateError              : ' + COALESCE(CAST(@DoGenerateError AS varchar), '<NULL>')
						+ @NEW_LINE + '    @DoThrowError                 : ' + COALESCE(CAST(@DoThrowError AS varchar), '<NULL>')
						+ @NEW_LINE

BEGIN TRY
SET @_Step = 'Generate any required error';
IF @DoGenerateError = 1
   select 1 / 0
SET @_Step = 'Validate Inputs';

SET @_Step = 'Initialise Variables';

SELECT
	@CurrColumnId	= NULL,
	@CurrColumnName = NULL,
	@CurrColumnType = NULL,
	@MergeStmnt		= NULL,
	@ColumnList		= NULL,
	@UpdateSet		= NULL,
	@PKJoinClause	= NULL,
	@GetValues		= NULL,
	@Values			= NULL,
	@HasIdentity	= 0

SELECT
    @currtable		=	@vault_config_table_name,
	@currschema		=	@vault_config_table_schema,
	@release_number	=	@vault_release_number 
			
SET @_Step = 'Get Release Header';
select @release_key = release_key from [dv_release].[dv_release_master] where release_number = @release_number

-- Find the table's Primary Key column(s) to build a JOIN clause

SELECT 
	@PKJoinClause = ISNULL(@PKJoinClause + N'
AND ',N'') + 'trgt.' + QUOTENAME(col.name) + N' = src.' + QUOTENAME(col.name)
FROM
	sys.indexes AS ind
INNER JOIN 
	sys.index_columns AS indcol
ON
	ind.object_id = indcol.object_id
AND ind.index_id = indcol.index_id
INNER JOIN
	sys.columns AS col
ON
	ind.object_id = col.object_id
AND indcol.column_id = col.column_id
WHERE 
	ind.is_primary_key = 1
AND ind.object_id = OBJECT_ID(QUOTENAME(@CurrSchema) + '.' + QUOTENAME(@CurrTable))

IF @debug_mode = 1
	PRINT 'PK Join Clause:
' + @PKJoinClause


-- If nothing found, abort (table is not supported)

IF @PKJoinClause IS NULL
BEGIN
	RAISERROR(N'ERROR: Table %s is not supported because it''s missing a Primary Key.', 16, 1, @CurrTable) WITH NOWAIT;
	GOTO Quit;
END


SET @_Step = 'Get the first column ID'

SELECT
	@CurrColumnId = MIN(ORDINAL_POSITION) 	
FROM
	INFORMATION_SCHEMA.COLUMNS (NOLOCK) 
WHERE
	TABLE_NAME = @CurrTable
AND TABLE_SCHEMA = @CurrSchema


SET @_Step = 'Loop through all the columns'

WHILE @CurrColumnId IS NOT NULL
BEGIN
	SELECT
		@CurrColumnName = QUOTENAME(COLUMN_NAME), 
		@CurrColumnType = DATA_TYPE 
	FROM
		INFORMATION_SCHEMA.COLUMNS (NOLOCK) 
	WHERE
		ORDINAL_POSITION = @CurrColumnId
	AND TABLE_NAME = @CurrTable
	AND TABLE_SCHEMA = @CurrSchema
	

	IF @debug_mode = 1
		PRINT 'Processing column ' + @CurrColumnName

	
	-- Making sure whether to output computed columns or not
IF @CurrColumnName IN (SELECT QUOTENAME(column_name) from @ExcludeColumns)
	BEGIN
		GOTO SKIP_COLUMN
	END

IF @omit_computed_cols = 1
	BEGIN
		IF (SELECT COLUMNPROPERTY( OBJECT_ID(QUOTENAME(@CurrSchema) + '.' + @CurrTable),SUBSTRING(@CurrColumnName,2,LEN(@CurrColumnName) - 2),'IsComputed')) = 1 
		BEGIN
			GOTO SKIP_COLUMN					
		END
	END
	

	-- Concatenate column value selection to the values list

SET @GetValues = ISNULL( @GetValues + ' + '',''' , '''(''' ) + ' + ' +
	CASE
		-- Format column value retrieval based on its data type
		WHEN @CurrColumnType IN ('text','char','varchar') 
			THEN 
				'COALESCE('''''''' + REPLACE(CONVERT(nvarchar(max),' + @CurrColumnName + '),'''''''','''''''''''')+'''''''',''NULL'')'					
		WHEN @CurrColumnType IN ('ntext','nchar','nvarchar','xml') 
			THEN  
				'COALESCE(''N'''''' + REPLACE(CONVERT(nvarchar(max),' + @CurrColumnName + '),'''''''','''''''''''')+'''''''',''NULL'')'					
		WHEN @CurrColumnType LIKE '%date%'
			THEN 
				'COALESCE('''''''' + RTRIM(CONVERT(varchar(max),' + @CurrColumnName + ',109))+'''''''',''NULL'')'
		WHEN @CurrColumnType IN ('uniqueidentifier') 
			THEN  
				'COALESCE('''''''' + REPLACE(CONVERT(varchar(255),RTRIM(' + @CurrColumnName + ')),'''''''','''''''''''')+'''''''',''NULL'')'
		WHEN @CurrColumnType IN ('binary','varbinary','image') 
			THEN  
				'COALESCE(RTRIM(CONVERT(nvarchar(max),' + @CurrColumnName + ',1)),''NULL'')'  
		WHEN @CurrColumnType IN ('timestamp','rowversion') 
			THEN  
				CASE 
					WHEN @include_timestamp = 0 
						THEN 
							'''DEFAULT''' 
						ELSE 
							'COALESCE(RTRIM(CONVERT(varchar(max),' + 'CONVERT(int,' + @CurrColumnName + '))),''NULL'')'  
				END
		WHEN @CurrColumnType IN ('float','real','money','smallmoney')
			THEN
				'COALESCE(LTRIM(RTRIM(' + 'CONVERT(varchar(max), ' +  @CurrColumnName  + ',2)' + ')),''NULL'')' 
		ELSE 
			'COALESCE(LTRIM(RTRIM(' + 'CONVERT(varchar(max), ' +  @CurrColumnName  + ')' + ')),''NULL'')' 
	END
	

	-- Concatenate column name to column list

	SET @ColumnList = ISNULL(@ColumnList + N',',N'') + @CurrColumnName


	-- Make sure to output SET IDENTITY_INSERT ON/OFF in case the table has an IDENTITY column

	IF (SELECT COLUMNPROPERTY( OBJECT_ID(QUOTENAME(@CurrSchema) + '.' + @CurrTable),SUBSTRING(@CurrColumnName,2,LEN(@CurrColumnName) - 2),'IsIdentity')) = 1 
	BEGIN
		SET @HasIdentity = 1		
	END
	ELSE
	BEGIN
		-- If column is not IDENTITY, concatenate it to UPDATE SET clause
		SET @UpdateSet = ISNULL(@UpdateSet + N'
		, ', N'') + @CurrColumnName + N' = src.' + @CurrColumnName
	END

	
	SKIP_COLUMN: -- The label used in GOTO to skip column


	-- Get next column in order

	SELECT
		@CurrColumnId = MIN(ORDINAL_POSITION) 
	FROM
		INFORMATION_SCHEMA.COLUMNS (NOLOCK) 
	WHERE 	
		ORDINAL_POSITION > @CurrColumnId
	AND TABLE_NAME = @CurrTable
	AND TABLE_SCHEMA = @CurrSchema


-- Column loop ends here

END


SET @_Step = 'Finalise VALUES constructor'

SET @GetValues = @GetValues + ' + '')'' ';

IF @debug_mode = 1
	PRINT 'Values Retrieval:
' + @GetValues + '

';


-- Using everything we found above, save all the table records as a values constructor (using dynamic SQL)

DECLARE @Params NVARCHAR(MAX)
DECLARE @CMD NVARCHAR(MAX);

SET @Params = N'@Result NVARCHAR(MAX) OUTPUT'
SET @CMD = 'SELECT ' + @top_clause + N' 
	@Result = ISNULL(@Result + '',
		'','''') + ' + @GetValues + ' FROM ' + QUOTENAME(@CurrSchema) + '.' + QUOTENAME(@CurrTable) + 
		' WHERE release_key = ' + cast(@release_key as varchar(20))

IF @debug_mode = 1
	SELECT @CMD;

-- Execute command and get the @Values parameter as output

EXECUTE sp_executesql @CMD, @Params, @Values OUTPUT
select @change_count = @@rowcount

SET @_Step = 'If table returned no rows'

IF @change_count = 0 OR @Values IS NULL
BEGIN
	-- If deletion is enabled

	IF @delete_unmatched_rows = 1

		-- Generate a DELETE statement
		SET @MergeStmnt = N'DELETE FROM ' + QUOTENAME(@CurrSchema) + N'.' + QUOTENAME(@CurrTable)
	ELSE

		-- Otherwise, generate an empty script
		SET @MergeStmnt = N''
END
ELSE

SET @_Step = 'Build the MERGE statement'

BEGIN

	-- Use IDENTITY_INSERT if table has an identity column

	IF @HasIdentity = 1
		SET @MergeStmnt = 'SET IDENTITY_INSERT ' + QUOTENAME(@CurrSchema) + '.' + QUOTENAME(@CurrTable) + ' ON;'
	ELSE
		SET @MergeStmnt = N''

	-- Build the MERGE statement using all the parts we found

	SET @MergeStmnt = @MergeStmnt + N' MERGE INTO ' + QUOTENAME(@CurrSchema) + N'.' + QUOTENAME(@CurrTable) + N' AS trgt ' +
	'USING	(VALUES ' + @Values + N'
			) AS src(' + @ColumnList + N')
	ON
		' + @PKJoinClause + N'
	WHEN MATCHED THEN
		UPDATE SET
			' + @UpdateSet + N'
	WHEN NOT MATCHED BY TARGET THEN
		INSERT (' + @ColumnList + N')
		VALUES (' + @ColumnList + N')
	' + CASE WHEN @delete_unmatched_rows = 1 THEN -- optional
	N'WHEN NOT MATCHED BY SOURCE THEN
		DELETE' ELSE N'' END + N'
	;
	';
	
    -- Get the Rowcount
	SET @MergeStmnt = @MergeStmnt + ' select @result = @@rowcount; '
	-- Use IDENTITY_INSERT if table has an identity column

	IF @HasIdentity = 1
		SET @MergeStmnt = @MergeStmnt + 'SET IDENTITY_INSERT ' + QUOTENAME(@CurrSchema) + '.' + QUOTENAME(@CurrTable) + ' OFF;'

END


Quit:


SET @_Step = 'Output the final statement'

SELECT @vault_statement		= @MergeStmnt
      ,@vault_change_count	= @change_count
/*--------------------------------------------------------------------------------------------------------------*/
IF @@TRANCOUNT > 0 COMMIT TRAN;

SET @_Message   = 'Successfully Created Release for: ' + quotename(@vault_config_table_schema) + '.' + quotename(@vault_config_table_name) + '('+ cast(@vault_release_number as varchar(20)) + ')'

END TRY
BEGIN CATCH
SET @_ErrorContext	= 'Failed to Create Release for: ' + quotename(@vault_config_table_schema) + '.' + quotename(@vault_config_table_name) + '('+ cast(@vault_release_number as varchar(20)) + ')'
IF (XACT_STATE() = -1) -- uncommitable transaction
OR (@@TRANCOUNT > 0 AND XACT_STATE() != 1) -- undocumented uncommitable transaction
	BEGIN
		ROLLBACK TRAN;
		SET @_ErrorContext = @_ErrorContext + ' (Forced rolled back of all changes)';
	END
	
EXEC log4.ExceptionHandler
		  @ErrorContext  = @_ErrorContext
		, @ErrorNumber   = @_Error OUT
		, @ReturnMessage = @_Message OUT
		, @ExceptionId   = @_ExceptionId OUT
;
END CATCH

--/////////////////////////////////////////////////////////////////////////////////////////////////
OnComplete:
--/////////////////////////////////////////////////////////////////////////////////////////////////

	--! Clean up

	--!
	--! Use dbo.udf_FormatElapsedTime() to get a nicely formatted run time string e.g.
	--! "0 hr(s) 1 min(s) and 22 sec(s)" or "1345 milliseconds"
	--!
	IF @_Error = 0
		BEGIN
			SET @_Step			= 'OnComplete'
			SET @_Severity		= @SEVERITY_SUCCESS
			SET @_Message		= COALESCE(@_Message, @_Step)
								+ ' in a total run time of ' + log4.FormatElapsedTime(@_SprocStartTime, NULL, 3)
			SET @_ProgressText  = @_ProgressText + @NEW_LINE + @_Message;
		END
	ELSE
		BEGIN
			SET @_Step			= COALESCE(@_Step, 'OnError')
			SET @_Severity		= @SEVERITY_SEVERE
			SET @_Message		= COALESCE(@_Message, @_Step)
								+ ' after a total run time of ' + log4.FormatElapsedTime(@_SprocStartTime, NULL, 3)
			SET @_ProgressText  = @_ProgressText + @NEW_LINE + @_Message;
		END

	IF @_JournalOnOff = 'ON'
		EXEC log4.JournalWriter
				  @Task				= @_FunctionName
				, @FunctionName		= @_FunctionName
				, @StepInFunction	= @_Step
				, @MessageText		= @_Message
				, @Severity			= @_Severity
				, @ExceptionId		= @_ExceptionId
				--! Supply all the progress info after we've gone to such trouble to collect it
				, @ExtraInfo        = @_ProgressText

	--! Finally, throw an exception that will be detected by the caller
	IF @DoThrowError = 1 AND @_Error > 0
		RAISERROR(@_Message, 16, 99);

	SET NOCOUNT OFF;

	--! Return the value of @@ERROR (which will be zero on success)
	RETURN (@_Error);
END
GO
PRINT N'Creating [dv_release].[dv_import_release_file]...';


GO
CREATE PROCEDURE [dv_release].[dv_import_release_file] 
(
  @vault_file_location			varchar(256)	=''
, @vault_file_name				varchar(256)	=''
, @DoGenerateError              bit				= 0
, @DoThrowError                 bit				= 1
)
AS
BEGIN
SET NOCOUNT ON
-- Internal use variables
declare @xml xml
       ,@sql					nvarchar(max) = ''
	   ,@parmdefinition			nvarchar(500)
	   ,@release_build_key		int
	   ,@temp_table_name		varchar(256)
	   ,@full_file_name			varchar(256)

-- Log4TSQL Journal Constants 
DECLARE @SEVERITY_CRITICAL      smallint = 1;
DECLARE @SEVERITY_SEVERE        smallint = 2;
DECLARE @SEVERITY_MAJOR         smallint = 4;
DECLARE @SEVERITY_MODERATE      smallint = 8;
DECLARE @SEVERITY_MINOR         smallint = 16;
DECLARE @SEVERITY_CONCURRENCY   smallint = 32;
DECLARE @SEVERITY_INFORMATION   smallint = 256;
DECLARE @SEVERITY_SUCCESS       smallint = 512;
DECLARE @SEVERITY_DEBUG         smallint = 1024;
DECLARE @NEW_LINE               char(1)  = CHAR(10);

-- Log4TSQL Standard/ExceptionHandler variables
DECLARE	  @_Error         int
		, @_RowCount      int
		, @_Step          varchar(128)
		, @_Message       nvarchar(512)
		, @_ErrorContext  nvarchar(512)

-- Log4TSQL JournalWriter variables
DECLARE   @_FunctionName			varchar(255)
		, @_SprocStartTime			datetime
		, @_JournalOnOff			varchar(3)
		, @_Severity				smallint
		, @_ExceptionId				int
		, @_StepStartTime			datetime
		, @_ProgressText			nvarchar(max)

SET @_Error             = 0;
SET @_FunctionName      = OBJECT_NAME(@@PROCID);
SET @_Severity          = @SEVERITY_INFORMATION;
SET @_SprocStartTime    = sysdatetimeoffset();
SET @_ProgressText      = '' 
SET @_JournalOnOff      = log4.GetJournalControl(@_FunctionName, 'HOWTO');  -- left Group Name as HOWTO for now.
		
-- set the Parameters for logging:
SET @_ProgressText		= @_FunctionName + ' starting at ' + CONVERT(char(23), @_SprocStartTime, 121) + ' with inputs: '
						+ @NEW_LINE + '    @vault_file_location			 : ' + COALESCE(@vault_file_location, '<NULL>')
						+ @NEW_LINE + '    @vault_file_name		         : ' + COALESCE(cast(@vault_file_name as varchar(20)), '<NULL>')
						+ @NEW_LINE + '    @DoGenerateError              : ' + COALESCE(CAST(@DoGenerateError AS varchar), '<NULL>')
						+ @NEW_LINE + '    @DoThrowError                 : ' + COALESCE(CAST(@DoThrowError AS varchar), '<NULL>')
						+ @NEW_LINE

BEGIN TRY
SET @_Step = 'Generate any required error';
IF @DoGenerateError = 1
   select 1 / 0
SET @_Step = 'Validate Inputs';

SET @_Step = 'Initialise Variables';

if isnull(@vault_file_location, '') = ''
	set @vault_file_location = 'C:\bcp\'

set @full_file_name = @vault_file_location + '\' + @vault_file_name		
set @full_file_name = replace (@full_file_name, '\\', '\')
-- Create Temp Table Name
select @temp_table_name = '##temp_001_' + replace(cast(newid() as varchar(50)), '-', '')
-- Build a Global Temp Table
set @sql = 'create table #table_name# (XmlCol xml)'
set @sql = replace (@sql, '#table_name#', @temp_table_name)
exec(@sql)
--Load the File into the Golbal Temp Table
set @sql = 'INSERT INTO #temp_table_name#(XmlCol) SELECT * FROM OPENROWSET(BULK ''#filename#'',SINGLE_CLOB) AS x;' 
set @sql = replace(@sql, '#temp_table_name#', @temp_table_name)
set @sql = replace(@sql, '#filename#', @full_file_name)
exec(@sql)
-- return the Build as an XML variable
SET @parmdefinition = N'@XMLData xml OUTPUT'
set @sql = 'select @XMLData = XmlCol from #temp_table_name#'
set @sql = replace(@sql, '#temp_table_name#', @temp_table_name)
EXECUTE sp_executesql @sql, @ParmDefinition, @XMLData = @xml OUTPUT;
--Clear the release out of the master file
SELECT @release_build_key = Tbl.Col.value('release_build_key[1]', 'varchar(4000)') 
FROM   @xml.nodes('//statement') Tbl(Col)
select @release_build_key
delete from [dv_release].[dv_release_build] where release_build_key = @release_build_key
--Import the release into the Build Table, Ready to apply
insert [dv_release].[dv_release_build]
   SELECT  
       Tbl.Col.value('release_build_key[1]', 'varchar(4000)') as release_build_key, 
	   Tbl.Col.value('release_statement_sequence[1]', 'varchar(4000)') as release_statement_sequence, 
	   Tbl.Col.value('release_number[1]', 'varchar(4000)') as release_number,
	   Tbl.Col.value('release_statement_type[1]', 'varchar(4000)') as release_statement_type,
	   Tbl.Col.value('release_statement[1]', 'varchar(max)') as release_statement,
	   Tbl.Col.value('affected_row_count[1]', 'varchar(4000)') as affected_row_count
FROM   @xml.nodes('//statement') Tbl(Col) 

/*--------------------------------------------------------------------------------------------------------------*/
IF @@TRANCOUNT > 0 COMMIT TRAN;

SET @_Message   = 'Successfully Imported Release File: ' + @full_file_name

END TRY
BEGIN CATCH
SET @_ErrorContext	= 'Failed to Import Release File: ' + @full_file_name
IF (XACT_STATE() = -1) -- uncommitable transaction
OR (@@TRANCOUNT > 0 AND XACT_STATE() != 1) -- undocumented uncommitable transaction
	BEGIN
		ROLLBACK TRAN;
		SET @_ErrorContext = @_ErrorContext + ' (Forced rolled back of all changes)';
	END
	
EXEC log4.ExceptionHandler
		  @ErrorContext  = @_ErrorContext
		, @ErrorNumber   = @_Error OUT
		, @ReturnMessage = @_Message OUT
		, @ExceptionId   = @_ExceptionId OUT
;
END CATCH

--/////////////////////////////////////////////////////////////////////////////////////////////////
OnComplete:
--/////////////////////////////////////////////////////////////////////////////////////////////////

	--! Clean up

	--!
	--! Use dbo.udf_FormatElapsedTime() to get a nicely formatted run time string e.g.
	--! "0 hr(s) 1 min(s) and 22 sec(s)" or "1345 milliseconds"
	--!
	IF @_Error = 0
		BEGIN
			SET @_Step			= 'OnComplete'
			SET @_Severity		= @SEVERITY_SUCCESS
			SET @_Message		= COALESCE(@_Message, @_Step)
								+ ' in a total run time of ' + log4.FormatElapsedTime(@_SprocStartTime, NULL, 3)
			SET @_ProgressText  = @_ProgressText + @NEW_LINE + @_Message;
		END
	ELSE
		BEGIN
			SET @_Step			= COALESCE(@_Step, 'OnError')
			SET @_Severity		= @SEVERITY_SEVERE
			SET @_Message		= COALESCE(@_Message, @_Step)
								+ ' after a total run time of ' + log4.FormatElapsedTime(@_SprocStartTime, NULL, 3)
			SET @_ProgressText  = @_ProgressText + @NEW_LINE + @_Message;
		END

	IF @_JournalOnOff = 'ON'
		EXEC log4.JournalWriter
				  @Task				= @_FunctionName
				, @FunctionName		= @_FunctionName
				, @StepInFunction	= @_Step
				, @MessageText		= @_Message
				, @Severity			= @_Severity
				, @ExceptionId		= @_ExceptionId
				--! Supply all the progress info after we've gone to such trouble to collect it
				, @ExtraInfo        = @_ProgressText

	--! Finally, throw an exception that will be detected by the caller
	IF @DoThrowError = 1 AND @_Error > 0
		RAISERROR(@_Message, 16, 99);

	SET NOCOUNT OFF;

	--! Return the value of @@ERROR (which will be zero on success)
	RETURN (@_Error);
END
GO
PRINT N'Creating [dv_release].[dv_export_release_file]...';


GO

CREATE PROCEDURE [dv_release].[dv_export_release_file] 
(
  @vault_release_number			int
, @vault_file_location			varchar(256)	=''
, @DoGenerateError              bit				= 0
, @DoThrowError                 bit				= 1
)
AS
BEGIN
SET NOCOUNT ON
-- Internal use variables
declare  @sql							nvarchar(4000)	= ''
	   , @filename						varchar(128)	= ''
	   , @database_name					varchar(128)	= ''

-- Log4TSQL Journal Constants 
DECLARE @SEVERITY_CRITICAL      smallint = 1;
DECLARE @SEVERITY_SEVERE        smallint = 2;
DECLARE @SEVERITY_MAJOR         smallint = 4;
DECLARE @SEVERITY_MODERATE      smallint = 8;
DECLARE @SEVERITY_MINOR         smallint = 16;
DECLARE @SEVERITY_CONCURRENCY   smallint = 32;
DECLARE @SEVERITY_INFORMATION   smallint = 256;
DECLARE @SEVERITY_SUCCESS       smallint = 512;
DECLARE @SEVERITY_DEBUG         smallint = 1024;
DECLARE @NEW_LINE               char(1)  = CHAR(10);

-- Log4TSQL Standard/ExceptionHandler variables
DECLARE	  @_Error         int
		, @_RowCount      int
		, @_Step          varchar(128)
		, @_Message       nvarchar(512)
		, @_ErrorContext  nvarchar(512)

-- Log4TSQL JournalWriter variables
DECLARE   @_FunctionName			varchar(255)
		, @_SprocStartTime			datetime
		, @_JournalOnOff			varchar(3)
		, @_Severity				smallint
		, @_ExceptionId				int
		, @_StepStartTime			datetime
		, @_ProgressText			nvarchar(max)

SET @_Error             = 0;
SET @_FunctionName      = OBJECT_NAME(@@PROCID);
SET @_Severity          = @SEVERITY_INFORMATION;
SET @_SprocStartTime    = sysdatetimeoffset();
SET @_ProgressText      = '' 
SET @_JournalOnOff      = log4.GetJournalControl(@_FunctionName, 'HOWTO');  -- left Group Name as HOWTO for now.

-- set the Parameters for logging:
SET @_ProgressText		= @_FunctionName + ' starting at ' + CONVERT(char(23), @_SprocStartTime, 121) + ' with inputs: '
						+ @NEW_LINE + '    @vault_file_location			 : ' + COALESCE(@vault_file_location, '<NULL>')
						+ @NEW_LINE + '    @vault_release_number         : ' + COALESCE(cast(@vault_release_number as varchar(20)), '<NULL>')
						+ @NEW_LINE + '    @DoGenerateError              : ' + COALESCE(CAST(@DoGenerateError AS varchar), '<NULL>')
						+ @NEW_LINE + '    @DoThrowError                 : ' + COALESCE(CAST(@DoThrowError AS varchar), '<NULL>')
						+ @NEW_LINE

BEGIN TRY
SET @_Step = 'Generate any required error';
IF @DoGenerateError = 1
   select 1 / 0
SET @_Step = 'Validate Inputs';

SET @_Step = 'Initialise Variables';

if isnull(@vault_file_location, '') = ''
	set @vault_file_location = 'C:\bcp'


select @database_name = quotename(db_name())
select @filename = 'DV_Release__' + format(@vault_release_number, '000000') + '__' + format(sysdatetimeoffset(), 'yyyyMMdd_HHmmss')

select @sql = 'bcp "select [release_build_key],[release_statement_sequence],[release_number],[release_statement_type],[release_statement] = REPLACE(REPLACE([release_statement],CHAR(13),''''),CHAR(10),''''),[affected_row_count] from #database_name#.[dv_release].[dv_release_build]  where [release_number] = #release_number# FOR XML RAW(''statement''), ROOT (''statements''), ELEMENTS" queryout #file_location#\#filename#.txt -c -T -S#servername# -r -t' 
select @sql = replace(@sql, '#database_name#', quotename(db_name())) 
select @sql = replace(@sql, '#release_number#', format(@vault_release_number, '000000'))
select @sql = replace(@sql, '#file_location#',@vault_file_location) 
select @sql = replace(@sql, '#filename#', @filename)
select @sql = replace(@sql, '#servername#', @@servername)
--select @sql
exec master.dbo.xp_cmdshell @sql

/*--------------------------------------------------------------------------------------------------------------*/
IF @@TRANCOUNT > 0 COMMIT TRAN;

SET @_Message   = 'Successfully Exported Release: ' + format(@vault_release_number, '000000')

END TRY
BEGIN CATCH
SET @_ErrorContext	= 'Failed to Export Release: ' + format(@vault_release_number, '000000')
IF (XACT_STATE() = -1) -- uncommitable transaction
OR (@@TRANCOUNT > 0 AND XACT_STATE() != 1) -- undocumented uncommitable transaction
	BEGIN
		ROLLBACK TRAN;
		SET @_ErrorContext = @_ErrorContext + ' (Forced rolled back of all changes)';
	END
	
EXEC log4.ExceptionHandler
		  @ErrorContext  = @_ErrorContext
		, @ErrorNumber   = @_Error OUT
		, @ReturnMessage = @_Message OUT
		, @ExceptionId   = @_ExceptionId OUT
;
END CATCH

--/////////////////////////////////////////////////////////////////////////////////////////////////
OnComplete:
--/////////////////////////////////////////////////////////////////////////////////////////////////

	--! Clean up

	--!
	--! Use dbo.udf_FormatElapsedTime() to get a nicely formatted run time string e.g.
	--! "0 hr(s) 1 min(s) and 22 sec(s)" or "1345 milliseconds"
	--!
	IF @_Error = 0
		BEGIN
			SET @_Step			= 'OnComplete'
			SET @_Severity		= @SEVERITY_SUCCESS
			SET @_Message		= COALESCE(@_Message, @_Step)
								+ ' in a total run time of ' + log4.FormatElapsedTime(@_SprocStartTime, NULL, 3)
			SET @_ProgressText  = @_ProgressText + @NEW_LINE + @_Message;
		END
	ELSE
		BEGIN
			SET @_Step			= COALESCE(@_Step, 'OnError')
			SET @_Severity		= @SEVERITY_SEVERE
			SET @_Message		= COALESCE(@_Message, @_Step)
								+ ' after a total run time of ' + log4.FormatElapsedTime(@_SprocStartTime, NULL, 3)
			SET @_ProgressText  = @_ProgressText + @NEW_LINE + @_Message;
		END

	IF @_JournalOnOff = 'ON'
		EXEC log4.JournalWriter
				  @Task				= @_FunctionName
				, @FunctionName		= @_FunctionName
				, @StepInFunction	= @_Step
				, @MessageText		= @_Message
				, @Severity			= @_Severity
				, @ExceptionId		= @_ExceptionId
				--! Supply all the progress info after we've gone to such trouble to collect it
				, @ExtraInfo        = @_ProgressText

	--! Finally, throw an exception that will be detected by the caller
	IF @DoThrowError = 1 AND @_Error > 0
		RAISERROR(@_Message, 16, 99);

	SET NOCOUNT OFF;

	--! Return the value of @@ERROR (which will be zero on success)
	RETURN (@_Error);
END
GO
PRINT N'Creating [dv_scheduler].[dv_populate_manifest_hierarchy]...';


GO
CREATE PROCEDURE [dv_scheduler].[dv_populate_manifest_hierarchy]
(
	@run_key			int
   ,@DoGenerateError   bit          = 0
   ,@DoThrowError      bit			= 1
)
AS
BEGIN
SET NOCOUNT ON;

-- Internal use variables

-- Log4TSQL Journal Constants 
DECLARE @SEVERITY_CRITICAL      smallint = 1;
DECLARE @SEVERITY_SEVERE        smallint = 2;
DECLARE @SEVERITY_MAJOR         smallint = 4;
DECLARE @SEVERITY_MODERATE      smallint = 8;
DECLARE @SEVERITY_MINOR         smallint = 16;
DECLARE @SEVERITY_CONCURRENCY   smallint = 32;
DECLARE @SEVERITY_INFORMATION   smallint = 256;
DECLARE @SEVERITY_SUCCESS       smallint = 512;
DECLARE @SEVERITY_DEBUG         smallint = 1024;
DECLARE @NEW_LINE               char(1)  = CHAR(10);

-- Log4TSQL Standard/ExceptionHandler variables
DECLARE	  @_Error         int
		, @_RowCount      int
		, @_Step          varchar(128)
		, @_Message       nvarchar(512)
		, @_ErrorContext  nvarchar(512)

-- Log4TSQL JournalWriter variables
DECLARE   @_FunctionName			varchar(255)
		, @_SprocStartTime			datetime
		, @_JournalOnOff			varchar(3)
		, @_Severity				smallint
		, @_ExceptionId				int
		, @_StepStartTime			datetime
		, @_ProgressText			nvarchar(max)

SET @_Error             = 0;
SET @_FunctionName      = OBJECT_NAME(@@PROCID);
SET @_Severity          = @SEVERITY_INFORMATION;
SET @_SprocStartTime    = sysdatetimeoffset();
SET @_ProgressText      = '' 
SET @_JournalOnOff      = log4.GetJournalControl(@_FunctionName, 'HOWTO');  -- left Group Name as HOWTO for now.
			
	
--set the Parameters for logging:
SET @_ProgressText		= @_FunctionName + ' starting at ' + CONVERT(char(23), @_SprocStartTime, 121) + ' with inputs: '
						+ @NEW_LINE + '    @run_key		         : ' + COALESCE(cast(@run_key as varchar(20)), '<NULL>')
						+ @NEW_LINE + '    @DoGenerateError      : ' + COALESCE(CAST(@DoGenerateError AS varchar), '<NULL>')
						+ @NEW_LINE + '    @DoThrowError         : ' + COALESCE(CAST(@DoThrowError AS varchar), '<NULL>')
						+ @NEW_LINE
BEGIN TRANSACTION
BEGIN TRY
SET @_Step = 'Generate any required error';
IF @DoGenerateError = 1
   select 1 / 0
SET @_Step = 'Validate Inputs';
IF (select count(*) from [dv_scheduler].[dv_run] where [run_key] = @run_key) <> 1
			RAISERROR('@run_key: %i Does Not Exist', 16, 1, @run_key);

SET @_Step = 'Initialise Variables';

SET @_Step = 'Build the Hierarchy';
;with cte_manifest_current as
(select src_table_hierarchy.source_table_hierarchy_key,run_mani.run_manifest_key 
from dv_scheduler.vw_dv_source_table_hierarchy_current src_table_hierarchy
inner join dv_scheduler.dv_run_manifest run_mani
on src_table_hierarchy.source_table_key = run_mani.source_table_key
where run_mani.run_key = @run_key 
--and src_table_hierarchy.is_deleted <> 1
),
cte_manifest_prior as (
select src_table_hierarchy_prior.source_table_hierarchy_key, run_mani_prior.run_manifest_key as prior_manifest_key
from dv_scheduler.vw_dv_source_table_hierarchy_current src_table_hierarchy_prior
inner join dv_scheduler.dv_run_manifest run_mani_prior
on src_table_hierarchy_prior.prior_table_key = run_mani_prior.source_table_key
where run_mani_prior.run_key = @run_key 
--and src_table_hierarchy_prior.is_deleted <> 1
) 
insert into dv_scheduler.dv_run_manifest_hierarchy (run_manifest_key, run_manifest_prior_key)
select mani_cur.run_manifest_key, mani_prev.prior_manifest_key  
from cte_manifest_current mani_cur
inner join cte_manifest_prior mani_prev
on mani_cur.source_table_hierarchy_key = mani_prev.source_table_hierarchy_key;

if (SELECT count(*) from [dv_scheduler].[fn_check_manifest_for_circular_reference] (@run_key)) <> 0
    BEGIN 
	SET @_ProgressText  = @_ProgressText + @NEW_LINE
						+ 'the Manifest created for @run_key: ' + cast(@run_key as varchar(20)) + ' Has Created a Circular Reference. Please Investigate'
						+ @NEW_LINE
	print @_ProgressText
	END

/*--------------------------------------------------------------------------------------------------------------*/
IF @@TRANCOUNT > 0 COMMIT TRAN;

SET @_Message   = 'Successfully Populated Manifest Hierarchy for Run: ' + cast(@run_key as varchar(20))

END TRY
BEGIN CATCH
SET @_ErrorContext	= 'Failed to Populate Manifest Hierarchy for Run: ' + cast(@run_key as varchar(20)) 
IF (XACT_STATE() = -1)  OR (@@TRANCOUNT > 0)
	BEGIN
		ROLLBACK TRAN;
		SET @_ErrorContext = @_ErrorContext + ' (Forced rolled back of all changes)';
	END
	
EXEC log4.ExceptionHandler
		  @ErrorContext  = @_ErrorContext
		, @ErrorNumber   = @_Error OUT
		, @ReturnMessage = @_Message OUT
		, @ExceptionId   = @_ExceptionId OUT
;
END CATCH

--/////////////////////////////////////////////////////////////////////////////////////////////////
OnComplete:
--/////////////////////////////////////////////////////////////////////////////////////////////////

	--! Clean up

	--!
	--! Use dbo.udf_FormatElapsedTime() to get a nicely formatted run time string e.g.
	--! "0 hr(s) 1 min(s) and 22 sec(s)" or "1345 milliseconds"
	--!
	IF @_Error = 0
		BEGIN
			SET @_Step			= 'OnComplete'
			SET @_Severity		= @SEVERITY_SUCCESS
			SET @_Message		= COALESCE(@_Message, @_Step)
								+ ' in a total run time of ' + log4.FormatElapsedTime(@_SprocStartTime, NULL, 3)
			SET @_ProgressText  = @_ProgressText + @NEW_LINE + @_Message;
		END
	ELSE
		BEGIN
			SET @_Step			= COALESCE(@_Step, 'OnError')
			SET @_Severity		= @SEVERITY_SEVERE
			SET @_Message		= COALESCE(@_Message, @_Step)
								+ ' after a total run time of ' + log4.FormatElapsedTime(@_SprocStartTime, NULL, 3)
			SET @_ProgressText  = @_ProgressText + @NEW_LINE + @_Message;
		END

	IF @_JournalOnOff = 'ON'
		EXEC log4.JournalWriter
				  @Task				= @_FunctionName
				, @FunctionName		= @_FunctionName
				, @StepInFunction	= @_Step
				, @MessageText		= @_Message
				, @Severity			= @_Severity
				, @ExceptionId		= @_ExceptionId
				--! Supply all the progress info after we've gone to such trouble to collect it
				, @ExtraInfo        = @_ProgressText

	--! Finally, throw an exception that will be detected by the caller
	IF @DoThrowError = 1 AND @_Error > 0
		RAISERROR(@_Message, 16, 99);

	SET NOCOUNT OFF;

	--! Return the value of @@ERROR (which will be zero on success)
	RETURN (@_Error);
END
GO
PRINT N'Creating [dv_scheduler].[dv_populate_manifest]...';


GO
CREATE PROCEDURE [dv_scheduler].[dv_populate_manifest]
(
	 @schedule_name		varchar(4000)
	,@run_key			int
	,@DoGenerateError   bit          = 0
	,@DoThrowError      bit			 = 1
)
AS
BEGIN
SET NOCOUNT ON;

-- Internal use variables

DECLARE
    @vault_statement		nvarchar(max),
	@vault_change_count		int,
	@release_key			int,
	@release_number			int,
	@change_count			int = 0,
	@currtable				SYSNAME,
	@currschema				SYSNAME,
	@dv_schema_name			sysname,
	@dv_table_name			sysname,
    @parm_definition		nvarchar(500),
	@rc						int	

-- Log4TSQL Journal Constants 
DECLARE @SEVERITY_CRITICAL      smallint = 1;
DECLARE @SEVERITY_SEVERE        smallint = 2;
DECLARE @SEVERITY_MAJOR         smallint = 4;
DECLARE @SEVERITY_MODERATE      smallint = 8;
DECLARE @SEVERITY_MINOR         smallint = 16;
DECLARE @SEVERITY_CONCURRENCY   smallint = 32;
DECLARE @SEVERITY_INFORMATION   smallint = 256;
DECLARE @SEVERITY_SUCCESS       smallint = 512;
DECLARE @SEVERITY_DEBUG         smallint = 1024;
DECLARE @NEW_LINE               char(1)  = CHAR(10);

-- Log4TSQL Standard/ExceptionHandler variables
DECLARE	  @_Error         int
		, @_RowCount      int
		, @_Step          varchar(128)
		, @_Message       nvarchar(512)
		, @_ErrorContext  nvarchar(512)

-- Log4TSQL JournalWriter variables
DECLARE   @_FunctionName			varchar(255)
		, @_SprocStartTime			datetime
		, @_JournalOnOff			varchar(3)
		, @_Severity				smallint
		, @_ExceptionId				int
		, @_StepStartTime			datetime
		, @_ProgressText			nvarchar(max)

SET @_Error             = 0;
SET @_FunctionName      = OBJECT_NAME(@@PROCID);
SET @_Severity          = @SEVERITY_INFORMATION;
SET @_SprocStartTime    = sysdatetimeoffset();
SET @_ProgressText      = '' 
SET @_JournalOnOff      = log4.GetJournalControl(@_FunctionName, 'HOWTO');  -- left Group Name as HOWTO for now.
			
	
--set the Parameters for logging:
SET @_ProgressText		= @_FunctionName + ' starting at ' + CONVERT(char(23), @_SprocStartTime, 121) + ' with inputs: '
						+ @NEW_LINE + '    @schedule_name	: ' + COALESCE(@schedule_name					, '<NULL>')
						+ @NEW_LINE + '    @run_key			: ' + COALESCE(CAST(@run_key as varchar(20))	, '<NULL>')
						+ @NEW_LINE + '    @DoGenerateError : ' + COALESCE(CAST(@DoGenerateError AS varchar), '<NULL>')
						+ @NEW_LINE + '    @DoThrowError    : ' + COALESCE(CAST(@DoThrowError AS varchar)	, '<NULL>')
						+ @NEW_LINE
BEGIN TRANSACTION
BEGIN TRY
SET @_Step = 'Generate any required error';
IF @DoGenerateError = 1
   select 1 / 0
SET @_Step = 'Validate Inputs';

SET @_Step = 'Initialise Variables';

SET @_Step = 'Initialise Release';


-- insert all tables to be run into the dv_run_manifest table
INSERT INTO dv_scheduler.dv_run_manifest (
	 [run_key]
	,[source_system_name]
	,[source_timevault]
	,[source_table_schema]
	,[source_table_name]
	,[source_table_key]
	,[source_table_load_type]
	,[source_procedure_schema]
	,[source_procedure_name]
	,[priority]
	,[queue]
	)
SELECT @run_key AS run_key
	,[src_system].[source_system_name]
	,[src_system].[timevault_name]
	,[src_table].[source_table_schema]
	,[src_table].[source_table_name]
	,[src_table].[source_table_key]
	,case when [schd_src_table].[source_table_load_type] = 'Default' then [src_table].[source_table_load_type] else [schd_src_table].[source_table_load_type] end
	,[src_table].[source_procedure_schema]
	,[src_table].[source_procedure_name]
	,[schd_src_table].[priority]
	,[schd_src_table].[queue]
FROM dv_scheduler.vw_dv_schedule_current AS schd
INNER JOIN dv_scheduler.vw_dv_schedule_source_table_current AS schd_src_table 
	ON schd.schedule_key = schd_src_table.schedule_key
INNER JOIN dbo.dv_source_table AS src_table 
	ON schd_src_table.source_table_key = src_table.[source_table_key]
INNER JOIN dbo.dv_source_system AS src_system 
	ON src_table.system_key = src_system.[source_system_key]
WHERE upper(schedule_name) IN (
		SELECT replace(Item, ' ', '')
		FROM dbo.fn_split_strings(upper(@schedule_name), ',')
		)
--and (schd_src_table.is_deleted | schd.is_deleted <> 1);  -- Bitwise OR to check if one or both bits are set


/*--------------------------------------------------------------------------------------------------------------*/
IF @@TRANCOUNT > 0 COMMIT TRAN;

SET @_Message   = 'Successfully Populated Manifest for Schedule: ' + @schedule_name

END TRY
BEGIN CATCH
SET @_ErrorContext	= 'Failed to Populate Manifest for Schedule: ' + @schedule_name
IF (XACT_STATE() = -1) -- uncommitable transaction
OR (@@TRANCOUNT > 0) -- AND XACT_STATE() != 1) -- undocumented uncommitable transaction
	BEGIN
		ROLLBACK TRAN;
		SET @_ErrorContext = @_ErrorContext + ' (Forced rolled back of all changes)';
	END
	
EXEC log4.ExceptionHandler
		  @ErrorContext  = @_ErrorContext
		, @ErrorNumber   = @_Error OUT
		, @ReturnMessage = @_Message OUT
		, @ExceptionId   = @_ExceptionId OUT
;
END CATCH

--/////////////////////////////////////////////////////////////////////////////////////////////////
OnComplete:
--/////////////////////////////////////////////////////////////////////////////////////////////////

	--! Clean up

	--!
	--! Use dbo.udf_FormatElapsedTime() to get a nicely formatted run time string e.g.
	--! "0 hr(s) 1 min(s) and 22 sec(s)" or "1345 milliseconds"
	--!
	IF @_Error = 0
		BEGIN
			SET @_Step			= 'OnComplete'
			SET @_Severity		= @SEVERITY_SUCCESS
			SET @_Message		= COALESCE(@_Message, @_Step)
								+ ' in a total run time of ' + log4.FormatElapsedTime(@_SprocStartTime, NULL, 3)
			SET @_ProgressText  = @_ProgressText + @NEW_LINE + @_Message;
		END
	ELSE
		BEGIN
			SET @_Step			= COALESCE(@_Step, 'OnError')
			SET @_Severity		= @SEVERITY_SEVERE
			SET @_Message		= COALESCE(@_Message, @_Step)
								+ ' after a total run time of ' + log4.FormatElapsedTime(@_SprocStartTime, NULL, 3)
			SET @_ProgressText  = @_ProgressText + @NEW_LINE + @_Message;
		END

	IF @_JournalOnOff = 'ON'
		EXEC log4.JournalWriter
				  @Task				= @_FunctionName
				, @FunctionName		= @_FunctionName
				, @StepInFunction	= @_Step
				, @MessageText		= @_Message
				, @Severity			= @_Severity
				, @ExceptionId		= @_ExceptionId
				--! Supply all the progress info after we've gone to such trouble to collect it
				, @ExtraInfo        = @_ProgressText

	--! Finally, throw an exception that will be detected by the caller
	IF @DoThrowError = 1 AND @_Error > 0
		RAISERROR(@_Message, 16, 99);

	SET NOCOUNT OFF;

	--! Return the value of @@ERROR (which will be zero on success)
	RETURN (@_Error);
END
GO
PRINT N'Creating [dv_scheduler].[dv_manifest_delete]...';


GO
CREATE procedure [dv_scheduler].[dv_manifest_delete]
( 
  @vault_run_key int
, @dogenerateerror               bit            = 0
, @dothrowerror                  bit			= 1
)
as

BEGIN
set nocount on

-- Local Variables

-- Log4TSQL Journal Constants 
DECLARE @SEVERITY_CRITICAL      smallint = 1;
DECLARE @SEVERITY_SEVERE        smallint = 2;
DECLARE @SEVERITY_MAJOR         smallint = 4;
DECLARE @SEVERITY_MODERATE      smallint = 8;
DECLARE @SEVERITY_MINOR         smallint = 16;
DECLARE @SEVERITY_CONCURRENCY   smallint = 32;
DECLARE @SEVERITY_INFORMATION   smallint = 256;
DECLARE @SEVERITY_SUCCESS       smallint = 512;
DECLARE @SEVERITY_DEBUG         smallint = 1024;
DECLARE @NEW_LINE               char(1)  = CHAR(10);

-- Log4TSQL Standard/ExceptionHandler variables
DECLARE	  @_Error         int
		, @_RowCount      int
		, @_Step          varchar(128)
		, @_Message       nvarchar(512)
		, @_ErrorContext  nvarchar(512)

-- Log4TSQL JournalWriter variables
DECLARE   @_FunctionName			varchar(255)
		, @_SprocStartTime			datetime
		, @_JournalOnOff			varchar(3)
		, @_Severity				smallint
		, @_ExceptionId				int
		, @_StepStartTime			datetime
		, @_ProgressText			nvarchar(max)

SET @_Error             = 0;
SET @_FunctionName      = OBJECT_NAME(@@PROCID);
SET @_Severity          = @SEVERITY_INFORMATION;
SET @_SprocStartTime    = sysdatetimeoffset();
SET @_ProgressText      = '' 
SET @_JournalOnOff      = log4.GetJournalControl(@_FunctionName, 'HOWTO');  -- left Group Name as HOWTO for now.


-- set the Parameters for logging:

SET @_ProgressText		= @_FunctionName + ' starting at ' + CONVERT(char(23), @_SprocStartTime, 121) + ' with inputs: '
						+ @NEW_LINE + '    @vault_run_key                : ' + COALESCE(CAST(@vault_run_key AS varchar(20)), '<NULL>')
						+ @NEW_LINE + '    @DoGenerateError              : ' + COALESCE(CAST(@DoGenerateError AS varchar), '<NULL>')
						+ @NEW_LINE + '    @DoThrowError                 : ' + COALESCE(CAST(@DoThrowError AS varchar), '<NULL>')
						+ @NEW_LINE

BEGIN TRY
SET @_Step = 'Generate any required error';
IF @DoGenerateError = 1
   select 1 / 0
SET @_Step = 'Validate Inputs';

if not exists (select 1 from [dv_scheduler].[dv_run] where [run_key] = @vault_run_key 
													   and [run_status] in('Failed', 'Completed', 'Cancelled')
													   and [run_start_datetime] < dateadd(dd, -1, sysdatetimeoffset())
				)
   raiserror('Run Manifest must be "Completed", "Cancelled" or "Failed" and older than 24 hours, to be able to Delete it', 16, 1)

/*--------------------------------------------------------------------------------------------------------------*/
SET @_Step = 'Get Defaults';

BEGIN TRANSACTION
delete from [dv_scheduler].[dv_run_manifest_hierarchy] where [run_manifest_hierarchy_key] in(
select distinct [run_manifest_hierarchy_key]
from [dv_scheduler].[dv_run_manifest_hierarchy]
where [run_manifest_key] in(select [run_manifest_key] from [dv_scheduler].[dv_run_manifest] where run_key = @vault_run_key))

delete from [dv_scheduler].[dv_run_manifest] 
where run_key = @vault_run_key

delete from [dv_scheduler].[dv_run]
where run_key = @vault_run_key

/*--------------------------------------------------------------------------------------------------------------*/

SET @_ProgressText  = @_ProgressText + @NEW_LINE
				+ 'Step: [' + @_Step + '] completed ' 

IF @@TRANCOUNT > 0 COMMIT TRAN;

SET @_Message   = 'Successfully Removed Manifest with Run_Key: ' + cast(@vault_run_key as varchar(20))

END TRY
BEGIN CATCH
SET @_ErrorContext	= 'Failed to Remove Manifest with Run_Key: ' + cast(@vault_run_key as varchar(20))
IF (XACT_STATE() = -1) OR (@@TRANCOUNT > 0) -- undocumented uncommitable transaction
	BEGIN
		ROLLBACK TRAN;
		SET @_ErrorContext = @_ErrorContext + ' (Forced rolled back of all changes)';
	END
	
EXEC log4.ExceptionHandler
		  @ErrorContext  = @_ErrorContext
		, @ErrorNumber   = @_Error OUT
		, @ReturnMessage = @_Message OUT
		, @ExceptionId   = @_ExceptionId OUT
;
END CATCH

--/////////////////////////////////////////////////////////////////////////////////////////////////
OnComplete:
--/////////////////////////////////////////////////////////////////////////////////////////////////

	--! Clean up

	--!
	--! Use dbo.udf_FormatElapsedTime() to get a nicely formatted run time string e.g.
	--! "0 hr(s) 1 min(s) and 22 sec(s)" or "1345 milliseconds"
	--!
	IF @_Error = 0
		BEGIN
			SET @_Step			= 'OnComplete'
			SET @_Severity		= @SEVERITY_SUCCESS
			SET @_Message		= COALESCE(@_Message, @_Step)
								+ ' in a total run time of ' + log4.FormatElapsedTime(@_SprocStartTime, NULL, 3)
			SET @_ProgressText  = @_ProgressText + @NEW_LINE + @_Message;
		END
	ELSE
		BEGIN
			SET @_Step			= COALESCE(@_Step, 'OnError')
			SET @_Severity		= @SEVERITY_SEVERE
			SET @_Message		= COALESCE(@_Message, @_Step)
								+ ' after a total run time of ' + log4.FormatElapsedTime(@_SprocStartTime, NULL, 3)
			SET @_ProgressText  = @_ProgressText + @NEW_LINE + @_Message;
		END

	IF @_JournalOnOff = 'ON'
		EXEC log4.JournalWriter
				  @Task				= @_FunctionName
				, @FunctionName		= @_FunctionName
				, @StepInFunction	= @_Step
				, @MessageText		= @_Message
				, @Severity			= @_Severity
				, @ExceptionId		= @_ExceptionId
				--! Supply all the progress info after we've gone to such trouble to collect it
				, @ExtraInfo        = @_ProgressText

	--! Finally, throw an exception that will be detected by the caller
	IF @DoThrowError = 1 AND @_Error > 0
		RAISERROR(@_Message, 16, 99);

	SET NOCOUNT OFF;

	--! Return the value of @@ERROR (which will be zero on success)
	RETURN (@_Error);
END
GO
PRINT N'Creating [dv_scheduler].[dv_populate_run_manifest]...';


GO
CREATE PROCEDURE [dv_scheduler].[dv_populate_run_manifest]
(
	@schedule_list		varchar(4000)
   ,@vault_run_key		int				output 
   ,@DoGenerateError	bit				= 0
   ,@DoThrowError		bit				= 1
)
AS
BEGIN
SET NOCOUNT ON;

-- Internal use variables

DECLARE		@RC					int;
DECLARE		@run_key			int;
DECLARE     @schedule_list_var	varchar(4000)

-- Log4TSQL Journal Constants 
DECLARE @SEVERITY_CRITICAL      smallint = 1;
DECLARE @SEVERITY_SEVERE        smallint = 2;
DECLARE @SEVERITY_MAJOR         smallint = 4;
DECLARE @SEVERITY_MODERATE      smallint = 8;
DECLARE @SEVERITY_MINOR         smallint = 16;
DECLARE @SEVERITY_CONCURRENCY   smallint = 32;
DECLARE @SEVERITY_INFORMATION   smallint = 256;
DECLARE @SEVERITY_SUCCESS       smallint = 512;
DECLARE @SEVERITY_DEBUG         smallint = 1024;
DECLARE @NEW_LINE               char(1)  = CHAR(10);

-- Log4TSQL Standard/ExceptionHandler variables
DECLARE	  @_Error         int
		, @_RowCount      int
		, @_Step          varchar(128)
		, @_Message       nvarchar(512)
		, @_ErrorContext  nvarchar(512)

-- Log4TSQL JournalWriter variables
DECLARE   @_FunctionName			varchar(255)
		, @_SprocStartTime			datetime
		, @_JournalOnOff			varchar(3)
		, @_Severity				smallint
		, @_ExceptionId				int
		, @_StepStartTime			datetime
		, @_ProgressText			nvarchar(max)

SET @_Error             = 0;
SET @_FunctionName      = OBJECT_NAME(@@PROCID);
SET @_Severity          = @SEVERITY_INFORMATION;
SET @_SprocStartTime    = sysdatetimeoffset();
SET @_ProgressText      = '' 
SET @_JournalOnOff      = log4.GetJournalControl(@_FunctionName, 'HOWTO');  -- left Group Name as HOWTO for now.
			
	
--set the Parameters for logging:
SET @_ProgressText		= @_FunctionName + ' starting at ' + CONVERT(char(23), @_SprocStartTime, 121) + ' with inputs: '
						+ @NEW_LINE + '    @schedule_list        : ' + COALESCE(@schedule_list, '<NULL>')
						+ @NEW_LINE + '    @DoGenerateError      : ' + COALESCE(CAST(@DoGenerateError AS varchar), '<NULL>')
						+ @NEW_LINE + '    @DoThrowError         : ' + COALESCE(CAST(@DoThrowError AS varchar), '<NULL>')
						+ @NEW_LINE

BEGIN TRANSACTION
BEGIN TRY
SET @_Step = 'Generate any required error';
IF @DoGenerateError = 1
   select 1 / 0

SET @_Step = 'Initialise Variables';
select @schedule_list_var = replace(@schedule_list, ' ','')

SET @_Step = 'insert one row for the run into dv_run table'
EXECUTE @run_key = [dv_scheduler].[dv_run_insert] @schedule_list_var 

SET @_Step = 'execute dv_populate_manifest to insert data in dv_run_manifest table'
EXECUTE @RC = [dv_scheduler].[dv_populate_manifest] @schedule_list_var, @run_key
  
SET @_Step = 'execute dv_populate_run_manifest_hierarchy to insert data in dv_run_manifest_hierarchy table'
EXECUTE @RC = [dv_scheduler].[dv_populate_manifest_hierarchy] @run_key

-- Return the Run Key to the controlling Proc.
select @vault_run_key = @run_key

/*--------------------------------------------------------------------------------------------------------------*/
IF @@TRANCOUNT > 0 COMMIT TRAN;

SET @_Message   = 'Successfully Built Manifest Schedule: ' + @schedule_list

END TRY
BEGIN CATCH
SET @_ErrorContext	= 'Failed to Build Manifest Schedule: ' + @schedule_list 
IF (XACT_STATE() = -1) -- uncommitable transaction
OR (@@TRANCOUNT > 0 ) --AND XACT_STATE() != 1) -- undocumented uncommitable transaction
IF @@TRANCOUNT > 0
	BEGIN
		ROLLBACK TRAN;
		SET @_ErrorContext = @_ErrorContext + ' (Forced rolled back of all changes)';
	END
	
EXEC log4.ExceptionHandler
		  @ErrorContext  = @_ErrorContext
		, @ErrorNumber   = @_Error OUT
		, @ReturnMessage = @_Message OUT
		, @ExceptionId   = @_ExceptionId OUT
;
END CATCH

--/////////////////////////////////////////////////////////////////////////////////////////////////
OnComplete:
--/////////////////////////////////////////////////////////////////////////////////////////////////

	--! Clean up

	--!
	--! Use dbo.udf_FormatElapsedTime() to get a nicely formatted run time string e.g.
	--! "0 hr(s) 1 min(s) and 22 sec(s)" or "1345 milliseconds"
	--!
	IF @_Error = 0
		BEGIN
			SET @_Step			= 'OnComplete'
			SET @_Severity		= @SEVERITY_SUCCESS
			SET @_Message		= COALESCE(@_Message, @_Step)
								+ ' in a total run time of ' + log4.FormatElapsedTime(@_SprocStartTime, NULL, 3)
			SET @_ProgressText  = @_ProgressText + @NEW_LINE + @_Message;
		END
	ELSE
		BEGIN
			SET @_Step			= COALESCE(@_Step, 'OnError')
			SET @_Severity		= @SEVERITY_SEVERE
			SET @_Message		= COALESCE(@_Message, @_Step)
								+ ' after a total run time of ' + log4.FormatElapsedTime(@_SprocStartTime, NULL, 3)
			SET @_ProgressText  = @_ProgressText + @NEW_LINE + @_Message;
		END

	IF @_JournalOnOff = 'ON'
		EXEC log4.JournalWriter
				  @Task				= @_FunctionName
				, @FunctionName		= @_FunctionName
				, @StepInFunction	= @_Step
				, @MessageText		= @_Message
				, @Severity			= @_Severity
				, @ExceptionId		= @_ExceptionId
				--! Supply all the progress info after we've gone to such trouble to collect it
				, @ExtraInfo        = @_ProgressText

	--! Finally, throw an exception that will be detected by the caller
	IF @DoThrowError = 1 AND @_Error > 0
		RAISERROR(@_Message, 16, 99);

	SET NOCOUNT OFF;

	--! Return the value of @@ERROR (which will be zero on success)
	RETURN (@_Error);
END
GO
PRINT N'Creating [dv_release].[dv_build_release_config]...';


GO
CREATE PROCEDURE [dv_release].[dv_build_release_config]
(
  @vault_release_number			int			 = NULL
, @vault_return_change_script	bit          = 0
, @DoGenerateError              bit          = 0
, @DoThrowError                 bit			 = 1
)

AS
BEGIN
SET NOCOUNT ON

-- Internal use variables
DECLARE @IncludeTables table(dv_schema_name sysname, dv_table_name sysname, dv_load_order int)
insert @IncludeTables 
SELECT dv_schema_name	
      ,dv_table_name	
	  ,dv_load_order
FROM [dv_release].[fn_config_table_list] ()


DECLARE
    @vault_statement		nvarchar(max),
	@vault_change_count		int,
	@release_key			int,
	@release_number			int,
	@change_count			int = 0,
	@currtable				SYSNAME,
	@currschema				SYSNAME,
	@dv_schema_name			sysname,
	@dv_table_name			sysname


-- Log4TSQL Journal Constants 
DECLARE @SEVERITY_CRITICAL      smallint = 1;
DECLARE @SEVERITY_SEVERE        smallint = 2;
DECLARE @SEVERITY_MAJOR         smallint = 4;
DECLARE @SEVERITY_MODERATE      smallint = 8;
DECLARE @SEVERITY_MINOR         smallint = 16;
DECLARE @SEVERITY_CONCURRENCY   smallint = 32;
DECLARE @SEVERITY_INFORMATION   smallint = 256;
DECLARE @SEVERITY_SUCCESS       smallint = 512;
DECLARE @SEVERITY_DEBUG         smallint = 1024;
DECLARE @NEW_LINE               char(1)  = CHAR(10);

-- Log4TSQL Standard/ExceptionHandler variables
DECLARE	  @_Error         int
		, @_RowCount      int
		, @_Step          varchar(128)
		, @_Message       nvarchar(512)
		, @_ErrorContext  nvarchar(512)

-- Log4TSQL JournalWriter variables
DECLARE   @_FunctionName			varchar(255)
		, @_SprocStartTime			datetime
		, @_JournalOnOff			varchar(3)
		, @_Severity				smallint
		, @_ExceptionId				int
		, @_StepStartTime			datetime
		, @_ProgressText			nvarchar(max)

SET @_Error             = 0;
SET @_FunctionName      = OBJECT_NAME(@@PROCID);
SET @_Severity          = @SEVERITY_INFORMATION;
SET @_SprocStartTime    = sysdatetimeoffset();
SET @_ProgressText      = '' 
SET @_JournalOnOff      = log4.GetJournalControl(@_FunctionName, 'HOWTO');  -- left Group Name as HOWTO for now.
			
	
-- set the Parameters for logging:
SET @_ProgressText		= @_FunctionName + ' starting at ' + CONVERT(char(23), @_SprocStartTime, 121) + ' with inputs: '
						+ @NEW_LINE + '    @vault_return_change_script   : ' + COALESCE(cast(@vault_return_change_script as varchar(20)), '<NULL>')
						+ @NEW_LINE + '    @vault_release_number         : ' + COALESCE(cast(@vault_release_number as varchar(20)), '<NULL>')
						+ @NEW_LINE + '    @DoGenerateError              : ' + COALESCE(CAST(@DoGenerateError AS varchar), '<NULL>')
						+ @NEW_LINE + '    @DoThrowError                 : ' + COALESCE(CAST(@DoThrowError AS varchar), '<NULL>')
						+ @NEW_LINE

BEGIN TRY
SET @_Step = 'Generate any required error';
IF @DoGenerateError = 1
   select 1 / 0
SET @_Step = 'Validate Inputs';

SET @_Step = 'Initialise Variables';

CREATE TABLE #dv_release_build(
	[release_build_key]				[int] NOT NULL,
	[release_statement_sequence]	[int] identity(1,1) not null,
	[release_number]				[int] not null,
	[release_statement_type]		[varchar](10),
	[release_statement]				[varchar](max) NULL,
	[affected_row_count]			[int] NOT NULL)
			
SET @_Step = 'Get Release Header';
select @release_key = release_key from [dv_release].[dv_release_master] where release_number = @vault_release_number

SET @_Step = 'Initialise Release';

update [dv_release].[dv_release_master]
set [build_number]		= [build_number] + 1,
    [build_date]		= SYSDATETIMEOFFSET(),
	[build_server]		= @@SERVERNAME,
	[release_built_by]	= user_name()
where [release_key] = @release_key

-- Extract the Release Master Details
EXECUTE [dv_release].[dv_build_release_config_table] 'dv_release', 'dv_release_master', @vault_release_number, 'release_start_datetime,release_complete_datetime,release_count', @vault_statement OUTPUT, @vault_change_count OUTPUT
insert #dv_release_build([release_build_key], [release_number], [release_statement_type], [release_statement], [affected_row_count])values(@release_key, @vault_release_number, 'Header', @vault_statement, @vault_change_count)

-- Extract the Changes per Table
DECLARE dv_table_cursor CURSOR FOR  
SELECT dv_schema_name, dv_table_name
FROM @IncludeTables 
order by dv_load_order

OPEN dv_table_cursor
FETCH NEXT FROM dv_table_cursor INTO @dv_schema_name, @dv_table_name

WHILE @@FETCH_STATUS = 0   
BEGIN   
 --      print @dv_table_name
	   EXECUTE [dv_release].[dv_build_release_config_table] @dv_schema_name, @dv_table_name, @vault_release_number, '', @vault_statement OUTPUT, @vault_change_count OUTPUT
	   if isnull(@vault_change_count, 0) > 0
			insert #dv_release_build([release_build_key], [release_number], [release_statement_type], [release_statement], [affected_row_count]) values(@release_key, @vault_release_number, 'Table', @vault_statement, @vault_change_count)
       FETCH NEXT FROM dv_table_cursor INTO @dv_schema_name, @dv_table_name   
END   

CLOSE dv_table_cursor   
DEALLOCATE dv_table_cursor


delete from [dv_release].[dv_release_build] where [release_build_key] = @release_key
insert [dv_release].[dv_release_build]
SELECT [release_build_key]
      ,[release_statement_sequence]
	  ,[release_number]
	  ,[release_statement_type]
      ,[release_statement]
      ,[affected_row_count]
  FROM #dv_release_build

if @vault_return_change_script = 1
	select * from #dv_release_build

/*--------------------------------------------------------------------------------------------------------------*/
IF @@TRANCOUNT > 0 COMMIT TRAN;

SET @_Message   = 'Successfully Created Release for: ' 

END TRY
BEGIN CATCH
SET @_ErrorContext	= 'Failed to Create Release for: ' 
IF (XACT_STATE() = -1) -- uncommitable transaction
OR (@@TRANCOUNT > 0 AND XACT_STATE() != 1) -- undocumented uncommitable transaction
	BEGIN
		ROLLBACK TRAN;
		SET @_ErrorContext = @_ErrorContext + ' (Forced rolled back of all changes)';
	END
	
EXEC log4.ExceptionHandler
		  @ErrorContext  = @_ErrorContext
		, @ErrorNumber   = @_Error OUT
		, @ReturnMessage = @_Message OUT
		, @ExceptionId   = @_ExceptionId OUT
;
END CATCH

--/////////////////////////////////////////////////////////////////////////////////////////////////
OnComplete:
--/////////////////////////////////////////////////////////////////////////////////////////////////

	--! Clean up

	--!
	--! Use dbo.udf_FormatElapsedTime() to get a nicely formatted run time string e.g.
	--! "0 hr(s) 1 min(s) and 22 sec(s)" or "1345 milliseconds"
	--!
	IF @_Error = 0
		BEGIN
			SET @_Step			= 'OnComplete'
			SET @_Severity		= @SEVERITY_SUCCESS
			SET @_Message		= COALESCE(@_Message, @_Step)
								+ ' in a total run time of ' + log4.FormatElapsedTime(@_SprocStartTime, NULL, 3)
			SET @_ProgressText  = @_ProgressText + @NEW_LINE + @_Message;
		END
	ELSE
		BEGIN
			SET @_Step			= COALESCE(@_Step, 'OnError')
			SET @_Severity		= @SEVERITY_SEVERE
			SET @_Message		= COALESCE(@_Message, @_Step)
								+ ' after a total run time of ' + log4.FormatElapsedTime(@_SprocStartTime, NULL, 3)
			SET @_ProgressText  = @_ProgressText + @NEW_LINE + @_Message;
		END

	IF @_JournalOnOff = 'ON'
		EXEC log4.JournalWriter
				  @Task				= @_FunctionName
				, @FunctionName		= @_FunctionName
				, @StepInFunction	= @_Step
				, @MessageText		= @_Message
				, @Severity			= @_Severity
				, @ExceptionId		= @_ExceptionId
				--! Supply all the progress info after we've gone to such trouble to collect it
				, @ExtraInfo        = @_ProgressText

	--! Finally, throw an exception that will be detected by the caller
	IF @DoThrowError = 1 AND @_Error > 0
		RAISERROR(@_Message, 16, 99);

	SET NOCOUNT OFF;

	--! Return the value of @@ERROR (which will be zero on success)
	RETURN (@_Error);
END
GO
PRINT N'Creating [dv_scheduler].[dv_restart_manifest]...';


GO
CREATE PROCEDURE [dv_scheduler].[dv_restart_manifest]
(
    @vault_run_key			int	= 0
   ,@restart_failed_items	bit	= 0
   ,@force					bit	= 0
   ,@DoGenerateError		bit	= 0
   ,@DoThrowError			bit	= 1
)
AS
BEGIN
SET NOCOUNT ON;

-- Internal use variables

DECLARE		@RC					int;
DECLARE		@run_status			varchar(128);

-- Log4TSQL Journal Constants 
DECLARE @SEVERITY_CRITICAL      smallint = 1;
DECLARE @SEVERITY_SEVERE        smallint = 2;
DECLARE @SEVERITY_MAJOR         smallint = 4;
DECLARE @SEVERITY_MODERATE      smallint = 8;
DECLARE @SEVERITY_MINOR         smallint = 16;
DECLARE @SEVERITY_CONCURRENCY   smallint = 32;
DECLARE @SEVERITY_INFORMATION   smallint = 256;
DECLARE @SEVERITY_SUCCESS       smallint = 512;
DECLARE @SEVERITY_DEBUG         smallint = 1024;
DECLARE @NEW_LINE               char(1)  = CHAR(10);

-- Log4TSQL Standard/ExceptionHandler variables
DECLARE	  @_Error         int
		, @_RowCount      int
		, @_Step          varchar(128)
		, @_Message       nvarchar(512)
		, @_ErrorContext  nvarchar(512)

-- Log4TSQL JournalWriter variables
DECLARE   @_FunctionName			varchar(255)
		, @_SprocStartTime			datetime
		, @_JournalOnOff			varchar(3)
		, @_Severity				smallint
		, @_ExceptionId				int
		, @_StepStartTime			datetime
		, @_ProgressText			nvarchar(max)

SET @_Error             = 0;
SET @_FunctionName      = OBJECT_NAME(@@PROCID);
SET @_Severity          = @SEVERITY_INFORMATION;
SET @_SprocStartTime    = sysdatetimeoffset();
SET @_ProgressText      = '' 
SET @_JournalOnOff      = log4.GetJournalControl(@_FunctionName, 'HOWTO');  -- left Group Name as HOWTO for now.
			
	
--set the Parameters for logging:
SET @_ProgressText		= @_FunctionName + ' starting at ' + CONVERT(char(23), @_SprocStartTime, 121) + ' with inputs: '
						+ @NEW_LINE + '    @vault_run_key        : ' + COALESCE(cast(@vault_run_key as varchar), '<NULL>')
						+ @NEW_LINE + '    @restart_failed_items : ' + COALESCE(cast(@restart_failed_items as varchar), '<NULL>')
						+ @NEW_LINE + '    @force				 : ' + COALESCE(cast(@force as varchar), '<NULL>')
						+ @NEW_LINE + '    @DoGenerateError      : ' + COALESCE(CAST(@DoGenerateError AS varchar), '<NULL>')
						+ @NEW_LINE + '    @DoThrowError         : ' + COALESCE(CAST(@DoThrowError AS varchar), '<NULL>')
						+ @NEW_LINE

BEGIN TRANSACTION
BEGIN TRY
SET @_Step = 'Generate any required error';
IF @DoGenerateError = 1
   select 1 / 0
SET @_Step = 'Validation';
select @run_status = isnull(run_status, '<Unknown>') from [dv_scheduler].[dv_run] where run_key = @vault_run_key
if @@ROWCOUNT < 1 raiserror('Run Key: %i does not exist', @vault_run_key, 16, 1)
if @run_status not in('Failed')
	if @force <> 1
		raiserror('%s is not a valid status for restarting a manifest', @run_status, 16, 1)

SET @_Step = 'Initialise Variables';

SET @_Step = 'Set the Run Staus to "Scheduled". Ensure that any "Queued" manifest items are set to "Scheduled"'
update [dv_scheduler].[dv_run]
	set [run_status] = 'Scheduled'
where [run_key] = @vault_run_key

update [dv_scheduler].[dv_run_manifest]
	set [run_status] = 'Scheduled'
where [run_key] = @vault_run_key
  and [run_status] = 'Queued'

if @restart_failed_items = 1
update [dv_scheduler].[dv_run_manifest]
	set [run_status] = 'Scheduled'
where [run_key] = @vault_run_key
  and [run_status] = 'Failed'
IF @@TRANCOUNT > 0 COMMIT TRAN;

SET @_Step = 'Start the Manifest Running'
EXECUTE [dv_scheduler].[dv_process_manifest] @vault_run_key
  
/*--------------------------------------------------------------------------------------------------------------*/
IF @@TRANCOUNT > 0 COMMIT TRAN;

SET @_Message   = 'Successfully Processed Manifest: ' + cast(@vault_run_key as varchar)

END TRY
BEGIN CATCH
SET @_ErrorContext	= 'Failed to Process Manifest: ' + cast(@vault_run_key as varchar)
IF (XACT_STATE() = -1) -- uncommitable transaction
OR (@@TRANCOUNT > 0 ) --AND XACT_STATE() != 1) -- undocumented uncommitable transaction
IF @@TRANCOUNT > 0
	BEGIN
		ROLLBACK TRAN;
		SET @_ErrorContext = @_ErrorContext + ' (Forced rolled back of all changes)';
	END
	
EXEC log4.ExceptionHandler
		  @ErrorContext  = @_ErrorContext
		, @ErrorNumber   = @_Error OUT
		, @ReturnMessage = @_Message OUT
		, @ExceptionId   = @_ExceptionId OUT
;
END CATCH

--/////////////////////////////////////////////////////////////////////////////////////////////////
OnComplete:
--/////////////////////////////////////////////////////////////////////////////////////////////////

	--! Clean up

	--!
	--! Use dbo.udf_FormatElapsedTime() to get a nicely formatted run time string e.g.
	--! "0 hr(s) 1 min(s) and 22 sec(s)" or "1345 milliseconds"
	--!
	IF @_Error = 0
		BEGIN
			SET @_Step			= 'OnComplete'
			SET @_Severity		= @SEVERITY_SUCCESS
			SET @_Message		= COALESCE(@_Message, @_Step)
								+ ' in a total run time of ' + log4.FormatElapsedTime(@_SprocStartTime, NULL, 3)
			SET @_ProgressText  = @_ProgressText + @NEW_LINE + @_Message;
		END
	ELSE
		BEGIN
			SET @_Step			= COALESCE(@_Step, 'OnError')
			SET @_Severity		= @SEVERITY_SEVERE
			SET @_Message		= COALESCE(@_Message, @_Step)
								+ ' after a total run time of ' + log4.FormatElapsedTime(@_SprocStartTime, NULL, 3)
			SET @_ProgressText  = @_ProgressText + @NEW_LINE + @_Message;
		END

	IF @_JournalOnOff = 'ON'
		EXEC log4.JournalWriter
				  @Task				= @_FunctionName
				, @FunctionName		= @_FunctionName
				, @StepInFunction	= @_Step
				, @MessageText		= @_Message
				, @Severity			= @_Severity
				, @ExceptionId		= @_ExceptionId
				--! Supply all the progress info after we've gone to such trouble to collect it
				, @ExtraInfo        = @_ProgressText

	--! Finally, throw an exception that will be detected by the caller
	IF @DoThrowError = 1 AND @_Error > 0
		RAISERROR(@_Message, 16, 99);

	SET NOCOUNT OFF;

	--! Return the value of @@ERROR (which will be zero on success)
	RETURN (@_Error);
END
GO
PRINT N'Creating [dv_scheduler].[dv_process_schedule]...';


GO
CREATE PROCEDURE [dv_scheduler].[dv_process_schedule]
(
	@schedule_list		varchar(4000)
   ,@DoGenerateError	bit				= 0
   ,@DoThrowError		bit				= 1
)
AS
BEGIN
SET NOCOUNT ON;

-- Internal use variables

DECLARE		@vault_run_key			int = 0;
DECLARE     @schedule_list_var	varchar(4000)

-- Log4TSQL Journal Constants 
DECLARE @SEVERITY_CRITICAL      smallint = 1;
DECLARE @SEVERITY_SEVERE        smallint = 2;
DECLARE @SEVERITY_MAJOR         smallint = 4;
DECLARE @SEVERITY_MODERATE      smallint = 8;
DECLARE @SEVERITY_MINOR         smallint = 16;
DECLARE @SEVERITY_CONCURRENCY   smallint = 32;
DECLARE @SEVERITY_INFORMATION   smallint = 256;
DECLARE @SEVERITY_SUCCESS       smallint = 512;
DECLARE @SEVERITY_DEBUG         smallint = 1024;
DECLARE @NEW_LINE               char(1)  = CHAR(10);

-- Log4TSQL Standard/ExceptionHandler variables
DECLARE	  @_Error         int
		, @_RowCount      int
		, @_Step          varchar(128)
		, @_Message       nvarchar(512)
		, @_ErrorContext  nvarchar(512)

-- Log4TSQL JournalWriter variables
DECLARE   @_FunctionName			varchar(255)
		, @_SprocStartTime			datetime
		, @_JournalOnOff			varchar(3)
		, @_Severity				smallint
		, @_ExceptionId				int
		, @_StepStartTime			datetime
		, @_ProgressText			nvarchar(max)

SET @_Error             = 0;
SET @_FunctionName      = OBJECT_NAME(@@PROCID);
SET @_Severity          = @SEVERITY_INFORMATION;
SET @_SprocStartTime    = sysdatetimeoffset();
SET @_ProgressText      = '' 
SET @_JournalOnOff      = log4.GetJournalControl(@_FunctionName, 'HOWTO');  -- left Group Name as HOWTO for now.
			
	
--set the Parameters for logging:
SET @_ProgressText		= @_FunctionName + ' starting at ' + CONVERT(char(23), @_SprocStartTime, 121) + ' with inputs: '
						+ @NEW_LINE + '    @schedule_list        : ' + COALESCE(@schedule_list, '<NULL>')
						+ @NEW_LINE + '    @DoGenerateError      : ' + COALESCE(CAST(@DoGenerateError AS varchar), '<NULL>')
						+ @NEW_LINE + '    @DoThrowError         : ' + COALESCE(CAST(@DoThrowError AS varchar), '<NULL>')
						+ @NEW_LINE

BEGIN TRY
SET @_Step = 'Generate any required error';
IF @DoGenerateError = 1
   select 1 / 0

SET @_Step = 'Initialise Variables';
select @schedule_list_var = replace(@schedule_list, ' ','')

SET @_Step = 'Build a Manifest for the Schedule'
EXECUTE [dv_scheduler].[dv_populate_run_manifest] @schedule_list_var, @vault_run_key output

SET @_Step = 'Execute the Manifest'
EXECUTE [dv_scheduler].[dv_process_manifest] @vault_run_key
  
/*--------------------------------------------------------------------------------------------------------------*/
IF @@TRANCOUNT > 0 COMMIT TRAN;

SET @_Message   = 'Successfully Processed Schedule: ' + @schedule_list

END TRY
BEGIN CATCH
SET @_ErrorContext	= 'Failed to Process Schedule: ' + @schedule_list 
IF (XACT_STATE() = -1) -- uncommitable transaction
OR (@@TRANCOUNT > 0 ) --AND XACT_STATE() != 1) -- undocumented uncommitable transaction
IF @@TRANCOUNT > 0
	BEGIN
		ROLLBACK TRAN;
		SET @_ErrorContext = @_ErrorContext + ' (Forced rolled back of all changes)';
	END
	
EXEC log4.ExceptionHandler
		  @ErrorContext  = @_ErrorContext
		, @ErrorNumber   = @_Error OUT
		, @ReturnMessage = @_Message OUT
		, @ExceptionId   = @_ExceptionId OUT
;
END CATCH

--/////////////////////////////////////////////////////////////////////////////////////////////////
OnComplete:
--/////////////////////////////////////////////////////////////////////////////////////////////////

	--! Clean up

	--!
	--! Use dbo.udf_FormatElapsedTime() to get a nicely formatted run time string e.g.
	--! "0 hr(s) 1 min(s) and 22 sec(s)" or "1345 milliseconds"
	--!
	IF @_Error = 0
		BEGIN
			SET @_Step			= 'OnComplete'
			SET @_Severity		= @SEVERITY_SUCCESS
			SET @_Message		= COALESCE(@_Message, @_Step)
								+ ' in a total run time of ' + log4.FormatElapsedTime(@_SprocStartTime, NULL, 3)
			SET @_ProgressText  = @_ProgressText + @NEW_LINE + @_Message;
		END
	ELSE
		BEGIN
			SET @_Step			= COALESCE(@_Step, 'OnError')
			SET @_Severity		= @SEVERITY_SEVERE
			SET @_Message		= COALESCE(@_Message, @_Step)
								+ ' after a total run time of ' + log4.FormatElapsedTime(@_SprocStartTime, NULL, 3)
			SET @_ProgressText  = @_ProgressText + @NEW_LINE + @_Message;
		END

	IF @_JournalOnOff = 'ON'
		EXEC log4.JournalWriter
				  @Task				= @_FunctionName
				, @FunctionName		= @_FunctionName
				, @StepInFunction	= @_Step
				, @MessageText		= @_Message
				, @Severity			= @_Severity
				, @ExceptionId		= @_ExceptionId
				--! Supply all the progress info after we've gone to such trouble to collect it
				, @ExtraInfo        = @_ProgressText

	--! Finally, throw an exception that will be detected by the caller
	IF @DoThrowError = 1 AND @_Error > 0
		RAISERROR(@_Message, 16, 99);

	SET NOCOUNT OFF;

	--! Return the value of @@ERROR (which will be zero on success)
	RETURN (@_Error);
END
GO
PRINT N'Creating [dv_scheduler].[dv_process_queued_002]...';


GO
CREATE PROCEDURE [dv_scheduler].[dv_process_queued_002]

WITH EXECUTE AS OWNER
AS
BEGIN
SET NOCOUNT ON
-- Declare Variables for use by the SP.
DECLARE @task							nvarchar(512)
       ,@message_type_name				nvarchar(512)
	   ,@queue_name						nvarchar(512)
	   ,@msg							xml
	   ,@msgChar						nvarchar(500)
	   ,@sql							nvarchar(4000)
	   ,@dialog_handle					uniqueidentifier
	   ,@vault_source_system_name		nvarchar(50)
	   ,@vault_source_timevault			nvarchar(50)
	   ,@vault_source_table_schema		nvarchar(128)
	   ,@vault_source_table_name		nvarchar(128)
	   ,@vault_procedure_schema			nvarchar(128)
	   ,@vault_procedure_name			nvarchar(128)
	   ,@vault_source_table_run_type	nvarchar(50)
	   ,@vault_runkey					varchar(20)
	   ,@vault_run_key					int
	   ,@rowcount						int
	   ,@stage_delta_switch				varchar(100) = 'N'

-- Set Constant Values

set @queue_name = 'dv_scheduler_m002' -- Change for each Reveiver Procedure

-- Log4TSQL Journal Constants 
DECLARE @dogenerateerror		bit		 = 0
	   ,@dothrowerror			bit		 = 1
	    
DECLARE @SEVERITY_CRITICAL      smallint = 1;
DECLARE @SEVERITY_SEVERE        smallint = 2;
DECLARE @SEVERITY_MAJOR         smallint = 4;
DECLARE @SEVERITY_MODERATE      smallint = 8;
DECLARE @SEVERITY_MINOR         smallint = 16;
DECLARE @SEVERITY_CONCURRENCY   smallint = 32;
DECLARE @SEVERITY_INFORMATION   smallint = 256;
DECLARE @SEVERITY_SUCCESS       smallint = 512;
DECLARE @SEVERITY_DEBUG         smallint = 1024;
DECLARE @NEW_LINE               char(1)  = CHAR(10);

-- Log4TSQL Standard/ExceptionHandler variables
DECLARE	  @_Error         int
		, @_RowCount      int
		, @_Step          varchar(128)
		, @_Message       nvarchar(512)
		, @_ErrorContext  nvarchar(512)

-- Log4TSQL JournalWriter variables
DECLARE   @_FunctionName			varchar(255)
		, @_SprocStartTime			datetime
		, @_JournalOnOff			varchar(3)
		, @_Severity				smallint
		, @_ExceptionId				int
		, @_StepStartTime			datetime
		, @_ProgressText			nvarchar(max)

SET @_Error             = 0;
SET @_FunctionName      = OBJECT_NAME(@@PROCID);
SET @_Severity          = @SEVERITY_INFORMATION;
SET @_SprocStartTime    = sysdatetimeoffset();
SET @_ProgressText      = '' 
SET @_JournalOnOff      = log4.GetJournalControl(@_FunctionName, 'HOWTO');  -- left Group Name as HOWTO for now.


-- set the Parameters for logging:
SET @_ProgressText		= @_FunctionName + ' starting at ' + CONVERT(char(23), @_SprocStartTime, 121) + ' with inputs: '
						+ @NEW_LINE

BEGIN TRY
SET @_Step = 'Generate any required error';
IF @DoGenerateError = 1
   select 1 / 0
SET @_Step = 'Validate inputs';

SET @dialog_handle = NULL
/*--------------------------------------------------------------------------------------------------------------*/
SET @_Step = 'Get Defaults'

select @stage_delta_switch		= [default_varchar] from [dbo].[dv_defaults]		where default_type = 'Global'	and default_subtype = 'StageDeltaSwitch'
/*--------------------------------------------------------------------------------------------------------------*/

SET @_Step = 'Pull From the Queue';
WAITFOR ( RECEIVE TOP (1) @dialog_handle		= conversation_handle
                        , @message_type_name	= message_type_name
						, @msg					= convert(xml,message_body)
FROM [dv_scheduler_q002]), TIMEOUT 1000   -- Change for each Reveiver Procedure
                        
select @rowcount = @@ROWCOUNT

IF (@rowcount > 0)
	--END CONVERSATION @dialog_handle;
	BEGIN
	END CONVERSATION @dialog_handle;
	SET @_Step = 'Process the Message';	
	SET @msgChar = cast(@msg as varchar(500))
	IF @message_type_name = @queue_name
		BEGIN 
		    SELECT
			     @vault_runkey			    = x.value('(/Request/RunKey)[1]'			,'VARCHAR(20)')
				,@vault_source_timevault	= x.value('(/Request/SourceTimeVault)[1]'	,'VARCHAR(50)')
				,@vault_source_system_name	= x.value('(/Request/SourceSystem)[1]'		,'VARCHAR(50)')
				,@vault_source_table_schema	= x.value('(/Request/SourceSchema)[1]'		,'VARCHAR(128)')
				,@vault_source_table_name	= x.value('(/Request/SourceTable)[1]'		,'VARCHAR(128)')
				,@vault_procedure_schema	= x.value('(/Request/ProcSchema)[1]'		,'VARCHAR(128)')
				,@vault_procedure_name		= x.value('(/Request/ProcName)[1]'			,'VARCHAR(128)')
				,@vault_source_table_run_type	= x.value('(/Request/RunType)[1]'			,'VARCHAR(50)')
			FROM @msg.nodes('/Request') AS T(x);
			
			set @vault_run_key = cast(ltrim(rtrim(@vault_runkey)) as int)
			select @vault_source_table_run_type = case when @vault_source_table_run_type = 'Default' then null else @vault_source_table_run_type end

			SELECT 1
			  FROM [dv_scheduler].[dv_run] r
			  inner join [dv_scheduler].[dv_run_manifest] m
			  on r.run_key = m.run_key
			  where 1=1
				and r.run_key = @vault_run_key
				and m.source_system_name = @vault_source_system_name
				and r.run_status = 'Started'
				and m.run_status = 'Queued'
			if @@rowcount > 0
			BEGIN
				EXECUTE[dv_scheduler].[dv_manifest_status_update] @vault_run_key ,@vault_source_system_name ,@vault_source_table_schema ,@vault_source_table_name ,'Processing'

				--WAITFOR DELAY '00:00:10'
				if not (ltrim(rtrim(@vault_procedure_schema)) = '' or ltrim(rtrim(@vault_procedure_name)) = '')
					BEGIN
					SET @_Step = 'Executing Procedure: '+ quotename(@vault_source_timevault) + '.' + quotename(@vault_procedure_schema) + '.' + quotename(@vault_procedure_name);
					print @_Step	
					set @sql = 'EXEC ' + quotename(@vault_source_timevault) + '.' + quotename(@vault_procedure_schema) + '.' + quotename(@vault_procedure_name) 
					if @stage_delta_switch = 'Y' 
					set @sql = @sql + ' ''' + @vault_source_table_run_type + ''''
					exec (@SQL)
					END
				SET @_Step = 'Loading Table: ' + quotename(@vault_source_system_name) + '.' + quotename(@vault_source_table_schema) + '.' + quotename(@vault_source_table_name)
				exec [dbo].[dv_load_source_table] @vault_source_system_name, @vault_source_table_schema, @vault_source_table_name, @vault_source_table_run_type
				SET @_Step = 'Load Completed'
				EXECUTE[dv_scheduler].[dv_manifest_status_update] @vault_run_key ,@vault_source_system_name ,@vault_source_table_schema ,@vault_source_table_name ,'Completed'
			END
		END		
	ELSE 
		BEGIN		
			set @_Message = 'Message ' + quotename(@message_type_name) +  'Received but not Processed on Queue: ' + quotename(@queue_name) + quotename(@msgChar)
		    set @_ProgressText = @_ProgressText + @_Message + @NEW_LINE
		END
	END
SET @_ProgressText  = @_ProgressText + @NEW_LINE
				+ 'Step: [' + @_Step + '] completed ' 

IF @@TRANCOUNT > 0 COMMIT TRAN;

SET @_Message   = 'Completed Load of: ' + quotename(@vault_source_system_name) + '.' + quotename(@vault_source_table_schema) + '.' + quotename(@vault_source_table_name)
print @_Message

END TRY
BEGIN CATCH
SET @_ErrorContext	= 'Failed Load of: ' + isnull(quotename(@vault_source_system_name), '') + '.' + isnull(quotename(@vault_source_table_schema), '') + '.' + isnull(quotename(@vault_source_table_name), '') + @NEW_LINE
SET @_ErrorContext += 'For Message Type: ' + isnull(@message_type_name, '') + @NEW_LINE + 'For Message: ' + isnull(@msgChar, '')
IF (XACT_STATE() = -1) -- uncommitable transaction
OR (@@TRANCOUNT > 0 AND XACT_STATE() != 1) -- undocumented uncommitable transaction
	BEGIN
		ROLLBACK TRAN;
		SET @_ErrorContext = @_ErrorContext + ' (Forced rolled back of all changes)';
	END
EXECUTE[dv_scheduler].[dv_manifest_status_update] @vault_run_key ,@vault_source_system_name ,@vault_source_table_schema ,@vault_source_table_name ,'Failed'

EXEC log4.ExceptionHandler
		  @ErrorContext  = @_ErrorContext
		, @ErrorNumber   = @_Error OUT
		, @ReturnMessage = @_Message OUT
		, @ExceptionId   = @_ExceptionId OUT
;
END CATCH

--/////////////////////////////////////////////////////////////////////////////////////////////////
OnComplete:
--/////////////////////////////////////////////////////////////////////////////////////////////////

	--! Clean up

	--!
	--! Use dbo.udf_FormatElapsedTime() to get a nicely formatted run time string e.g.
	--! "0 hr(s) 1 min(s) and 22 sec(s)" or "1345 milliseconds"
	--!
	IF @_Error = 0
		BEGIN
			SET @_Step			= 'OnComplete'
			SET @_Severity		= @SEVERITY_SUCCESS
			SET @_Message		= COALESCE(@_Message, @_Step)
								+ ' in a total run time of ' + log4.FormatElapsedTime(@_SprocStartTime, NULL, 3)
			SET @_ProgressText  = @_ProgressText + @NEW_LINE + @_Message;
		END
	ELSE
		BEGIN
			SET @_Step			= COALESCE(@_Step, 'OnError')
			SET @_Severity		= @SEVERITY_SEVERE
			SET @_Message		= COALESCE(@_Message, @_Step)
								+ ' after a total run time of ' + log4.FormatElapsedTime(@_SprocStartTime, NULL, 3)
			SET @_ProgressText  = @_ProgressText + @NEW_LINE + @_Message;
		END
	IF @_JournalOnOff = 'ON'
		EXEC log4.JournalWriter
				  @Task				= @_FunctionName
				, @FunctionName		= @_FunctionName
				, @StepInFunction	= @_Step
				, @MessageText		= @_Message
				, @Severity			= @_Severity
				, @ExceptionId		= @_ExceptionId
				--! Supply all the progress info after we've gone to such trouble to collect it
				, @ExtraInfo        = @_ProgressText

	--! Finally, throw an exception that will be detected by the caller
	IF @DoThrowError = 1 AND @_Error > 0
		RAISERROR(@_Message, 16, 99);

	SET NOCOUNT OFF;

	--! Return the value of @@ERROR (which will be zero on success)
	RETURN (@_Error);
END
GO
PRINT N'Creating [dv_scheduler].[dv_process_queued_001]...';


GO
CREATE PROCEDURE [dv_scheduler].[dv_process_queued_001]

WITH EXECUTE AS OWNER
AS
BEGIN
SET NOCOUNT ON
-- Declare Variables for use by the SP.
DECLARE @task							nvarchar(512)
       ,@message_type_name				nvarchar(512)
	   ,@queue_name						nvarchar(512)
	   ,@msg							xml
	   ,@msgChar						nvarchar(500)
	   ,@sql							nvarchar(4000)
	   ,@dialog_handle					uniqueidentifier
	   ,@vault_source_system_name		nvarchar(50)
	   ,@vault_source_timevault			nvarchar(50)
	   ,@vault_source_table_schema		nvarchar(128)
	   ,@vault_source_table_name		nvarchar(128)
	   ,@vault_procedure_schema			nvarchar(128)
	   ,@vault_procedure_name			nvarchar(128)
	   ,@vault_source_table_run_type	nvarchar(50)
	   ,@vault_runkey					varchar(20)
	   ,@vault_run_key					int
	   ,@rowcount						int
	   ,@stage_delta_switch				varchar(100) = 'N'

-- Set Constant Values

set @queue_name = 'dv_scheduler_m001' -- Change for each Reveiver Procedure

-- Log4TSQL Journal Constants 
DECLARE @dogenerateerror		bit		 = 0
	   ,@dothrowerror			bit		 = 1
	    
DECLARE @SEVERITY_CRITICAL      smallint = 1;
DECLARE @SEVERITY_SEVERE        smallint = 2;
DECLARE @SEVERITY_MAJOR         smallint = 4;
DECLARE @SEVERITY_MODERATE      smallint = 8;
DECLARE @SEVERITY_MINOR         smallint = 16;
DECLARE @SEVERITY_CONCURRENCY   smallint = 32;
DECLARE @SEVERITY_INFORMATION   smallint = 256;
DECLARE @SEVERITY_SUCCESS       smallint = 512;
DECLARE @SEVERITY_DEBUG         smallint = 1024;
DECLARE @NEW_LINE               char(1)  = CHAR(10);

-- Log4TSQL Standard/ExceptionHandler variables
DECLARE	  @_Error         int
		, @_RowCount      int
		, @_Step          varchar(128)
		, @_Message       nvarchar(512)
		, @_ErrorContext  nvarchar(512)

-- Log4TSQL JournalWriter variables
DECLARE   @_FunctionName			varchar(255)
		, @_SprocStartTime			datetime
		, @_JournalOnOff			varchar(3)
		, @_Severity				smallint
		, @_ExceptionId				int
		, @_StepStartTime			datetime
		, @_ProgressText			nvarchar(max)

SET @_Error             = 0;
SET @_FunctionName      = OBJECT_NAME(@@PROCID);
SET @_Severity          = @SEVERITY_INFORMATION;
SET @_SprocStartTime    = sysdatetimeoffset();
SET @_ProgressText      = '' 
SET @_JournalOnOff      = log4.GetJournalControl(@_FunctionName, 'HOWTO');  -- left Group Name as HOWTO for now.


-- set the Parameters for logging:
SET @_ProgressText		= @_FunctionName + ' starting at ' + CONVERT(char(23), @_SprocStartTime, 121) + ' with inputs: '
						+ @NEW_LINE

BEGIN TRY
SET @_Step = 'Generate any required error';
IF @DoGenerateError = 1
   select 1 / 0
SET @_Step = 'Validate inputs';

SET @dialog_handle = NULL

/*--------------------------------------------------------------------------------------------------------------*/
SET @_Step = 'Get Defaults'

select @stage_delta_switch		= [default_varchar] from [dbo].[dv_defaults]		where default_type = 'Global'	and default_subtype = 'StageDeltaSwitch'

/*--------------------------------------------------------------------------------------------------------------*/

SET @_Step = 'Pull From the Queue';
WAITFOR ( RECEIVE TOP (1) @dialog_handle		= conversation_handle
                        , @message_type_name	= message_type_name
						, @msg					= convert(xml,message_body)
FROM [dv_scheduler_q001]), TIMEOUT 1000   -- Change for each Reveiver Procedure
                        
select @rowcount = @@ROWCOUNT

IF (@rowcount > 0)
	--END CONVERSATION @dialog_handle;
	BEGIN
	END CONVERSATION @dialog_handle;
	SET @_Step = 'Process the Message';	
	SET @msgChar = cast(@msg as varchar(500))
	IF @message_type_name = @queue_name
		BEGIN 
		    SELECT
			     @vault_runkey					= x.value('(/Request/RunKey)[1]'			,'VARCHAR(20)')
				,@vault_source_timevault		= x.value('(/Request/SourceTimeVault)[1]'	,'VARCHAR(50)')
				,@vault_source_system_name		= x.value('(/Request/SourceSystem)[1]'		,'VARCHAR(50)')
				,@vault_source_table_schema		= x.value('(/Request/SourceSchema)[1]'		,'VARCHAR(128)')
				,@vault_source_table_name		= x.value('(/Request/SourceTable)[1]'		,'VARCHAR(128)')
				,@vault_procedure_schema		= x.value('(/Request/ProcSchema)[1]'		,'VARCHAR(128)')
				,@vault_procedure_name			= x.value('(/Request/ProcName)[1]'			,'VARCHAR(128)')
				,@vault_source_table_run_type	= x.value('(/Request/RunType)[1]'			,'VARCHAR(50)')
			FROM @msg.nodes('/Request') AS T(x);
	
		
			set @vault_run_key = cast(ltrim(rtrim(@vault_runkey)) as int)
			select @vault_source_table_run_type = case when @vault_source_table_run_type = 'Default' then NULL else @vault_source_table_run_type end

			SELECT 1
			  FROM [dv_scheduler].[dv_run] r
			  inner join [dv_scheduler].[dv_run_manifest] m
			  on r.run_key = m.run_key
			  where 1=1
				and r.run_key = @vault_run_key
				and m.source_system_name = @vault_source_system_name
				and r.run_status = 'Started'
				and m.run_status = 'Queued'
			if @@rowcount > 0
			BEGIN
				EXECUTE[dv_scheduler].[dv_manifest_status_update] @vault_run_key ,@vault_source_system_name ,@vault_source_table_schema ,@vault_source_table_name ,'Processing'

				--WAITFOR DELAY '00:00:30'
				if not (ltrim(rtrim(@vault_procedure_schema)) = '' or ltrim(rtrim(@vault_procedure_name)) = '')
					BEGIN
					SET @_Step = 'Executing Procedure: '+ quotename(@vault_source_timevault) + '.' + quotename(@vault_procedure_schema) + '.' + quotename(@vault_procedure_name);
					print @_Step	
					set @sql = 'EXEC ' + quotename(@vault_source_timevault) + '.' + quotename(@vault_procedure_schema) + '.' + quotename(@vault_procedure_name)
					if @stage_delta_switch = 'Y' 
					set @sql = @sql + ' ''' + @vault_source_table_run_type + ''''
					exec (@SQL)
					END
				SET @_Step = 'Loading Table: ' + quotename(@vault_source_system_name) + '.' + quotename(@vault_source_table_schema) + '.' + quotename(@vault_source_table_name)
				exec [dbo].[dv_load_source_table] @vault_source_system_name, @vault_source_table_schema, @vault_source_table_name, @vault_source_table_run_type
				SET @_Step = 'Load Completed'
				EXECUTE [dv_scheduler].[dv_manifest_status_update] @vault_run_key ,@vault_source_system_name ,@vault_source_table_schema ,@vault_source_table_name ,'Completed'
			END
		END		
	ELSE 
		BEGIN		
			set @_Message = 'Message ' + quotename(@message_type_name) +  'Received but not Processed on Queue: ' + quotename(@queue_name) + quotename(@msgChar)
		    set @_ProgressText = @_ProgressText + @_Message + @NEW_LINE
		END
	END
SET @_ProgressText  = @_ProgressText + @NEW_LINE
				+ 'Step: [' + @_Step + '] completed ' 

IF @@TRANCOUNT > 0 COMMIT TRAN;

SET @_Message   = 'Completed Load of: ' + quotename(@vault_source_system_name) + '.' + quotename(@vault_source_table_schema) + '.' + quotename(@vault_source_table_name)
print @_Message

END TRY
BEGIN CATCH
SET @_ErrorContext	= 'Failed Load of: ' + isnull(quotename(@vault_source_system_name), '') + '.' + isnull(quotename(@vault_source_table_schema), '') + '.' + isnull(quotename(@vault_source_table_name), '') + @NEW_LINE
SET @_ErrorContext += 'For Message Type: ' + isnull(@message_type_name, '') + @NEW_LINE + 'For Message: ' + isnull(@msgChar, '')
IF (XACT_STATE() = -1) OR (@@TRANCOUNT > 0)
	BEGIN
		ROLLBACK TRAN;
		SET @_ErrorContext = @_ErrorContext + ' (Forced rolled back of all changes)';
	END
EXECUTE[dv_scheduler].[dv_manifest_status_update] @vault_run_key ,@vault_source_system_name ,@vault_source_table_schema ,@vault_source_table_name ,'Failed'

EXEC log4.ExceptionHandler
		  @ErrorContext  = @_ErrorContext
		, @ErrorNumber   = @_Error OUT
		, @ReturnMessage = @_Message OUT
		, @ExceptionId   = @_ExceptionId OUT
;
END CATCH

--/////////////////////////////////////////////////////////////////////////////////////////////////
OnComplete:
--/////////////////////////////////////////////////////////////////////////////////////////////////

	--! Clean up

	--!
	--! Use dbo.udf_FormatElapsedTime() to get a nicely formatted run time string e.g.
	--! "0 hr(s) 1 min(s) and 22 sec(s)" or "1345 milliseconds"
	--!
	IF @_Error = 0
		BEGIN
			SET @_Step			= 'OnComplete'
			SET @_Severity		= @SEVERITY_SUCCESS
			SET @_Message		= COALESCE(@_Message, @_Step)
								+ ' in a total run time of ' + log4.FormatElapsedTime(@_SprocStartTime, NULL, 3)
			SET @_ProgressText  = @_ProgressText + @NEW_LINE + @_Message;
		END
	ELSE
		BEGIN
			SET @_Step			= COALESCE(@_Step, 'OnError')
			SET @_Severity		= @SEVERITY_SEVERE
			SET @_Message		= COALESCE(@_Message, @_Step)
								+ ' after a total run time of ' + log4.FormatElapsedTime(@_SprocStartTime, NULL, 3)
			SET @_ProgressText  = @_ProgressText + @NEW_LINE + @_Message;
		END
	IF @_JournalOnOff = 'ON'
		EXEC log4.JournalWriter
				  @Task				= @_FunctionName
				, @FunctionName		= @_FunctionName
				, @StepInFunction	= @_Step
				, @MessageText		= @_Message
				, @Severity			= @_Severity
				, @ExceptionId		= @_ExceptionId
				--! Supply all the progress info after we've gone to such trouble to collect it
				, @ExtraInfo        = @_ProgressText

	--! Finally, throw an exception that will be detected by the caller
	IF @DoThrowError = 1 AND @_Error > 0
		RAISERROR(@_Message, 16, 99);

	SET NOCOUNT OFF;

	--! Return the value of @@ERROR (which will be zero on success)
	RETURN (@_Error);
END
GO
PRINT N'Creating [dv_scheduler].[dv_process_manifest]...';


GO
CREATE procedure [dv_scheduler].[dv_process_manifest]
( 
  @vault_run_key int
, @dogenerateerror               bit            = 0
, @dothrowerror                  bit			= 1
)
as

BEGIN
set nocount on

DECLARE @msg						XML
       ,@SBDialog					uniqueidentifier
	   ,@source_system_name			varchar(50)
	   ,@source_timevault           varchar(50)
	   ,@source_table_schema		varchar(128)		
	   ,@source_table_name			varchar(128)
	   ,@source_procedure_schema	varchar(128)
	   ,@source_procedure_name		varchar(128)
	   ,@source_table_load_type		varchar(50)
	   ,@queue						varchar(10)
	   ,@run_key					int
	   ,@delay_in_seconds			int
	   ,@delayChar					char(8)


-- Log4TSQL Journal Constants 
DECLARE @SEVERITY_CRITICAL      smallint = 1;
DECLARE @SEVERITY_SEVERE        smallint = 2;
DECLARE @SEVERITY_MAJOR         smallint = 4;
DECLARE @SEVERITY_MODERATE      smallint = 8;
DECLARE @SEVERITY_MINOR         smallint = 16;
DECLARE @SEVERITY_CONCURRENCY   smallint = 32;
DECLARE @SEVERITY_INFORMATION   smallint = 256;
DECLARE @SEVERITY_SUCCESS       smallint = 512;
DECLARE @SEVERITY_DEBUG         smallint = 1024;
DECLARE @NEW_LINE               char(1)  = CHAR(10);

-- Log4TSQL Standard/ExceptionHandler variables
DECLARE	  @_Error         int
		, @_RowCount      int
		, @_Step          varchar(128)
		, @_Message       nvarchar(512)
		, @_ErrorContext  nvarchar(512)

-- Log4TSQL JournalWriter variables
DECLARE   @_FunctionName			varchar(255)
		, @_SprocStartTime			datetime
		, @_JournalOnOff			varchar(3)
		, @_Severity				smallint
		, @_ExceptionId				int
		, @_StepStartTime			datetime
		, @_ProgressText			nvarchar(max)

SET @_Error             = 0;
SET @_FunctionName      = OBJECT_NAME(@@PROCID);
SET @_Severity          = @SEVERITY_INFORMATION;
SET @_SprocStartTime    = sysdatetimeoffset();
SET @_ProgressText      = '' 
SET @_JournalOnOff      = log4.GetJournalControl(@_FunctionName, 'HOWTO');  -- left Group Name as HOWTO for now.


-- set the Parameters for logging:

SET @_ProgressText		= @_FunctionName + ' starting at ' + CONVERT(char(23), @_SprocStartTime, 121) + ' with inputs: '
						+ @NEW_LINE + '    @vault_run_key                : ' + COALESCE(CAST(@vault_run_key AS varchar(20)), '<NULL>')
						+ @NEW_LINE + '    @DoGenerateError              : ' + COALESCE(CAST(@DoGenerateError AS varchar), '<NULL>')
						+ @NEW_LINE + '    @DoThrowError                 : ' + COALESCE(CAST(@DoThrowError AS varchar), '<NULL>')
						+ @NEW_LINE

BEGIN TRY
SET @_Step = 'Generate any required error';
IF @DoGenerateError = 1
   select 1 / 0
SET @_Step = 'Validate Inputs';

if not exists (select 1 from [dv_scheduler].[dv_run] where [run_key] = @vault_run_key and [run_status] = 'Scheduled')
   raiserror('Run must be "Scheduled" to be able to Start it', 16, 1)

if (SELECT count(*) from [dv_scheduler].[fn_check_manifest_for_circular_reference] (@vault_run_key)) <> 0
	begin
	select @_Message = 'Run Key: ' + cast(@vault_run_key as varchar(20)) + ' Contains Circular References. Please Investigate'
    RAISERROR(@_Message, 16, 1);
	end
/*--------------------------------------------------------------------------------------------------------------*/
SET @_Step = 'Get Defaults';
select @delay_in_seconds = cast([dbo].[fn_get_default_value] ('PollDelayInSeconds','Scheduler') as int)
select @delayChar = '00' + format(CONVERT(DATETIME, DATEADD(SECOND, @delay_in_seconds, 0)), ':mm:ss');

set @run_key = @vault_run_key

UPDATE [dv_scheduler].[dv_run] 
	set [run_status] = 'Started'
	   ,[run_start_datetime] = SYSDATETIMEOFFSET()
    where [run_key] = @run_key

SET @_Step = 'Start the Manifest';
while 1=1 -- The loop forcibly exits when all processing has completed
BEGIN
SET @_Step = 'Check Whether the Schedule is Complete'
    if not exists (
		select 1
		from [dv_scheduler].[dv_run] r
		inner join [dv_scheduler].[dv_run_manifest] m
		on m.run_key = r.run_key
		where 1=1
		  and r.run_key = @run_key
		  and isnull(m.run_status, '') <> 'Completed')
		BEGIN
		    UPDATE [dv_scheduler].[dv_run] 
			   set [run_status] = 'Completed'
	              ,[run_end_datetime] = SYSDATETIMEOFFSET()
			   where [run_key] = @run_key
			BREAK
		END
-- has there been a Failure?	
	if exists (
		select 1
		from [dv_scheduler].[dv_run] r
		inner join [dv_scheduler].[dv_run_manifest] m
		on m.run_key = r.run_key
		where 1=1
		and r.run_key = @run_key
		and (isnull(r.run_status, '') = 'Failed' or isnull(m.run_status, '') = 'Failed')
		)
		BEGIN
-- If so, Is there anything to run, assuming that what is queued or running now will succeed?
			if not exists(SELECT 1 FROM [dv_scheduler].[fn_get_waiting_scheduler_tasks] (@run_key, 'Potential'))
			BEGIN
-- If not, Fail the run.
				UPDATE [dv_scheduler].[dv_run] 
					set [run_status] = 'Failed'
	                   ,[run_end_datetime] = SYSDATETIMEOFFSET()
					where [run_key] = @run_key
				BREAK
			END
        END
-- has there been a Cancellation?	
	if exists (
		select 1
		from [dv_scheduler].[dv_run] r
		inner join [dv_scheduler].[dv_run_manifest] m
		on m.run_key = r.run_key
		where 1=1
		and r.run_key = @run_key
		and (isnull(r.run_status, '') = 'Cancelled' or isnull(m.run_status, '') = 'Cancelled')
		)
		BEGIN
-- If so, Is there anything to run, assuming that what is queued or running now will succeed?
			if not exists(SELECT 1 FROM [dv_scheduler].[fn_get_waiting_scheduler_tasks] (@run_key, 'Potential'))
			BEGIN
-- If not, Cancel the run.
				UPDATE [dv_scheduler].[dv_run] 
					set [run_status] = 'Cancelled'
	                   ,[run_end_datetime] = SYSDATETIMEOFFSET()
					where [run_key] = @run_key
				BREAK
			END
        END
-- There is still something to run so Get a list of Tasks to run:
SET @_Step = 'Queue as Set of Tasks'
	DECLARE manifest_cursor CURSOR FOR  
	SELECT [source_system_name]
	      ,[source_timevault]
		  ,[source_table_schema]	
		  ,[source_table_name]	
		  ,[source_procedure_schema]	
		  ,[source_procedure_name]	
		  ,[source_table_load_type]	
		  ,[queue]
	FROM [dv_scheduler].[fn_get_waiting_scheduler_tasks] (@run_key, DEFAULT)
	order by [priority]
	OPEN manifest_cursor
	FETCH NEXT FROM manifest_cursor 
	  INTO @source_system_name
	      ,@source_timevault
		  ,@source_table_schema
		  ,@source_table_name
		  ,@source_procedure_schema 
		  ,@source_procedure_name
		  ,@source_table_load_type
		  ,@queue
	
	WHILE @@FETCH_STATUS = 0   
	BEGIN   
		
	SET @msg = N'
	<Request>
	      <RunKey>'				+ isnull(cast(@run_key as varchar(20)), '')		+ N'</RunKey>
		  <SourceTimeVault>'	+ isnull(@source_timevault, '')					+ N'</SourceTimeVault>
		  <SourceSystem>'		+ isnull(@source_system_name, '')				+ N'</SourceSystem>
		  <SourceSchema>'		+ isnull(@source_table_schema, '')				+ N'</SourceSchema>
		  <SourceTable>'		+ isnull(@source_table_name, '')				+ N'</SourceTable>
		  <ProcSchema>'			+ isnull(@source_procedure_schema, '')			+ N'</ProcSchema>
		  <ProcName>'			+ isnull(@source_procedure_name, '')			+ N'</ProcName>
		  <RunType>'			+ isnull(@source_table_load_type, '')			+ N'</RunType>
	</Request>'
	SET @_Step = 'Queue a Single Task: ' + cast(@msg as varchar(4000))
	BEGIN TRANSACTION
	IF @queue = '001'
	BEGIN
		BEGIN DIALOG CONVERSATION @SBDialog
			FROM SERVICE dv_scheduler_s001
			TO SERVICE  'dv_scheduler_s001'
			ON CONTRACT  dv_scheduler_c001
			WITH ENCRYPTION = OFF;
			--Send messages on Dialog
		SEND ON CONVERSATION @SBDialog
			MESSAGE TYPE dv_scheduler_m001 (@Msg)
	END
	ELSE
	BEGIN
		BEGIN DIALOG CONVERSATION @SBDialog
			FROM SERVICE dv_scheduler_s002
			TO SERVICE	'dv_scheduler_s002'
			ON CONTRACT	 dv_scheduler_c002
			WITH ENCRYPTION = OFF;
			--Send messages on Dialog
		SEND ON CONVERSATION @SBDialog
			MESSAGE TYPE dv_scheduler_m002 (@Msg)
	END
	END CONVERSATION @SBDialog
	EXECUTE[dv_scheduler].[dv_manifest_status_update] @run_key ,@source_system_name ,@source_table_schema ,@source_table_name ,'Queued'
	COMMIT
	FETCH NEXT FROM manifest_cursor 
	  INTO @source_system_name
	      ,@source_timevault
		  ,@source_table_schema
		  ,@source_table_name 
		  ,@source_procedure_schema 
		  ,@source_procedure_name
		  ,@source_table_load_type
		  ,@queue
	END   
	
	CLOSE manifest_cursor   
	DEALLOCATE manifest_cursor
    WAITFOR DELAY @delayChar
END
/*--------------------------------------------------------------------------------------------------------------*/

SET @_ProgressText  = @_ProgressText + @NEW_LINE
				+ 'Step: [' + @_Step + '] completed ' 

IF @@TRANCOUNT > 0 COMMIT TRAN;

SET @_Message   = 'Successfully Completed Schedule with Run_Key: ' + cast(@run_key as varchar(20))

END TRY
BEGIN CATCH
SET @_ErrorContext	= 'Failed to Complete Schedule with Run_Key: ' + cast(@run_key as varchar(20))
IF (XACT_STATE() = -1) OR (@@TRANCOUNT > 0) -- undocumented uncommitable transaction
	BEGIN
		ROLLBACK TRAN;
		SET @_ErrorContext = @_ErrorContext + ' (Forced rolled back of all changes)';
	END
	
EXEC log4.ExceptionHandler
		  @ErrorContext  = @_ErrorContext
		, @ErrorNumber   = @_Error OUT
		, @ReturnMessage = @_Message OUT
		, @ExceptionId   = @_ExceptionId OUT
;
END CATCH

--/////////////////////////////////////////////////////////////////////////////////////////////////
OnComplete:
--/////////////////////////////////////////////////////////////////////////////////////////////////

	--! Clean up

	--!
	--! Use dbo.udf_FormatElapsedTime() to get a nicely formatted run time string e.g.
	--! "0 hr(s) 1 min(s) and 22 sec(s)" or "1345 milliseconds"
	--!
	IF @_Error = 0
		BEGIN
			SET @_Step			= 'OnComplete'
			SET @_Severity		= @SEVERITY_SUCCESS
			SET @_Message		= COALESCE(@_Message, @_Step)
								+ ' in a total run time of ' + log4.FormatElapsedTime(@_SprocStartTime, NULL, 3)
			SET @_ProgressText  = @_ProgressText + @NEW_LINE + @_Message;
		END
	ELSE
		BEGIN
			SET @_Step			= COALESCE(@_Step, 'OnError')
			SET @_Severity		= @SEVERITY_SEVERE
			SET @_Message		= COALESCE(@_Message, @_Step)
								+ ' after a total run time of ' + log4.FormatElapsedTime(@_SprocStartTime, NULL, 3)
			SET @_ProgressText  = @_ProgressText + @NEW_LINE + @_Message;
		END

	IF @_JournalOnOff = 'ON'
		EXEC log4.JournalWriter
				  @Task				= @_FunctionName
				, @FunctionName		= @_FunctionName
				, @StepInFunction	= @_Step
				, @MessageText		= @_Message
				, @Severity			= @_Severity
				, @ExceptionId		= @_ExceptionId
				--! Supply all the progress info after we've gone to such trouble to collect it
				, @ExtraInfo        = @_ProgressText

	--! Finally, throw an exception that will be detected by the caller
	IF @DoThrowError = 1 AND @_Error > 0
		RAISERROR(@_Message, 16, 99);

	SET NOCOUNT OFF;

	--! Return the value of @@ERROR (which will be zero on success)
	RETURN (@_Error);
END
GO
PRINT N'Creating [dbo].[dv_scheduler_q001]...';


GO
CREATE QUEUE [dbo].[dv_scheduler_q001]
    WITH ACTIVATION (STATUS = ON, PROCEDURE_NAME = [dv_scheduler].[dv_process_queued_001], MAX_QUEUE_READERS = 4, EXECUTE AS N'SBLogin');


GO
PRINT N'Creating [dbo].[dv_scheduler_q002]...';


GO
CREATE QUEUE [dbo].[dv_scheduler_q002]
    WITH ACTIVATION (STATUS = ON, PROCEDURE_NAME = [dv_scheduler].[dv_process_queued_002], MAX_QUEUE_READERS = 3, EXECUTE AS N'SBLogin');


GO
PRINT N'Creating [dv_scheduler_s001]...';


GO
CREATE SERVICE [dv_scheduler_s001]
    AUTHORIZATION [dbo]
    ON QUEUE [dbo].[dv_scheduler_q001]
    ([dv_scheduler_c001]);


GO
PRINT N'Creating [dv_scheduler_s002]...';


GO
CREATE SERVICE [dv_scheduler_s002]
    AUTHORIZATION [dbo]
    ON QUEUE [dbo].[dv_scheduler_q002]
    ([dv_scheduler_c002]);


GO
PRINT N'Creating [log4].[FormatElapsedTime].[MS_Description]...';


GO
EXECUTE sp_addextendedproperty @name = N'MS_Description', @value = N'Returns a string describing the time elapsed between start and end time', @level0type = N'SCHEMA', @level0name = N'log4', @level1type = N'FUNCTION', @level1name = N'FormatElapsedTime';


GO
PRINT N'Creating [log4].[GetJournalControl].[MS_Description]...';


GO
EXECUTE sp_addextendedproperty @name = N'MS_Description', @value = N'Returns the ON/OFF value for the specified Journal Name, or Group Name if Module not found or the system default if neither is found', @level0type = N'SCHEMA', @level0name = N'log4', @level1type = N'FUNCTION', @level1name = N'GetJournalControl';


GO
PRINT N'Creating [log4].[SessionInfoOutput].[MS_Description]...';


GO
EXECUTE sp_addextendedproperty @name = N'MS_Description', @value = N'Outputs session info from master.sys.dm_exec_sessions for the current @@SPID', @level0type = N'SCHEMA', @level0name = N'log4', @level1type = N'PROCEDURE', @level1name = N'SessionInfoOutput';


GO
PRINT N'Creating [log4].[PrintString].[MS_Description]...';


GO
EXECUTE sp_addextendedproperty @name = N'MS_Description', @value = N'Prints the supplied string respecting all line feeds and/or carriage returns except where no line feeds are found, in which case the output is printed in user-specified lengths', @level0type = N'SCHEMA', @level0name = N'log4', @level1type = N'PROCEDURE', @level1name = N'PrintString';


GO
PRINT N'Creating [log4].[JournalReader].[MS_Description]...';


GO
EXECUTE sp_addextendedproperty @name = N'MS_Description', @value = N'Returns all Journal entries matching the specified search criteria', @level0type = N'SCHEMA', @level0name = N'log4', @level1type = N'PROCEDURE', @level1name = N'JournalReader';


GO
PRINT N'Creating [log4].[JournalPrinter].[MS_Description]...';


GO
EXECUTE sp_addextendedproperty @name = N'MS_Description', @value = N'Prints the contents of JournalDetail for the specified Journal ID respecting all line feeds and/or carriage returns', @level0type = N'SCHEMA', @level0name = N'log4', @level1type = N'PROCEDURE', @level1name = N'JournalPrinter';


GO
PRINT N'Creating [log4].[ExceptionReader].[MS_Description]...';


GO
EXECUTE sp_addextendedproperty @name = N'MS_Description', @value = N'Returns all Exceptions matching the specified search criteria', @level0type = N'SCHEMA', @level0name = N'log4', @level1type = N'PROCEDURE', @level1name = N'ExceptionReader';


GO
PRINT N'Creating [log4].[ExceptionHandler].[MS_Description]...';


GO
EXECUTE sp_addextendedproperty @name = N'MS_Description', @value = N'Returns error info as output parameters and writes info to Exception table', @level0type = N'SCHEMA', @level0name = N'log4', @level1type = N'PROCEDURE', @level1name = N'ExceptionHandler';


GO
PRINT N'Creating [log4].[JournalWriter].[MS_Description]...';


GO
EXECUTE sp_addextendedproperty @name = N'MS_Description', @value = N'Adds a journal entry summarising task progress, completion or failure msgs etc.', @level0type = N'SCHEMA', @level0name = N'log4', @level1type = N'PROCEDURE', @level1name = N'JournalWriter';


GO
PRINT N'Creating [log4].[JournalCleanup].[MS_Description]...';


GO
EXECUTE sp_addextendedproperty @name = N'MS_Description', @value = N'Deletes all Journal and Exception entries older than the specified days', @level0type = N'SCHEMA', @level0name = N'log4', @level1type = N'PROCEDURE', @level1name = N'JournalCleanup';


GO
/*
Post-Deployment Script Template							
--------------------------------------------------------------------------------------
 This file contains SQL statements that will be appended to the build script.		
 Use SQLCMD syntax to include a file in the post-deployment script.			
 Example:      :r .\myfile.sql								
 Use SQLCMD syntax to reference a variable in the post-deployment script.		
 Example:      :setvar TableName MyTable							
               SELECT * FROM [$(TableName)]					
--------------------------------------------------------------------------------------
*/
/*  Default Release  */
SET IDENTITY_INSERT [dv_release].[dv_release_master] ON;
GO

MERGE INTO [dv_release].[dv_release_master] AS trgt
	USING	(VALUES
			(0,0,'<N/A>','<N/A>','<N/A>')
			) AS src([release_key],[release_number],[release_description],[reference_number],[reference_source])
	ON
		trgt.[release_key] = src.[release_key]
	WHEN MATCHED THEN
		UPDATE SET
		  [release_number] = src.[release_number]
		, [release_description] = src.[release_description]
		, [reference_number] = src.[reference_number]
		, [reference_source] = src.[reference_source]
		
	WHEN NOT MATCHED BY TARGET THEN
		INSERT ([release_key],[release_number],[release_description],[reference_number],[reference_source])
		VALUES ([release_key],[release_number],[release_description],[reference_number],[reference_source])
	WHEN NOT MATCHED BY SOURCE THEN
		DELETE
	;
GO

SET IDENTITY_INSERT [dv_release].[dv_release_master] OFF;
GO

/*  Default Hub  */
SET IDENTITY_INSERT [dbo].[dv_hub] ON;
GO

MERGE INTO [dbo].[dv_hub] AS trgt 
USING	(VALUES (0,'Default_Hub',NULL,'Default','Default',0)) AS src([hub_key],[hub_name],[hub_abbreviation],[hub_schema],[hub_database],[release_key])
	ON
		trgt.[hub_key] = src.[hub_key]
	WHEN MATCHED THEN
		UPDATE SET
			[hub_name] = src.[hub_name]
		, [hub_abbreviation] = src.[hub_abbreviation]
		, [hub_schema] = src.[hub_schema]
		, [hub_database] = src.[hub_database]
		, [release_key] = src.[release_key]
	WHEN NOT MATCHED BY TARGET THEN
		INSERT ([hub_key],[hub_name],[hub_abbreviation],[hub_schema],[hub_database],[release_key])
		VALUES ([hub_key],[hub_name],[hub_abbreviation],[hub_schema],[hub_database],[release_key])
;
GO

SET IDENTITY_INSERT [dbo].[dv_hub] OFF;
GO

/*  Default Link  */
SET IDENTITY_INSERT [dbo].[dv_link] ON;
GO

MERGE INTO [dbo].[dv_link] AS trgt USING (VALUES (0,'Default_Link',NULL,'Default','Default',0)) 
		AS src([link_key],[link_name],[link_abbreviation],[link_schema],[link_database],[release_key])
	ON
		trgt.[link_key] = src.[link_key]
	WHEN MATCHED THEN
		UPDATE SET
			[link_name] = src.[link_name]
		, [link_abbreviation] = src.[link_abbreviation]
		, [link_schema] = src.[link_schema]
		, [link_database] = src.[link_database]
		, [release_key] = src.[release_key]
	WHEN NOT MATCHED BY TARGET THEN
		INSERT ([link_key],[link_name],[link_abbreviation],[link_schema],[link_database],[release_key])
		VALUES ([link_key],[link_name],[link_abbreviation],[link_schema],[link_database],[release_key])
;
GO

SET IDENTITY_INSERT [dbo].[dv_link] OFF;
GO


MERGE INTO [dbo].[dv_defaults] AS trgt 
USING (VALUES	('Global','LowDate',1,'datetime',NULL,NULL,'Jan  1 1900 12:00:00:000AM',0),
				('Global','HighDate',1,'datetime',NULL,NULL,'Dec 31 9999 12:00:00:000AM',0),
				('Global','DefaultLoadDateTime',1,'varchar',NULL,'sysdatetimeoffset()',NULL,0),
				('Global','FailedLookupKey',1,'int',-999,NULL,NULL,0),
				('Global','UnknownValue',1,'varchar',NULL,'<Unknown>',NULL,0),
				('Global','NAValue',1,'varchar',NULL,'<N/A>',NULL,0),
				('Global','MissingValue',1,'varchar',NULL,'<Missing>',NULL,0),
				('Global','Not RequiredValue',1,'varchar',NULL,'<Not Required>',NULL,0),
				('Hub','Prefix',1,'varchar',NULL,'h_',NULL,0),
				('Hub','Schema',1,'varchar',NULL,'Hub',NULL,0),
				('Hub','Filegroup',1,'varchar',NULL,'PRIMARY',NULL,0),
				('HubSurrogate','Suffix',1,'varchar',NULL,'_key',NULL,0),
				('Lnk','Prefix',1,'varchar',NULL,'l_',NULL,0),
				('Lnk','Schema',1,'varchar',NULL,'Lnk',NULL,0),
				('Lnk','Filegroup',1,'varchar',NULL,'PRIMARY',NULL,0),
				('LnkSurrogate','Suffix',1,'varchar',NULL,'_key',NULL,0),
				('Sat','Prefix',1,'varchar',NULL,'s_',NULL,0),
				('Sat','Schema',1,'varchar',NULL,'Sat',NULL,0),
				('Sat','Filegroup',1,'varchar',NULL,'PRIMARY',NULL,0),
				('SatSurrogate','Suffix',1,'varchar',NULL,'_key',NULL,0),
				('dv_col_metrics','RunType',1,'varchar',NULL,'Weekly', NULL, 0),
				('Scheduler','PollDelayInSeconds',1,'int',30,NULL,NULL,0)
			) AS src([default_type],[default_subtype],[default_sequence],[data_type],[default_integer],[default_varchar],[default_dateTime],[release_key])
	ON
		trgt.[default_type]     = src.[default_type] and 
		trgt.[default_subtype]  = src.[default_subtype]
	WHEN MATCHED THEN
		UPDATE SET
		  [default_type]		= src.[default_type]
		, [default_subtype]		= src.[default_subtype]
		, [default_sequence]	= src.[default_sequence]
		, [data_type]			= src.[data_type]
		, [default_integer]		= src.[default_integer]
		, [default_varchar]		= src.[default_varchar]
		, [default_dateTime]	= src.[default_dateTime]
		, [release_key]			= src.[release_key]
	WHEN NOT MATCHED BY TARGET THEN
		INSERT ([default_type],[default_subtype],[default_sequence],[data_type],[default_integer],[default_varchar],[default_dateTime],[release_key])
		VALUES ([default_type],[default_subtype],[default_sequence],[data_type],[default_integer],[default_varchar],[default_dateTime],[release_key])
	;
GO

MERGE INTO [dbo].[dv_default_column] AS trgt 
USING	(VALUES ('Hub','Object_Key',1,'h_','%','_key','int',NULL,NULL,NULL,NULL,0,1,0,0),
			    ('Hub','Load_Date_Time',2,NULL,'dv_load_date_time',NULL,'datetimeoffset',NULL,7,NULL,NULL,0,0,0,0),
			    ('Hub','Data_Source',3,NULL,'dv_record_source',NULL,'varchar',50,NULL,NULL,NULL,0,0,0,0),
			    ('Lnk','Object_Key',1,'l_','%','_key','int',NULL,NULL,NULL,NULL,0,1,0,0),
			    ('Lnk','Load_Date_Time',2,NULL,'dv_load_date_time',NULL,'datetimeoffset',NULL,7,NULL,NULL,0,0,0,0),
			    ('Lnk','Data_Source',3,NULL,'dv_record_source',NULL,'varchar',50,NULL,NULL,NULL,0,0,0,0),
			    ('Sat','Object_Key',1,'s_','%','_key','int',NULL,NULL,NULL,NULL,0,1,0,0),
			    ('Sat','Source_Date_Time',3,NULL,'dv_source_date_time',NULL,'datetimeoffset',NULL,7,NULL,NULL,0,0,0,0),
			    ('Sat','Data_Source',4,NULL,'dv_record_source',NULL,'varchar',50,NULL,NULL,NULL,0,0,0,0),
			    ('Sat','Current_Row',5,NULL,'dv_row_is_current',NULL,'bit',NULL,NULL,NULL,NULL,0,0,0,0),
			    ('Sat','Tombstone_Indicator',6,NULL,'dv_is_tombstone',NULL,'bit',NULL,NULL,NULL,NULL,0,0,0,0),
			    ('Sat','Version_Start_Date',7,NULL,'dv_rowstartdate',NULL,'datetimeoffset',NULL,7,NULL,NULL,0,0,0,0),
			    ('Sat','Version_End_Date',8,NULL,'dv_rowenddate',NULL,'datetimeoffset',NULL,7,NULL,NULL,0,0,0,0)			  
			) AS src([object_type],[object_column_type],[ordinal_position],[column_prefix],[column_name],[column_suffix],[column_type],[column_length],[column_precision],[column_scale],[collation_Name],[is_nullable],[is_pk],[discard_flag],[release_key])
	ON
		trgt.[object_type]			= src.[object_type] and 
		trgt.[object_column_type]	= src.[object_column_type]
	WHEN MATCHED THEN
		UPDATE SET
		  [object_type]				= src.[object_type]
		, [object_column_type]		= src.[object_column_type]
		, [ordinal_position]		= src.[ordinal_position]
		, [column_prefix]			= src.[column_prefix]
		, [column_name]				= src.[column_name]
		, [column_suffix]			= src.[column_suffix]
		, [column_type]				= src.[column_type]
		, [column_length]			= src.[column_length]
		, [column_precision]		= src.[column_precision]
		, [column_scale]			= src.[column_scale]
		, [collation_Name]			= src.[collation_Name]
		, [is_nullable]				= src.[is_nullable]
		, [is_pk]					= src.[is_pk]
		, [discard_flag]			= src.[discard_flag]
		, [release_key]				= src.[release_key]
	WHEN NOT MATCHED BY TARGET THEN
		INSERT ([object_type],[object_column_type],[ordinal_position],[column_prefix],[column_name],[column_suffix],[column_type],[column_length],[column_precision],[column_scale],[collation_Name],[is_nullable],[is_pk],[discard_flag],[release_key])
		VALUES ([object_type],[object_column_type],[ordinal_position],[column_prefix],[column_name],[column_suffix],[column_type],[column_length],[column_precision],[column_scale],[collation_Name],[is_nullable],[is_pk],[discard_flag],[release_key])
	;
GO

IF NOT EXISTS
    (
        SELECT 1 FROM [log4].[Severity] WHERE [SeverityId] = 1
    )
  INSERT INTO [log4].[Severity]
      (
        [SeverityId]
      , [SeverityName]
      )
  VALUES
      (
        1
      , 'Showstopper/Critical Failure'
      )
ELSE
    UPDATE
        [log4].[Severity]
    SET
          [SeverityName] = 'Showstopper/Critical Failure'
    WHERE
        [SeverityId] = 1
GO

IF NOT EXISTS
    (
        SELECT 1 FROM [log4].[Severity] WHERE [SeverityId] = 2
    )
  INSERT INTO [log4].[Severity]
      (
        [SeverityId]
      , [SeverityName]
      )
  VALUES
      (
        2
      , 'Severe Failure'
      )
ELSE
    UPDATE
        [log4].[Severity]
    SET
          [SeverityName] = 'Severe Failure'
    WHERE
        [SeverityId] = 2
GO

IF NOT EXISTS
    (
        SELECT 1 FROM [log4].[Severity] WHERE [SeverityId] = 4
    )
  INSERT INTO [log4].[Severity]
      (
        [SeverityId]
      , [SeverityName]
      )
  VALUES
      (
        4
      , 'Major Failure'
      )
ELSE
    UPDATE
        [log4].[Severity]
    SET
          [SeverityName] = 'Major Failure'
    WHERE
        [SeverityId] = 4
GO

IF NOT EXISTS
    (
        SELECT 1 FROM [log4].[Severity] WHERE [SeverityId] = 8
    )
  INSERT INTO [log4].[Severity]
      (
        [SeverityId]
      , [SeverityName]
      )
  VALUES
      (
        8
      , 'Moderate Failure'
      )
ELSE
    UPDATE
        [log4].[Severity]
    SET
          [SeverityName] = 'Moderate Failure'
    WHERE
        [SeverityId] = 8
GO

IF NOT EXISTS
    (
        SELECT 1 FROM [log4].[Severity] WHERE [SeverityId] = 16
    )
  INSERT INTO [log4].[Severity]
      (
        [SeverityId]
      , [SeverityName]
      )
  VALUES
      (
        16
      , 'Minor Failure'
      )
ELSE
    UPDATE
        [log4].[Severity]
    SET
          [SeverityName] = 'Minor Failure'
    WHERE
        [SeverityId] = 16
GO

IF NOT EXISTS
    (
        SELECT 1 FROM [log4].[Severity] WHERE [SeverityId] = 32
    )
  INSERT INTO [log4].[Severity]
      (
        [SeverityId]
      , [SeverityName]
      )
  VALUES
      (
        32
      , 'Concurrency Violation'
      )
ELSE
    UPDATE
        [log4].[Severity]
    SET
          [SeverityName] = 'Concurrency Violation'
    WHERE
        [SeverityId] = 32
GO

IF NOT EXISTS
    (
        SELECT 1 FROM [log4].[Severity] WHERE [SeverityId] = 64
    )
  INSERT INTO [log4].[Severity]
      (
        [SeverityId]
      , [SeverityName]
      )
  VALUES
      (
        64
      , 'Reserved for future Use 1'
      )
ELSE
    UPDATE
        [log4].[Severity]
    SET
          [SeverityName] = 'Reserved for future Use 1'
    WHERE
        [SeverityId] = 64
GO

IF NOT EXISTS
    (
        SELECT 1 FROM [log4].[Severity] WHERE [SeverityId] = 128
    )
  INSERT INTO [log4].[Severity]
      (
        [SeverityId]
      , [SeverityName]
      )
  VALUES
      (
        128
      , 'Reserved for future Use 2'
      )
ELSE
    UPDATE
        [log4].[Severity]
    SET
          [SeverityName] = 'Reserved for future Use 2'
    WHERE
        [SeverityId] = 128
GO

IF NOT EXISTS
    (
        SELECT 1 FROM [log4].[Severity] WHERE [SeverityId] = 256
    )
  INSERT INTO [log4].[Severity]
      (
        [SeverityId]
      , [SeverityName]
      )
  VALUES
      (
        256
      , 'Informational'
      )
ELSE
    UPDATE
        [log4].[Severity]
    SET
          [SeverityName] = 'Informational'
    WHERE
        [SeverityId] = 256
GO

IF NOT EXISTS
    (
        SELECT 1 FROM [log4].[Severity] WHERE [SeverityId] = 512
    )
  INSERT INTO [log4].[Severity]
      (
        [SeverityId]
      , [SeverityName]
      )
  VALUES
      (
        512
      , 'Success'
      )
ELSE
    UPDATE
        [log4].[Severity]
    SET
          [SeverityName] = 'Success'
    WHERE
        [SeverityId] = 512
GO

IF NOT EXISTS
    (
        SELECT 1 FROM [log4].[Severity] WHERE [SeverityId] = 1024
    )
  INSERT INTO [log4].[Severity]
      (
        [SeverityId]
      , [SeverityName]
      )
  VALUES
      (
        1024
      , 'Debug'
      )
ELSE
    UPDATE
        [log4].[Severity]
    SET
          [SeverityName] = 'Debug'
    WHERE
        [SeverityId] = 1024
GO

MERGE INTO [log4].[JournalControl] AS trgt 
USING	(VALUES ('dv_create_DV_table'				,'OFF'),
				('dv_create_hub_table'				,'OFF'),
				('dv_create_link_table'				,'OFF'),
				('dv_create_sat_table'				,'OFF'),
				('dv_load_hub_table'				,'OFF'),
				('dv_load_sat_table'				,'OFF'),
				('dv_load_source_table_key_lookup'	,'OFF'),
				('dv_load_link_table'				,'OFF'),
				('dv_load_sats_for_source_table'	,'OFF'),
				('dv_load_source_table'				,'OFF'),
				('IntegrityChecks'					,'ON'),
				('SYSTEM_OVERRIDE'					,'ON'),
				('SYSTEM_DEFAULT'					,'OFF')
			) AS src([ModuleName],[OnOffSwitch])
	ON
		trgt.[ModuleName]			= src.[ModuleName] 
	WHEN MATCHED THEN
		UPDATE SET
		  [OnOffSwitch]				= src.[OnOffSwitch]
	WHEN NOT MATCHED BY TARGET THEN
		INSERT ([ModuleName],[OnOffSwitch])
		VALUES ([ModuleName],[OnOffSwitch])
	;
select * from [log4].[JournalControl]
GO

GO
DECLARE @VarDecimalSupported AS BIT;

SELECT @VarDecimalSupported = 0;

IF ((ServerProperty(N'EngineEdition') = 3)
    AND (((@@microsoftversion / power(2, 24) = 9)
          AND (@@microsoftversion & 0xffff >= 3024))
         OR ((@@microsoftversion / power(2, 24) = 10)
             AND (@@microsoftversion & 0xffff >= 1600))))
    SELECT @VarDecimalSupported = 1;

IF (@VarDecimalSupported > 0)
    BEGIN
        EXECUTE sp_db_vardecimal_storage_format N'$(DatabaseName)', 'ON';
    END


GO
ALTER DATABASE [$(DatabaseName)]
    SET MULTI_USER 
    WITH ROLLBACK IMMEDIATE;


GO
PRINT N'Update complete.';


GO
